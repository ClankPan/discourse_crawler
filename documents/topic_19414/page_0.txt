domwoe | 2023-04-25 15:33:53 UTC | #1

## Overview

Status: Open
Project Type: Cooperative - Multiple workers can submit work, and the bounty is shared
Time Commitment: Weeks
Experience Level: Intermediate
Size: USD 7'000 in ICP (at time of distribution)

## Description
As part of the ICRC process, we aim to provide production-level implementation code to speed up adoption. This bounty concerns the ICRC-7 NFT standard which is being finalized in the working group.

The applicant is expected to have understood the current draft of ICRC-7 as well as the intentions of the working group and the design trade-offs made, implement according to the specification, and report back to the working group on a bi-weekly basis about any findings during implementation and suggestions on how the standard could be improved. 

Familiarity with the fungible token standards ICRC-1, ICRC-2, and ICRC-3 is a plus.

## Use Cases
NFTs on the IC.

## Acceptance Criteria
- The implementation shall fully implement the ICRC-7 draft proposal.
- The code shall be of production quality, have good documentation and reasonable test coverage.
- The code shall be open sourced with an MIT license.
- The code will be considered 80% complete when the above criteria are met, and 100% complete when it passes the security audit with all problems fixed (the applicant does not bear the cost of the security audit).

## How to apply?
Include links to previous relevant work.
Include a brief overview of how you will complete the task.
Post your application text in this thread.

## References
[1] ICRC-7 Github. https://github.com/dfinity/ICRC/tree/main/ICRCs/ICRC-7

-------------------------

ttt | 2023-04-13 15:32:18 UTC | #2

Hello. I would like to be assigned to work on this bounty.

**Relevant experience:**

* Solid understanding of IC fundamentals relevant to the bounty (inter-canister calls, DID, etc) and NFT's in general
* Successfully completed bounty to write a Rust Canister: https://forum.dfinity.org/t/assigned-icdevs-org-bounty-33-reg-ex-utility-canister-rust-4-000/17886 (https://github.com/holykol/ic-regex)

**Rough estimate timeline:**

1. Designing base canister with basic read methods outlined in spec 3-4d
1. Implementing transfer method 1-2d
1. Implementing transaction deduplication 1-3d 
1. Making sure implementation is conformant to spec and testing implementation 4-5d

-------------------------

benji | 2023-04-20 09:20:14 UTC | #3

Hello. Thank you for your interest. Would you be able to participate in our next WG meeting on Tue 25th? It'd be helpful if you could better understand our goals. @ttt

-------------------------

ttt | 2023-04-22 06:54:10 UTC | #4

I will definitely try. Can you DM me the link? I couldn't find myself.

-------------------------

domwoe | 2023-04-24 15:57:14 UTC | #5

I've changed the bounty to allow proposals for a Rust or a Motoko implementation.

-------------------------

domwoe | 2023-04-24 15:58:04 UTC | #6

The event is in the general [Technical Working Group calendar](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t).

-------------------------

benji | 2023-04-25 15:28:50 UTC | #7

@ttt @domwoe We agreed in the WG meeting of Apr 25 2023 to attribute this bounty to @ttt. He estimates 3 weeks to complete this implementation.

-------------------------

benji | 2023-04-25 15:35:14 UTC | #8

Additionally, the HTTP interface and the transaction history are not part of this bounty, there will be a separate bounty in the future for those points.

The implementation is expected to be of production quality, including our best practices, using stable memory.

-------------------------

ttt | 2023-05-15 14:35:42 UTC | #9

Hey. Sorry for not updating you on my progress. I've published my workings here: https://github.com/holykol/icrc7

There are a few todos left, I expect to complete them in a ~2-3 days:
- [] stable memory
- [] approvals
- [] readme and CI

I am using [ic-kit](https://docs.rs/ic-kit/latest/ic_kit/) for auto .did generation and excellent testing harness. Thanks to it the code already has about 70% coverage and I expect that to increase in a few days

-------------------------

stopak | 2023-05-15 14:49:40 UTC | #10

On a side note, I will be expanding icpunks standard to match icrc7, so we will have two implementations :slight_smile:

-------------------------

ttt | 2023-05-18 19:48:05 UTC | #11

Few questions and random notes regarding spec:

  * why does `text` in `icrc7_metadata : (nat) -> (vec record { text; Metadata }) query;` mean? What should it represent?

   * took liberty of naming fields in `type Metadata = variant { Nat : nat; Int : int; Text : text; Blob : blob }`, see below:
```
pub struct TokenMetadata {
    pub icrc7_id: TokenID,
    pub icrc7_name: String,
    pub icrc7_image: Vec<u8>,
}
```

   * Just a note: if transfer only accepted one token, the code for this and all future implementations would be simpler. Was this added because of high latency of updates?

   * If approvals can have infinite duration (when `expires_at` is set to `None`), shouldn't there be a way to revoke approval and list existing approvals?

   * I assume approval does not expire when it is used, right? From my background: in Solana there can be only one approval for account at a time. Also after delegate used approval (e.g. transferred something), approval gets revoked. 

   * Should approvals also be deduplicated? I assume yes because of `memo` and `created_at` fields

-------------------------

ttt | 2023-05-18 23:33:47 UTC | #12

I've pushed support approvals, transaction deduplication and stable memory. 
All that remains now is more documentation and timer for purging old transfers. Also maybe GenericError handling can be improved a bit.

The code coverage shows 82.56%, but it's definitely higher because [`grcov`](https://github.com/mozilla/grcov) treats structs as uncovered lines of code for some reason. Also because 99% of the tests are integrational (thanks, `ic-kit`!), I'm sure they can be ported with little or no effort to make sure another implementation is compatible with spec. Definitely a thing worth researching. 

@domwoe @benji I think the project is pretty stable now and is ready for review. I'm looking for in-depth feedback.

-------------------------

stopak | 2023-05-19 07:08:03 UTC | #13

Can you share the github repo? I would like to test lightic testing framework against your integration tests

-------------------------

ttt | 2023-05-19 11:39:22 UTC | #14

it's https://github.com/holykol/icrc7/blob/master/src/icrc7/tests/integration.rs, as I mentioned it will require some adaption if yours is not written using ic-kit @stopak

-------------------------

cryptoschindler | 2023-05-31 12:50:05 UTC | #15

[quote="ttt, post:11, topic:19414"]
Few questions and random notes regarding spec:

* why does `text` in `icrc7_metadata : (nat) -> (vec record { text; Metadata }) query;` mean? What should it represent?
* took liberty of naming fields in `type Metadata = variant { Nat : nat; Int : int; Text : text; Blob : blob }`, see below:

```
pub struct TokenMetadata {
    pub icrc7_id: TokenID,
    pub icrc7_name: String,
    pub icrc7_image: Vec<u8>,
}
```
[/quote]

hey, i think the way you currently implemented `icrc7_metadata` it's deviating from the standard. 
`(vec record { text; Metadata }` means that there should be a vector of tuples that contain a `text` field that represents the name of the metadata and then a `Metadata` field that contains the actual metadata. `Metadata` again is of type `variant { Nat : nat; Int : int; Text : text; Blob : blob };`, which makes it very flexible. The metadata name fields are supposedly not part of the ICRC7 standard, afaik.

See [this playground](https://m7sm4-2iaaa-aaaab-qabra-cai.icp0.io/?tag=503092097) for an example implementation.

-------------------------

ttt | 2023-06-08 16:45:38 UTC | #16

Thanks for clarification. I'll update it in the next commit @cryptoschindler

-------------------------

cymqqqq | 2023-06-18 09:35:06 UTC | #17

Hi ttt, any new updates on your icrc7? I want to use your icrc7 in my own project.

-------------------------

ttt | 2023-06-21 17:24:24 UTC | #18

hey. I am currently in the process of figuring out how to remove ic-kit without sacrificing testing abilities. However, I think that the code is ready to use, since API will only have minor changes or changes at all.

-------------------------

benji | 2023-06-23 08:53:47 UTC | #20

I disagree with your assessment. I opened multiple issues in your github repo. Most of them are basic errors.

-------------------------

pramitgaha | 2023-06-23 13:51:50 UTC | #21

thank you, I was using the code blindly.
thanks.....

-------------------------

pramitgaha | 2023-07-07 03:20:41 UTC | #22

hello @benji @domwoe 
will there be calls again regarding icrc7?

-------------------------

benji | 2023-07-07 15:30:27 UTC | #23

Hello @ttt, did you have time to address my feedback? If you're unable to respond within 1 week we would re-assign this bounty.

-------------------------

pramitgaha | 2023-07-08 02:34:28 UTC | #24

hello @benji , if that's the case, I also have written my own implementation. Can I take over the bounty?

-------------------------

benji | 2023-07-12 12:34:25 UTC | #25

@pramitgaha If @ttt doesn't respond in the next 2 days then you can take it. BTW the next NFT WG meeting is Tue 18 July, 5pm CEST. You can find a calendar here https://forum.dfinity.org/t/announcing-technical-working-groups/11781/9

-------------------------

pramitgaha | 2023-07-13 03:37:14 UTC | #26

what's the update about changing image property?
dom mentioned that the team is working for the update.
changing it to url: will give flexibility of uploading any type of image. that was my thinking...

-------------------------

benji | 2023-07-13 07:47:13 UTC | #27

Yes it's changed to url preliminarily.
https://github.com/dfinity/ICRC/blob/3daed4c5cae7a782ff0d51913b81f0ca36995301/ICRCs/ICRC-7/ICRC-7.md?plain=1#L37

-------------------------

ttt | 2023-07-13 10:52:01 UTC | #28

Hey @benji. I am sorry for delay. I've had some personal issues. I'll finish addressing changes you requested by Sunday (Jul 16).

-------------------------

pramitgaha | 2023-07-13 14:15:17 UTC | #29

here is my implementation: https://github.com/pramitgaha/icrc7
would like to get some review, improvement suggestion...

-------------------------

pramitgaha | 2023-07-13 14:25:44 UTC | #30

one point I couldn't understood:
```
type TransferArgs = record {
    from : opt Account;     /* if supplied and is not caller then is permit transfer, if not supplied defaults to subaccount 0 of the caller principal */
    to : Account;
    token_ids : vec nat;
    // type: leave open for now
    memo : opt blob;
    created_at_time : opt nat64;
    is_atomic : opt bool;
};
```
if the `caller` and the `from` are same the transaction should fail?
also, the approval transfer is only activated when from is specified and allowed to transfer approved token of user specified in `from` field?

-------------------------

benji | 2023-07-13 22:28:23 UTC | #31

Thanks for raising those points. Some of the discussions we had prior to ICRC-2 was finalized, and we decided just to follow ICRC-2 in the WG. Those points are reflected in my [latest commit](https://github.com/dfinity/ICRC/pull/28/files).

caller: A
spender_subaccount: S1
from: principal: A subaccount: S1
-> it's a normal transfer

caller: A
spender_subaccount: any (defaults to 0)
from: principal: B subaccount: any (defaults to 0)
-> it's a permit transfer, accept only if `(caller, spender_subaccount)` has been approved enough allowance to spend from `from`.

caller: A
spender_subaccount: S1
from: principal: A subaccount: S2
-> it's a permit transfer, accept only if `(caller, S1)` has been approved enough allowance to spend from `(A, S2)`.

-------------------------

kayicp | 2023-07-15 06:39:05 UTC | #32

I have some questions

A) regarding Transfer operation authorization, do i have this right?

1. if `from` and `to` is same, throw `SelfTransfer`
2. go through each token in `token_ids`
3. if `from` is the token `owner` and `caller` is the `spender`, then the new `owner` becomes `to` and remove the `spender`.
4. if the `caller` or `from` fails the ownership test, then put the token id in `unauthorized` array.
5. check if `is_atomic` is `true (default)`, rollback all of the ownership changes and throw the `unauthorized` array.
6. if `is_atomic` is `false`, if ownership changes even once while the rest failed, then the transfer will be considered as success.

B) For transaction deduplication, so whenever we're throwing the `TransferError` we have to rollback any changes, yes?

C) The same applies to `approve` operation? if Fail then Rollback?

D) One of the Approve arguments is the `token_ids: ?[Nat]`. Am I correct to assume that if this is `null`, this means that the `caller` want to approve the `spender` for ALL of his tokens?

-------------------------

pramitgaha | 2023-07-15 09:24:41 UTC | #33

A:
1: yes. that's what I'm also doing
2: yes, you need to go through each id, there might be some token_ids that isn't available in the collection yet. you need to handle the error.
3: I think you need to remove all the spender assigned by previous owner. this will leave backdoor for the previous owner to gain the ownership again.
4: yes...
5: another yes.
6: this is kinda open, I guess I'm collecting unauthorized and returning it as an error. but the changes made when the ownership/approval check succeed remains unchanged.

B: you're just checking for the transaction that matches up. there is no need for state changes to no rollback needed.

C: if you do the ownership check earlier, I think there is no place for error according to the reference document.

D: yes.

-------------------------

kayicp | 2023-07-16 10:29:16 UTC | #34

1) for the Transfer deduplication process, how should we check `created_at_time` potential duplicate? by using `==` for exactly similar time? or should we compare if the `A.created_at_time` window and future, overlaps with `B.created_at_time` window and future?

2) When can I expect the standard spec to be completed along with other update operations such as `mint` and `burn`? Do we want to also include `token_ids` array argument to apply many mints per update call and many burns per update call too? along with deduplication?

3) Why is the Transfer's token_id arg is definite, but the Approve's token_id is optional? Can't we make Approve's token_id also definite so if the token_id array being empty, it can be regarded as it being null. Also, the ApprovalError is missing the `CreatedInFuture { ledger_time: Nat64 }` variant, but is present in ICRC-2.

4) When should I throw the `TemporarilyUnavailable` error?

5) Based on ICRC-2, I propose that we also include `Expired` error if the user set very low expiry time such as
![image|690x134](upload://2FWRWNNQS6QdoM5TNFbq4RKbdB2.png)
I add `PERMITTED_DRIFT` since i think it's a good idea to also give a minimum time for approval. If the user set it to exactly NOW, then the approval will be pointless because by the time the `transfer` gets called, it's already expired.

i apologize for asking too much.

-------------------------

pramitgaha | 2023-07-16 05:35:28 UTC | #35

1:
hmm, i didn't understood your question quite well.
so I'll try to explain you the deduplication process.
current_time - TX_window + permitted_drift  <---> current_time + pemitted_drift.
the time specified in created_at_time must be between these two time or else return error.

3: that's open for proposal.

-------------------------

pramitgaha | 2023-07-16 22:51:29 UTC | #37

following up the changes: https://github.com/pramitgaha/icrc7/commit/0f9cb16cd03e40a0e074c2a07a989bba22e826ea

@benji what's the update for the bounty. It will be remain assigned to ttt?

-------------------------

ttt | 2023-07-17 20:36:06 UTC | #38

Hey @benji, I've pushed an update to my [repo](https://github.com/holykol/icrc7). The code is still a little rough, I will need some time to clean it up and write some tests to make sure I'm still within the spec. I will update you in a couple of days. Again, sorry for the delay.

-------------------------

ttt | 2023-07-26 16:39:30 UTC | #39

Hello. Unfortunately, I won't be able to finish this assignment. Good luck to the next assignee

@benji @domwoe

-------------------------

domwoe | 2023-07-27 18:08:41 UTC | #40

Thanks for the heads up @ttt.

We assign @pramitgaha to this bounty.

-------------------------

cymqqqq | 2023-08-04 06:27:59 UTC | #41

Hi @domwoe, I have a question, does the Dfinity Foundation has determined to accept the icrc7 repo written by @pramitgaha  as the formal icrc7 standard on IC network?

-------------------------

pramitgaha | 2023-08-04 13:08:31 UTC | #42

hello, dom is on 2 weeks vacation!

-------------------------

karim | 2023-08-13 16:50:48 UTC | #43

Hi there! First of all, thank you all for your effort! I'd like to know if there will be a reference implementation for Motoko as well? Or will I have to port the finished assignment by myself if I'd like to use the standard in Motoko?

-------------------------

pramitgaha | 2023-08-14 08:34:59 UTC | #44

hello @benji 
any update regarding the code review?
is there any further changes to be made?

-------------------------

Agent2222 | 2023-08-15 03:52:55 UTC | #45

Hi, would like to join this bounty.

**Experience:**

* Currently utilizing IC DID for live NFT gated metaverse platform
* Successfully completed Dev Grant milestones with frontend and backend app fully deployed to the IC

**Timeline:**

1. Updating base canister with read methods outlined in spec - 2-3d
2. Updating base canister with write methods outlined in spec - 2-3d
3. Connecting calls to frontend interface - 2d
4. Making sure implementation is conformant to spec and testing implementation 2-3d

-------------------------

domwoe | 2023-08-16 12:31:07 UTC | #46

Hi @Agent2222,

thanks a lot for your interest. However, the bounty is already assigned.

Have a look at dfinity.org/grants and https://forum.dfinity.org/c/developers/bounties/37 for more opportunities.

-------------------------

Agent2222 | 2023-08-16 13:43:27 UTC | #47

Ah, thanks. Still getting the hang of navigating the forums. :sweat_smile:

-------------------------

benji | 2023-08-17 14:34:48 UTC | #48

Hi @pramitgaha, I submitted my review to your github. Another colleague is currently on vacation but will review once he's back.

-------------------------

pramitgaha | 2023-08-21 15:08:15 UTC | #49

hello @benji , can you upgrade the `candid` version in `ic-ledger-types` package to `0.9.3`?

-------------------------

benji | 2023-08-22 12:51:42 UTC | #50

https://docs.rs/ic-ledger-types/latest/ic_ledger_types/ is using `candid = ^0.9` so it should already be possible to use it in a project using candid `0.9.3` . What error do you get? @pramitgaha

-------------------------

pramitgaha | 2023-08-23 07:13:21 UTC | #51

ohh, I was importing the library by specifying the git path 
`icrc-ledger-types = { git ="https://github.com/dfinity/ic" }`
In that git repo, `candid`'s version was '0.8.4'
I didn't knew library was published!

-------------------------

pramitgaha | 2023-08-23 10:29:19 UTC | #52

hello @benji I can't see structs like `Account` in the library!

-------------------------

benji | 2023-08-25 14:47:18 UTC | #53

I'm not sure what your question is, but `Account` is here https://docs.rs/icrc-ledger-types/latest/icrc_ledger_types/icrc1/account/struct.Account.html

-------------------------

Alina-CAYA-Auditor | 2023-08-28 18:26:50 UTC | #54

Hey all! It's so incredible :boom:

By the way, what is the future fate of these standards? Will their quality be separately tested?

Besides, is it possible to create a separate library, for example, on Motoko, which will contain all the developed standards with the ability to import them and customize your canisters?

-------------------------

pramitgaha | 2023-09-24 04:20:15 UTC | #55

@benji , rewrote the work: [icrc7](https://github.com/rustacean1/icrc7)
regarding clear of expired approvals: I didn't do that. I saw in the `revoke_approval` method's error there is one variant `ApprovalExpired`. To keep a track for that: I didn't cleared the expired approvals.
Also regarding `revoke_approval` I've messaged you!
can you have a look?
thank you!

-------------------------

benji | 2023-09-26 10:42:26 UTC | #56

We intend to remove the `ApprovalExpired` error exactly for this reason.

-------------------------

pramitgaha | 2023-09-26 17:02:52 UTC | #57

@benji @domwoe 
what was the outcome of the today's meeting?
any changes?

-------------------------

skilesare | 2023-09-26 20:15:45 UTC | #58

The docs listed here have some updates.

https://forum.dfinity.org/t/call-for-participation-nft-token-standard-working-group-status-updated/16566/30?u=skilesare

-------------------------

PanIndustrial | 2023-11-13 18:31:31 UTC | #59

:wave:

We are a group building code for the IC and supporting the integration of existing IC tech into enterprise workflows.

We have a base ICRC7 Motoko Class/Base Implementation that we'd like to submit for this bounty.  We have a test suite, and it can be implemented by the following actor:

```
import Array "mo:base/Array";
import Vec "mo:vector";
import Principal "mo:base/Principal";
import Time "mo:base/Time";
import Nat "mo:base/Nat";
import D "mo:base/Debug";

import ICRC7 "../src";


import SB "mo:stablebuffer_1_2_0/StableBuffer";


shared(_init_msg) actor class Example(_args : {
  icrc7_args: ICRC7.InitArgs;
}) = this {

  type LogEntry =                         ICRC7.LogEntry;
  type Account =                          ICRC7.Account;
  type Environment =                      ICRC7.Environment;
  type Value =                            ICRC7.Value;
  type NFT =                              ICRC7.NFT;
  type NFTShared =                        ICRC7.NFTShared;
  type NFTMap =                           ICRC7.NFTMap;
  type OwnerOfResponse =                  ICRC7.OwnerOfResponse;
  type OwnerOfResponses =                 ICRC7.OwnerOfResponses;
  type ApprovalInfo =                     ICRC7.ApprovalInfo;
  type ApprovalResponse =                 ICRC7.ApprovalResponse;
  type ApprovalResponses =                ICRC7.ApprovalResponses;
  type ApprovalCollectionResponse =       ICRC7.ApprovalCollectionResponse;
  type TransferArgs =                     ICRC7.TransferArgs;
  type TransferResponse =                 ICRC7.TransferResponse;
  type TransferError =                    ICRC7.TransferArgs;
  type RevokeTokensArgs =                 ICRC7.RevokeTokensArgs;
  type RevokeTokensResponseItem =         ICRC7.RevokeTokensResponseItem;
  type RevokeCollectionArgs =             ICRC7.RevokeCollectionArgs;
  type RevokeCollectionResponseItem =     ICRC7.RevokeCollectionResponseItem;
  type TokenApproval =                    ICRC7.TokenApproval;
  type CollectionApproval =               ICRC7.CollectionApproval;

  stable var init_msg = _init_msg; //preserves original initialization;

  stable var icrc7_migration_state = ICRC7.init(ICRC7.initialState() , #v0_1_0(#id), switch(_args.icrc7_args){
    case(null){
      ?{
        symbol = ?"TST";
        name = ?"Test NFT";
        description = ?"A Test Collection";
        logo = ?"https://www.icpscan.co/img/motoko.jpeg";
        supply_cap = null;
        total_supply = 0;
        max_approvals_per_token_or_collection = ?10;
        max_query_batch_size = ?100;
        max_update_batch_size = ?100;
        default_take_value = ?1000;
        max_take_value = ?10000;
        max_revoke_approvals = ?100;
        max_memo_size = ?512;
        deployer = init_msg.caller;
      } : ICRC7.InitArgs;
    };
    case(?val) ?val;
    }, init_msg.caller);

  let #v0_1_0(#data(icrc7_state_current)) = icrc7_migration_state;

  private var _icrc7 : ?ICRC7.ICRC7 = null;

  private func get_icrc7_state() : ICRC7.CurrentState {
    return icrc7_state_current;
  };

  private func get_icrc7_environment() : ICRC7.Environment{
    {
      canister = get_canister;
      get_time = get_time;
      refresh_state = get_icrc7_state;
      log = ?addLog;
      ledger = ?{
        add_ledger_transaction = add_trx;
      };
    };
  };

  func icrc7() : ICRC7.ICRC7 {
    switch(_icrc7){
      case(null){
        let initclass : ICRC7.ICRC7 = ICRC7.ICRC7(?icrc7_migration_state, Principal.fromActor(this), get_icrc7_environment());
        _icrc7 := ?initclass;
        initclass;
      };
      case(?val) val;
    };
  };

  stable var log = SB.init<LogEntry>();

  private func addLog(entry : LogEntry){
    //note: Implement your own logging solution like canister geek. This will not scale without an implemented logging strategy
    SB.add(log, entry);
  };

  //we will use a stable log for this example, but encourage the use of ICRC3 in a full implementation.  see https://github.com/panindustrial/FullNFT.mo

  stable var trx_log = Vec.new<ICRC7.Value>();

  func add_trx(entry : Value) : Nat {
    Vec.add(trx_log, entry);
    return (Vec.size(trx_log) - 1);
  };

  private var canister_principal : ?Principal = null;

  private func get_canister() : Principal {
    switch (canister_principal) {
        case (null) {
            canister_principal := ?Principal.fromActor(this);
            Principal.fromActor(this);
        };
        case (?val) {
            val;
        };
    };
  };

  private func get_time() : Int{
      //note: you may want to implement a testing framework where you can set this time manually
      /* switch(state_current.testing.time_mode){
          case(#test){
              state_current.testing.test_time;
          };
          case(#standard){
               Time.now();
          };
      }; */
    Time.now();
  };



  public query func icrc_symbol() : async Text {

    return switch(icrc7().get_ledger_info().symbol){
      case(?val) val;
      case(null) "";
    };
  };

  public query func icrc_name() : async Text {
    return switch(icrc7().get_ledger_info().name){
      case(?val) val;
      case(null) "";
    };
  };

  public query func icrc7_description() : async ?Text {
    return icrc7().get_ledger_info().description;
  };

  public query func icrc7_logo() : async ?Text {
    return icrc7().get_ledger_info().logo;
  };

  public query func icrc7_max_memo_size() : async ?Nat {
    return icrc7().get_ledger_info().max_memo_size;
  };

  public query func icrc7_total_supply() : async Nat {
    return icrc7().get_ledger_info().total_supply;
  };

  public query func icrc7_supply_cap() : async ?Nat {
    return icrc7().get_ledger_info().supply_cap;
  };

  public query func icrc7_max_approvals_per_token_or_collection() : async ?Nat {
    return icrc7().get_ledger_info().max_approvals_per_token_or_collection;
  };

  public query func icrc7_max_query_batch_size() : async ?Nat {
    return icrc7().get_ledger_info().max_query_batch_size;
  };

  public query func icrc7_max_update_batch_size() : async ?Nat {
    return icrc7().get_ledger_info().max_update_batch_size;
  };

  public query func icrc7_default_take_value() : async ?Nat {
    return icrc7().get_ledger_info().default_take_value;
  };

  public query func icrc7_max_take_value() : async ?Nat {
    return icrc7().get_ledger_info().max_take_value;
  };

  public query func icrc7_max_revoke_approvals() : async ?Nat {
    return icrc7().get_ledger_info().max_revoke_approvals;
  };

  public query func icrc7_collection_metadata() : async {metadata: [(Text, Value)]} {

    let ledger_info = icrc7().get_ledger_info();
    let results = Vec.new<(Text, Value)>();

    switch(ledger_info.symbol){
      case(?val) Vec.add(results, ("icrc7:symbol", #Text(val)));
      case(null) {};
    };
    
    switch(ledger_info.name){
      case(?val) Vec.add(results, ("icrc7:name", #Text(val)));
      case(null) {};
    };

    switch(ledger_info.description){
      case(?val) Vec.add(results, ("icrc7:description", #Text(val)));
      case(null) {};
    };

    switch(ledger_info.logo){
      case(?val) Vec.add(results, ("icrc7:logo", #Text(val)));
      case(null) {};
    };

    Vec.add(results, ("icrc7:total_supply", #Nat(ledger_info.total_supply)));

    switch(ledger_info.supply_cap){
      case(?val) Vec.add(results, ("icrc7:supply_cap", #Nat(val)));
      case(null) {};
    };
 
    switch(ledger_info.max_approvals_per_token_or_collection){
      case(?val) Vec.add(results,("icrc7:max_approvals_per_token_or_collection", #Nat(val)));
      case(null) {};
    };

    switch(ledger_info.max_query_batch_size){
      case(?val) Vec.add(results,("icrc7:max_query_batch_size", #Nat(val)));
      case(null) {};
    };

    switch(ledger_info.max_update_batch_size){
      case(?val) Vec.add(results, ("icrc7:max_update_batch_size", #Nat(val)));
      case(null) {};
    };

    switch(ledger_info.default_take_value){
      case(?val) Vec.add(results,("icrc7:default_take_value", #Nat(val)));
      case(null) {};
    };

    switch(ledger_info.max_take_value){
      case(?val) Vec.add(results,("icrc7:max_take_value", #Nat(val)));
      case(null) {};
    };

    switch(ledger_info.max_revoke_approvals){
      case(?val) Vec.add(results, ("icrc7:max_revoke_approvals", #Nat(val)));
      case(null) {};
    };

    return {
      metadata = Vec.toArray(results);
    };
  };

  //todo: confirm the nullability of the NFT
  public query func icrc7_token_metadata(token_ids: [Nat]) : async [(Nat, ?NFTMap)]{
 
     switch(icrc7().get_token_infos_shared(token_ids)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };
  };

 

  public query func icrc7_owner_of(token_ids: [Nat]) : async OwnerOfResponses {
   
     switch( icrc7().get_token_owners(token_ids)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };
  };

  public query func icrc7_balance_of(account: Account) : async Nat {
    return icrc7().get_token_owners_tokens_count(account);
  };

  public query func icrc7_tokens(prev: ?Nat, take: ?Nat) : async [Nat] {
    return icrc7().get_tokens_paginated(prev, take);
  };

  public query func icrc7_tokens_of(account: Account, prev: ?Nat, take: ?Nat) : async [Nat] {
    return icrc7().get_tokens_of_paginated(account, prev, take);
  };

  public query func icrc7_is_approved(spender: Account, from_subaccount: ?Blob, token_id: Nat) : async Bool {
    return icrc7().is_approved(spender, from_subaccount, token_id);
  };

  public query func icrc7_get_approvals(token_ids: [Nat], prev: ?TokenApproval, take: ?Nat32) : async [TokenApproval] {
    
    switch(icrc7().get_token_approvals(token_ids, prev, take)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };
  };

  public query func icrc7_get_collection_approvals(owner : Account, prev: ?CollectionApproval, take: ?Nat32) : async [CollectionApproval] {
    
    switch(icrc7().get_collection_approvals(owner, prev, take)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };
  };

  public query func icrc7_supported_standards() : async [{ name : Text; url : Text }] {
    //todo: figure this out
    return [{name = "ICRC-7"; url = "https://github.com/dfinity/ICRC/ICRCs/ICRC-7"}];
  };


  //Update calls

  public shared(msg) func icrc7_approve(token_ids: [Nat], approval: ApprovalInfo) : async ApprovalResponses {

    switch(icrc7().approve_transfers(get_icrc7_environment(), msg.caller, token_ids, approval)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };
  };

  public shared(msg) func icrc7_approve_collection(approval: ApprovalInfo) : async ApprovalCollectionResponse {

      let result : ApprovalResponse = switch(icrc7().approve_collection(get_icrc7_environment(), msg.caller, approval)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };

      switch(result){
        case(#Err(val)){
          return (#Err(icrc7().TokenErrorToCollectionError(val)));
        };
        case(#Ok(val)){
          return #Ok(val);
        };
      };
  };

  public shared(msg) func icrc7_transfer(args: TransferArgs) : async [(Nat, TransferResponse)] {
      

      switch(icrc7().transfer(get_icrc7_environment(), msg.caller, args)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };
  };

  public shared(msg) func icrc7_revoke_token_approvals(args: RevokeTokensArgs) : async [RevokeTokensResponseItem] {
      switch(icrc7().revoke_token_approvals(get_icrc7_environment(), msg.caller, args)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };
  };

  public shared(msg) func icrc7_revoke_collection_approvals(args: RevokeCollectionArgs) : async [RevokeCollectionResponseItem] {
     
      switch(icrc7().revoke_collection_approvals(get_icrc7_environment(), msg.caller, args)){
        case(#ok(val)) val;
        case(#err(err)) D.trap(err);
      };
  };

};
```

-------------------------

Perlets9 | 2023-11-22 15:05:11 UTC | #60

Hello,
we would like to participate in this Bounty.

In Noku/Original we developed in June a Motoko version of the ICRC-7 standard.

You can see the code at our github page: noku-team/icrc7_motoko

We already opened a pull request to the awesome-motoko repository ( motoko-unofficial/awesome-motoko/pull/31 )

There are already a few collections that use this code, but the first one is Casino Lugano's NFT Collection

-------------------------

Gwojda | 2023-12-04 12:51:21 UTC | #61

Hi,
@ [pramitgaha](https://forum.dfinity.org/u/pramitgaha) is your current implementation still WIP or it is production ready ? ( https://github.com/rustacean1/icrc7 )
If not finished, do you need help on it? 
Gautier

-------------------------

Dustin | 2023-12-15 09:16:53 UTC | #62

Same question, does someone have an update on the state of this implementation?

-------------------------

pramitgaha | 2024-01-17 01:43:16 UTC | #63

hello @benji @Gwojda 
here is the implementation of [icrc7](https://github.com/pramitgaha21/icrc7.git)
Been working on the icrc30's transaction. Will update within few days.

-------------------------

Carsten | 2024-01-17 20:56:52 UTC | #64

[quote="pramitgaha, post:63, topic:19414, full:false"]
here is the implementation of [icrc7](https://github.com/pramitgaha21/icrc7.git)
[/quote]

Very nice, I've been playing with it a bit today, and it's very useful.

-------------------------

pramitgaha | 2024-01-19 19:53:51 UTC | #65

Hello, I'm facing an issue while implementing the transaction log for `icrc30_revoke_token_approvals`, in the documentation it's mentioned:
```
icrc30_revoke_token_approvals Block Schema

the tx.op field MUST be "30revoke"
it MUST contain a field tx.tid: Nat
it MUST contain a field tx.from: Account
it MUST contain a field tx.spender: Account
```

here is how the args looked like:
```rs
pub struct RevokeTokensArgs {
    pub token_ids: Vec<u128>,
    pub from_subaccount: Option<Subaccount>,
    pub spender: Option<Account>,
    pub memo: Option<Vec<u8>>,
    pub created_at_time: Option<u64>,
}
```
It's mentioned in the schema that the block should store `Spender` as `Account`,
when the `Spender` is `None`, how should I handle it?
should I iterate over every approved spender and store it as a single txn per `Spender`?

Can we change in the `Spender` in the schema to `Option<Account>` or `Vec<Account>`?

-------------------------

pramitgaha | 2024-01-19 16:28:43 UTC | #66

@cryptoschindler @benji @domwoe

-------------------------

dieter.sommer | 2024-01-23 12:51:58 UTC | #67

Quoting from the standard:

> A `null` value for `spender` means to revoke approvals with any value for the spender.

To your question:

> should I iterate over every approved spender and store it as a single txn per `Spender` ?

The current thinking is that for each spender you have approved a token, an ICRC-3 block is generated in the log. When you revoke with a `null` for a spender, you revoke all the approvals for this spender and token, so, yes, you iterate over all approved spenders.

> Can we change in the `Spender` in the schema to `Option<Account>` or `Vec<Account>` ?

You are referring to the method signature or the ICRC-3 block schema? If you mean the further, is the reason for this that you don't want to "find" the pending approvals in order to delete them, but already receive them as input? Like an optimization? Is it difficult / time consuming to retrieve the spenders with an approval?

Either way, we can discuss this in the next Working Group meeting.

-------------------------

pramitgaha | 2024-01-23 13:06:40 UTC | #68

@dieter.sommer 
I was talking about when recording the transaction.
```
icrc30_revoke_token_approvals Block Schema

the tx.op field MUST be "30revoke"
it MUST contain a field tx.tid: Nat
it MUST contain a field tx.from: Account
it MUST contain a field tx.spender: Account
```
for example: A token has 10 approvals, now while recording the txn, schema says it mush contain a field of `spender: Account`
now should I iterate over all 10 approvals and then record it as a single transaction per approved account?
this will just fill the txn logs, is this what the standard wants?
and what my suggestion was:
how about changing `tx.spender to Option<Account>`
`Some(Account)` means a single account was revoked from approval and `Null/None` means all approvals were revoked!

-------------------------

dieter.sommer | 2024-01-23 15:21:58 UTC | #69

OK, thanks for clarifying. Your suggestion does make sense, we will discuss in the WG meeting next Tuesday. Do you have any other suggestions you have found while implementing it?

Also note that we likely will update the batch API to be more powerful, see discussions in the [other topic](https://forum.dfinity.org/t/call-for-participation-nft-token-standard-working-group-status-updated/16566/167).

Also, can you join the WG meeting next Tue, 17:00 UTC+1 time?

-------------------------

pramitgaha | 2024-01-23 16:20:07 UTC | #70

yep, I had one more thing but it's regarding the `ICRC7`
here in the `icrc7_transfer` function, it's argument looks like this:
```
type TransferArgs = record {
    spender_subaccount: opt blob; // the subaccount of the caller (used to identify the spender)
    from : Account;
    to : Account;
    token_ids : vec nat;
    // type: leave open for now
    memo : opt blob;
    created_at_time : opt nat64;
    is_atomic : opt bool;
};
```
here, can we chance the `from` field to `Option<Account>`?
when it's `null`, smart contract will transfer tokens from the caller(who will also be a spender) in this case.
When it's `Some(Account)` then, we will check if the spender is approved to make the transfer or not.
So this thing clarifies that the list of token ids can be passed when they belong to a single owner, either from the caller or from the `Some(account)`.
otherwise the Transaction log will have false data.
imagine one transaction, where token_ids provided are: `vec {1; 2; 3; 4; 5}`, all tokens are owned by different `Account`, but caller was approved for every tokens and in case of from field, owner of token 3's account was provided, while the logging the transaction it will record the same from account.
although spender was able to make the transaction, but technically account specified in the from doesn't own all the tokens.

-------------------------

pramitgaha | 2024-01-23 16:20:23 UTC | #71

[quote="dieter.sommer, post:69, topic:19414"]
Also, can you join the WG meeting next Tue, 17:00 UTC+1 time?
[/quote]

sure, I'll join the call

-------------------------

dieter.sommer | 2024-01-31 16:17:14 UTC | #72

@pramitgaha 

We discussed this in our call yesterday with the outcome that we decided that it is a good idea to allow to omit the `spender` in a transaction log when revoking token-level approvals. This has the semantics that all matching approvals with all spenders are revoked. Only one block is written in this case.

This should be what you were asking for.

Please also note that there has been quite a big simplification in the API: All APIs are now true batch APIs and the response is flat instead of having a batch-level error possibility and then individual errors. This should be much easier overall in terms of implementation, e.g., to track txs for deduplication. This is the current proposal, see the most recent ICRC-7 and ICRC-37 proposals, links are [here](https://forum.dfinity.org/t/call-for-participation-nft-token-standard-working-group-status-updated/16566/159).

Hope this helps! Please come back to one of us in case you have further questions.

-------------------------

dieter.sommer | 2024-01-31 16:18:57 UTC | #73

[quote="pramitgaha, post:70, topic:19414"]
yep, I had one more thing but it’s regarding the `ICRC7`
here in the `icrc7_transfer` function, it’s argument looks like this:

```
type TransferArgs = record {
    spender_subaccount: opt blob; // the subaccount of the caller (used to identify the spender)
    from : Account;
    to : Account;
    token_ids : vec nat;
    // type: leave open for now
    memo : opt blob;
    created_at_time : opt nat64;
    is_atomic : opt bool;
};
```
[/quote]

It seems that you are referring to a rather old draft. The method for transferring has been split into an `icrc7_transfer` and `icrc37_tranfer_from` method. Does this already answer your question?

-------------------------

pramitgaha | 2024-02-06 17:29:39 UTC | #74

yep,
updated the repo again following the correct documentation.
Can you have a look over it?

-------------------------

Roman55 | 2024-06-25 17:39:59 UTC | #76

Hi all,  here is the implementation using derive macroses https://github.com/UncensoredGreats/NFT , I would like to get some review and improvement suggestions

-------------------------


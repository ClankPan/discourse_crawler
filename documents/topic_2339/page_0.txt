kpeacock | 2021-03-31 23:44:36 UTC | #1

Hi all, wanted to give you a heads-up that we have released a potentially breaking change to `@dfinity/agent`. We have removed the `BigNumber` package as a dependency in favor of the `BigInt` primitive, which will make our total package size a bit smaller and more performant.

Additionally, `@dfinity/agent` and `@dfinity/authentication` have improved Readme's with links to some autogenerated documentation. You can install the latest versions from `npm`!

https://www.npmjs.com/package/@dfinity/agent
https://www.npmjs.com/package/@dfinity/authentication

-------------------------

kpeacock | 2021-04-01 00:14:32 UTC | #2

To forecast some additional upcoming changes, we've prioritized the following work:

* Separate Candid / IDL logic into its own interface
* Refactor authentication into three packages 
  *  @dfinity/authentication retains a library of methods, the minimum API to support IC authentication
  * @dfinity/identity, for  crypto-generic identities (Ed25519, Delegation, etc) 
  * @dfinity/auth-client contains code to interface with a hosted auth0 identity provider 
* Open sourcing!

-------------------------

senior.joinu | 2021-04-06 19:48:41 UTC | #3

Unable to use this version of `agent` with `dfx 0.7.0` in typescript - generated typings are incompatible because of `BigNumber`.

UPD: it's not critical, but annoying to `as unknown as BigNumber`.

-------------------------

senior.joinu | 2021-04-06 19:57:12 UTC | #4

And also, there is a bug in `agent` encoding.

The code like:
```js
await sendNat(BigInt(0));
```
fails with
```
Invalid nat argument: 0n
```

---------
It works with plain zero `0` though.

-------------------------

kpeacock | 2021-04-06 23:02:46 UTC | #5

Thanks, I'll put some pressure on the Candid team to make the types update, and I'll look into the invalid Nat issue. Do you have a bit more context to help me reproduce and write a new test?

-------------------------

senior.joinu | 2021-04-06 23:53:31 UTC | #6

Hey there! Thanks for a quick response.

To reproduce:
```
// increment.mo
actor {
    public func inc(arg: Nat): async Nat {
        return arg + 1;
    };
}

// test.ts
await IncrementActor.inc(0 as unknown as BigNumber); // pass
await IncrementActor.inc(BigInt(1) as unknown as BigNumber); // pass
await IncrementActor.inc(BigInt(0) as unknown as BigNumber); // fail - Invalid nat argument: 0n
```

P.S. I'm preparing more bug reports, stay tuned.

UPD: When it's wrapped like this
```
// increment.mo
public type WrappedNat = { value: Nat };

public query func incWrapped(arg: WrappedNat): async WrappedNat {
    return { value = arg.value + 1 };
};

// test.ts
await IncrementActor.incWrapped({value: BigInt(0) as unknown as BigNumber}); // fail
```
error message changes to
```
Do not know how to serialize a BigInt
        at JSON.stringify (<anonymous>)
```

-------------------------

senior.joinu | 2021-04-07 00:32:46 UTC | #8

I figured out these are more proposals than bug reports.


I. Optional types unwrap incorrectly

This code:
```
// increment.mo

public query func maybeInc(arg: ?Nat): async ?Nat {
    switch (arg) {
        case null { null };
        case (?arg) { ?(arg + 1) };
    }
}
```

would produce this type (which correctly represent what it actually returns)
```typescript
'maybeInc' : (arg_0: [] | [BigNumber]) => Promise<[] | [BigNumber]>
```

This is misleading representation. It should returns something like
```typescript
'maybeInc' : (arg_0: null | BigNumber) => Promise<null | BigNumber>
```
or 
```typescript
'maybeInc' : (arg_0?: BigNumber) => Promise<undefined | BigNumber>
```

The second representation is better, because it allows us to omit optional fields, which is natural in js/ts, but a little bit harder to implement, I believe.


_for some reason I can't fit it in one message..._

-------------------------

senior.joinu | 2021-04-07 00:33:46 UTC | #9

II. Variant representation is very unsatisfying

```
// increment.mo

public query func incOrThrow(arg: Int): async Result.Result<Int, Text> {
    if (arg < 0) return #err("Negative!")
    else return #ok(arg + 1);
};
```
would produce this type
```
export type Result = {
    'ok' : BigNumber
  } |
  { 'err' : string };
```

which is very unhandy
```typescript
// test.ts

const result = await IncrementActor.incOrThrow(2n as unknown as BigNumber);
if (result.hasOwnProperty('ok')) {
  console.log((result as {'ok': BigNumber}).ok);
}
else {
  console.error((result as {'err': string}).err);
}
```

It would be better if:
1. For each variant kind there will be a separate generated type like
```
// increment.d.ts
type ResultOk = <type if ok>;
type ResultErr = <type if err>;
type Result = ResultOk | ResultErr;
```

-------------------------

senior.joinu | 2021-04-07 00:36:08 UTC | #10

*this also does not fit…*

2. Express variants in js in a reflection-free way like
```
// increment.d.ts
type Result = {
  kind: 'ok' | 'err';
  value: ResultOk | ResultErr;
};
```

Thanks in advance. Let me know if such proposals are inappropriate at that moment.

-------------------------

kpeacock | 2021-04-07 01:19:11 UTC | #11

Definitely not inappropriate! 

We know that the interface with Candid can use some quality of life improvements. So far, our principle has been to ship the agent / types with as close of a match to the Candid concepts of types as possible, with JS developers writing a small layer around the actor methods to make things pleasant in the rest of the application.

I'd like to make some nicer inferences, but it definitely comes at a risk of introducing some deeply confusing bugs

-------------------------

senior.joinu | 2021-04-07 10:55:12 UTC | #12

>  with JS developers writing a small layer around the actor methods to make things pleasant

It doesn't make sense to me, sorry. 
How can I do that, for example, for our `increment.mo` canister? Let's suppose I want `maybeInc()` to have the suggested interface (`undefined` instead of empty array). What exactly should I do?

-------------------------

Ori | 2021-04-07 11:48:43 UTC | #13

You could create some small utility functions that handle conversions for you (which also allows you to maintain any future changes to the returned types in a central place), something similar to this: [https://github.com/enzoh/superheroes/blob/master/src/www/utilities/idl.js](https://github.com/enzoh/superheroes/blob/master/src/www/utilities/idl.js)

-------------------------

Gabriel | 2021-04-07 12:22:08 UTC | #14

Yeah there seems to be more issues with the latest agent.

Even the hello demo example with this code:

    actor {
    public func greet(name : Text) : async Text {
        return "Hello, " # name # "!";
    };
};

gives me this error in console: `Uncaught ReferenceError: Buffer is not defined
    at w.toText `

-------------------------

senior.joinu | 2021-04-07 12:34:39 UTC | #15

Thanks. This is not a problem. 
The problem is that, if you want to make an interface that doesn't force anyone to stick with some particular style or pattern, you should make it easy to use by default and flexible enough to fit in any other paradigm. Not ugly and "as close to metal as we can". 

Right now they just force anyone to write exactly the same utilities you've mentioned.

-------------------------

Ori | 2021-04-07 14:36:39 UTC | #16

I do agree actually, it is a bit close to the metal, as Kyle said there’s room for improvement with all this.

-------------------------

kritzcreek | 2021-04-07 15:25:19 UTC | #17

[quote="senior.joinu, post:15, topic:2339"]
The problem is that, if you want to make an interface that doesn’t force anyone to stick with some particular style or pattern, you should make it easy to use by default and flexible enough to fit in any other paradigm. Not ugly and “as close to metal as we can”.
[/quote]

If you encode `opt A` as `null | A` in TypeScript you're losing information, because you can't tell `opt null` from `null` for a value of type `opt (opt A)`. I'd say losing data doesn't meet the "flexible enough" bar. Encoding it with arrays lets you tell them apart as `[null]` vs `[]`.

For the variant encoding I'd agree that a `tag` field might make for a nicer API.

-------------------------

senior.joinu | 2021-04-07 16:02:40 UTC | #18

You're right! But do you really want to distinct them?
Maybe it's not right to guess here, but I can't imagine a use-case when the distinction between `opt(null)` (which is null) and `null` could be useful. It doesn't even lose it's type safety.

But most of the time you want a nice `?.field` access syntax, and this could be very helpful.

```
//canister.mo
type Rec = {a : Nat; b : ?Nat;};
public query func getSmth() : ?Rec {...}

// test.ts - good semantics
const smth = await actor.getSmth();
if (smth?.b && smth?.b > 10n) {
  doStuff();
}

// test.ts - bad semantics
const smth = await actor.getSmth();
if (smth.length > 0 && smth[0].b.length > 0 && smth[0].b[0] > 10n) {
  doStuff();
}
```

-------------------------

kpeacock | 2021-04-07 16:45:36 UTC | #19

I think that the right path forward might be to provide some utility classes for things like Opts that can maintain full information, but can be cast to friendlier JS primitives.

In the meantime, I've merged a fix for the Nat bug 0n, and we should have a build of Candid without BigNumber, hopefully in time for the next `dfx` release

-------------------------

senior.joinu | 2021-04-07 17:44:24 UTC | #20

Thanks a lot. Great timing.

-------------------------

dani | 2021-06-16 10:48:12 UTC | #21

I'm running into the same issue. Did you manage to work around this somehow? -edit- I see there's a PR that might be the fix: https://github.com/dfinity/agent-js/pull/457

-------------------------

Gabriel | 2021-06-16 10:50:40 UTC | #22

Since 0.7.1 and agent at 0.9.1 I haven't had any issues.

-------------------------

dani | 2021-06-16 11:10:23 UTC | #23

hmm ok, I am on dfx 0.7.1 and agent 0.9.1, but it's throwing at:

```
Uncaught ReferenceError: Buffer is not defined
    at Principal.toText (index.ts:80)
    at Function.fromText (index.ts:49)
    at new CanisterActor (actor.ts:244)
    at Function.createActor (actor.ts:269)
```

I'll try to polyfill buffer, see if it solves the issue.

Thanks for the quick response

-edit- fixed by polyfilling Buffer with: https://github.com/feross/buffer

-------------------------

kpeacock | 2021-06-16 18:43:29 UTC | #24

Yes, while I'm working on removing Buffer (and hopefully a few other Node.js features), it's still a long-term work in progress and a pretty significant refactor. I'll definitely make an announcement once it's done

-------------------------

RMCS | 2021-07-01 07:34:06 UTC | #25

Could you share the polyfill code?

-------------------------

kpeacock | 2021-07-01 20:51:23 UTC | #26

```
npm install buffer
```
```
import Buffer from "buffer/";
```

-------------------------

jzxchiang | 2021-07-02 00:27:48 UTC | #27

If there's a way to replace the BLS signature validation wasm code with performant JS instead, that'd be good too. Unfortunately, native mobile doesn't seem to be able to run wasm (at least from what I can tell).

-------------------------

jzxchiang | 2021-07-02 00:31:22 UTC | #28

And when I convert the wasm to JS using binaryen's `wasm2js` tool, it's wayyyy too slow. For now, I comment out the BLS signature validation check entirely but for security's sake I don't want to...

-------------------------

kpeacock | 2021-07-02 16:22:30 UTC | #29

@chenyan actually implemented the BLS signature validation in JS and it was not very performant there either. He suggested that the path forward would be to offload the BLS check to run in a canister so you can simply call out to verify it instead of shipping the wasm with `agent-js`.

We haven't scoped out that work yet, though

-------------------------

alexeychirkov | 2021-09-10 15:38:34 UTC | #30

Hello
I have the same problem using variants in typescript.
How do you guys solve this?

-------------------------

kpeacock | 2021-09-10 15:45:33 UTC | #31

I've started using the pattern 
```
if("ok" in result){
  console.log(result.ok);
}
```

-------------------------

alexeychirkov | 2021-09-11 08:57:37 UTC | #32

@kpeacock Hello!

Are there any chances to improve typescript support for variants?

I mean currently variants in typescript looks something like this:

```
type MyVariant = { "ok" : null } | { "err" : "myErrorCode"  }
```

It is hard to create predicate with such type union.

I think it would be great to have:

```
type Type_1 = { "ok" : null }
type Type_2 = { "err" : "myErrorCode" }
type MyVariant = Type_1 | Type_2
```

If we have names type - it has great predicate support.

Maybe it is worth to create separate thread for this...

-------------------------

kpeacock | 2021-09-11 14:44:20 UTC | #33

Yeah, a separate thread would be good

-------------------------


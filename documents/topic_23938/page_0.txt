b3hr4d | 2023-10-21 20:35:00 UTC | #1

## Introduction

This comprehensive tutorial guides you through the process of building a decentralized e-commerce platform on the Internet Computer that can accept Ethereum (ETH) payments, handle withdrawals, and manage a digital storefront. Starting from a basic template, we'll incrementally add features to create a robust, cross-chain solution.

## Why I Made This Tutorial?

This tutorial is a hands-on guide designed for developers new to the Internet Computer blockchain. I've created a set of libraries to make development easier and more enjoyable, and this tutorial walks you through the process of building a decentralized ETH payment system using these libraries.

We'll explore key features like HTTP outcalls and stable memory, providing a solid foundation for anyone looking to bring their dream project to life on the Internet Computer. Although this tutorial uses my specific set of methods and libraries, there are many other tools and techniques you could use.

For example, you could integrate the [`ic-eth-rpc`](https://github.com/internet-computer-protocol/ic-eth-rpc) package for Ethereum RPC calls or accept ckETH as a payment method. The main goal here is to demonstrate the Internet Computer's flexibility and ease of use, especially when it comes to confirming transactions on-chain.

## Objective

The goal of this tutorial is to create a fully functional decentralized e-commerce platform that:

- Accepts ETH as payment for digital items
- Integrates with Ethereum smart contracts for payment processing.
- Verifies transactions on-chain for added security
- Allows for the withdrawal of ETH to an Ethereum address
- Utilizes stable memory to keep track of transactions and items.
- Manages a digital storefront with items for sale
- Implements access control to secure sensitive operations

## Final Product(YouTube Video)

https://youtu.be/lPNOqKwPRlE

## Prerequisites

- [DFINITY Canister SDK](https://sdk.dfinity.org/docs/quickstart/local-quickstart.html)
- [Node.js](https://nodejs.org/en/download/)
- [Rust](https://www.rust-lang.org/tools/install)
- Basic understanding of Ethereum and smart contracts

-------------------------

b3hr4d | 2023-10-21 17:50:16 UTC | #2

## Step 1: Clone the Starter Repository and Run the Project Locally

We'll begin by cloning the [`ic-rust-nextjs`](https://github.com/b3hr4d/ic-rust-nextjs) repository, which serves as our starter template.

### What's Inside the Starter Repository?

- [`README.md`](https://github.com/b3hr4d/ic-rust-nextjs/blob/main/README.md): Provides an overview and setup instructions.

- [`Cargo.toml`](https://github.com/b3hr4d/ic-rust-nextjs/blob/main/Cargo.toml): The manifest file for the Rust workspace.

- [`dfx.json`](https://github.com/b3hr4d/ic-rust-nextjs/blob/main/dfx.json): Configuration file for the DFINITY Canister SDK.

- [`backend/hello/src/lib.rs`](https://github.com/b3hr4d/ic-rust-nextjs/blob/main/backend/hello/src/lib.rs): The Rust code for the backend logic.

- [`src/pages/index.tsx`](https://github.com/b3hr4d/ic-rust-nextjs/blob/main/src/pages/index.tsx): The main page of the Next.js app.

- [`src/service/hello.ts`](https://github.com/b3hr4d/ic-rust-nextjs/blob/main/src/service/hello.ts): Service file to interact with the Rust backend.

### Cloning the Repository

To clone the repository, open your terminal and run:

```bash

git clone https://github.com/b3hr4d/ic-rust-nextjs.git

```

### Running the Project Locally

After cloning the repository, the next step is to run the project locally to ensure everything is set up correctly. Follow the commands below based on your package manager (Yarn or npm).

### Installing Dependencies

First, let's install all the required dependencies:

```bash

yarn install:all

# or

npm run install:all

```

### Running Local Internet Computer

To start the local Internet Computer environment, run:

```bash

yarn dfx:start

# or

npm run dfx:start

```

### Deploying to the Local Internet Computer

Deploy your the backend canister to the local Internet Computer by running:

```bash

yarn deploy hello

# or

npm run deploy hello

```

### Running the Next.js App

Finally, to run the Next.js(frontend) app, execute:

```bash

yarn dev

# or

npm run dev

```

Open your browser and navigate to [http://localhost:3000](http://localhost:3000) to see your app running.

![Alt text](upload://kqDnGbRdnaBvSycM8wLEQOd9MB4.png)

-------------------------

b3hr4d | 2023-10-22 13:56:58 UTC | #3


## Step 2: Modify the Backend for ETH Deposits

In this step, we'll modify the backend to include a function that generates a deposit principal from a canister ID. This is essential for converting SepoliaETH into ckSepoliaETH, as per the ckEth documentation.

### Installing the `b3_utils` Rust Crate

First, we need to install the [b3_utils](https://docs.rs/b3_utils/latest/b3_utils/) Rust crate. Open your `Cargo.toml` file and add the following line under `[dependencies]`:

```toml
b3_utils = "0.8.0"
```

or run this command:

```bash
cargo add b3_utils
```

### Modifying the `greet` Function

Replace the existing `greet` function with the new `deposit_principal` function:

```rust
use b3_utils::{vec_to_hex_string_with_0x, Subaccount};
use candid::Principal;

#[ic_cdk::query]
fn deposit_principal(principal: String) -> String {
    let principal = Principal::from_text(principal).unwrap();
    let subaccount = Subaccount::from_principal(principal);

    let bytes32 = subaccount.to_bytes32().unwrap();

    vec_to_hex_string_with_0x(bytes32)
}
```

#### Why This Change?

1. **Function Annotation**: We use `#[ic_cdk::query]` to indicate that this is a query method, meaning it's read-only and doesn't modify the state.

2. **Principal Conversion**: We convert the passed string into a `Principal` object, which is essential for generating a subaccount.

3. **Subaccount Generation**: We generate a `Subaccount` from the `Principal`, which is a necessary step for depositing ETH.

4. **Bytes32 Conversion**: We convert the subaccount into a bytes32 array, which is the required format for the smart contract on the Sepolia Ethereum testnet.

5. **Hex String**: Finally, we convert the bytes32 array into a hex string with a "0x" prefix, which can be used as an argument for the smart contract.

### Deploy the Modified Backend Canister

After making the changes to the backend, open another terminal and deploy the canister to your local Internet Computer environment using the following command:

```bash
yarn deploy hello
```

Note: confirm the conset with `yes` the change on the terminal.

This will deploy only the `hello` canister, which now includes the `deposit_principal` function.

### Update the Frontend Code

Navigate to the frontend code where the `useActorMethod` hook is used. This is typically found in a component file. Change the method from `"greet"` to `"deposit_principal"`:

```javascript
const { call, data, error, loading } = useActorMethod("deposit_principal")
```

#### Testing the Changes

1. **Pass the Canister ID**: Update the frontend to include an input field where you can enter the canister ID.

2. **Check the Output**: The output should be a hexadecimal string that represents the deposit principal, which can be used for depositing ETH.

![Alt text](upload://1FbtiLcS5TsQQ2kVhZsUZgW4Q6b.png)

-------------------------

b3hr4d | 2023-10-22 14:16:34 UTC | #4

## Step 3: Integrate MetaMask

In this step, we'll integrate MetaMask using the [wagmi](https://wagmi.sh) library and set up the frontend to call the minter helper contract's deposit function.

### Prerequisites

- Make sure you have the [MetaMask extension](https://metamask.io/download.html) installed in your browser.
- Create a new free account on [Alchemy](https://www.alchemy.com/). After signing up, you have to create a new Ethereum chain and Sepolia network app then you'll be provided with an API key.

1. **Create a `.env` File**: If you haven't already, create a `.env` file in the root directory of your project.

2. **Add Alchemy API Key**: Add the following line to your `.env` file:

   ```env
   NEXT_PUBLIC_ALCHEMY_KEY=your_alchemy_api_key_here
   ```

   Replace `your_alchemy_api_key_here` with the API key you got from Alchemy.

### Installing `wagmi` and `viem`

First, install the `wagmi` and `viem` packages:

```bash
yarn add wagmi viem
```

### Configure `wagmi`

Create a new file `config.ts` inside the `src/service` directory and add the following code:

```javascript
import { createPublicClient, http } from "viem"
import { createConfig, sepolia } from "wagmi"

export const config = createConfig({
  autoConnect: true,
  publicClient: createPublicClient({
    chain: sepolia,
    transport: http(
      `https://eth-sepolia.g.alchemy.com/v2/${process.env.NEXT_PUBLIC_ALCHEMY_KEY}`
    ),
  }),
})
```

### Create the `Wallet` Component

Create a new file named `Wallet.tsx` inside the `src/components` folder and add the following code:

```javascript
import { useAccount, useConnect, useDisconnect } from "wagmi"
import { MetaMaskConnector } from "wagmi/connectors/metaMask"

interface WalletProps {}

const Wallet: React.FC<WalletProps> = ({}) => {
  const { address } = useAccount()

  const { connect } = useConnect({
    connector: new MetaMaskConnector(),
  })

  const { disconnect } = useDisconnect()

  if (address)
    return (
      <main>
        Connected to: {address}
        <br />
        <button onClick={() => disconnect()}>Disconnect</button>
      </main>
    )
  return <button onClick={() => connect()}>Connect Wallet</button>
}

export default Wallet
```

### Update `index.tsx`

Finally, update your `src/pages/index.tsx` file and replace `<Greeting />` with the following code`:

```javascript
// ...existing imports
import Wallet from "../components/Wallet"
import { config } from "service/config"
import { WagmiConfig } from "wagmi"

function HomePage() {
  return (
    {/* ...existing components */}
    {/* <Greeting /> */}
    <WagmiConfig config={config}>
      <Wallet />
    </WagmiConfig>
    {/* ...existing components */}
  )
}
```

#### Testing the Changes

You should see a "Connect Wallet" button on your browser, similar to the screenshot below.

![Alt text](upload://vF3gDOsgZIDbFzfHRzlrDDw2POV.jpeg)
Clicking on the button should open a MetaMask popup asking for permission to connect. After connecting, you should see your wallet address on the screen.

-------------------------

b3hr4d | 2023-10-22 15:17:49 UTC | #5

## Step 4: Prepare Minter Helper Contract and Enable Deposits

In this step, we'll prepare the minter helper contract for calls and enable ETH deposits through the frontend.

### Fetch Contract ABI

1. **Navigate to Etherscan**: Open the [contract page on Sepolia Etherscan](https://sepolia.etherscan.io/address/0xb44B5e756A894775FC32EDdf3314Bb1B1944dC34#code).

2. **Copy Contract ABI**: Copy the Contract ABI from the "Contract" tab.
   ![Alt text](upload://yreXsq3lUqNVbDs1dRQX3rg6hXF.png)

3. **Create `abi.json`**: Inside the `src/service` directory, create a new file named `abi.json` and paste the copied ABI.

### Create the `Deposit` Component

Create a new file named `Deposit.tsx` inside the `src/components` directory and add the following code:

```javascript
import { canisterId } from "declarations/hello"
import { useEffect, useState } from "react"
import helperAbi from "service/abi.json"
import { useActorMethod } from "service/hello"
import { parseEther } from "viem"
import { useContractWrite } from "wagmi"

interface DepositProps {}

const Deposit: React.FC<DepositProps> = ({}) => {
  const [amount, setAmount] = useState(0)

  const { data: canisterDepositAddress, call } =
    useActorMethod("deposit_principal")

  useEffect(() => {
    call(canisterId)
  }, [])

  const { data, isLoading, write } = useContractWrite({
    address: "0xb44B5e756A894775FC32EDdf3314Bb1B1944dC34",
    abi: helperAbi,
    functionName: "deposit",
    value: parseEther(amount.toString()),
    args: [canisterDepositAddress],
  })

  const changeHandler = (e: React.ChangeEvent<HTMLInputElement>) => {
    let amount = e.target.valueAsNumber
    if (Number.isNaN(amount) || amount < 0) amount = 0

    setAmount(amount)
  }

  if (isLoading) {
    return <div>Loading...</div>
  } else if (data?.hash) {
    return <div>Transaction Hash: {data.hash}</div>
  } else {
    return (
      <div>
        <input type="number" value={amount} onChange={changeHandler} />
        <button onClick={() => write()}>Deposit</button>
      </div>
    )
  }
}

export default Deposit
```

#### Understanding `useContractWrite`

The `useContractWrite` hook is used to interact with Ethereum smart contracts. Here's what each parameter does:

- **`address`**: The Ethereum address of the contract you want to interact with.
- **`abi`**: The ABI (Application Binary Interface) of the contract, which is a JSON representation of the contract's methods and structures.
- **`functionName`**: The name of the function in the contract that you want to call.
- **`value`**: The amount of ETH to send along with the function call, converted to its smallest unit (wei) using `parseEther`.
- **`args`**: An array of arguments that the function takes. In this case, it's the deposit address generated by the canister.

### Update the `Wallet` Component

Add the `<Deposit />` component to the `Wallet.tsx` file, right above the "Disconnect" button:

```javascript
// ...existing code
return (
  <main>
    Connected to: {address}
    <br />
    <Deposit />
    <br />
    <button onClick={() => disconnect()}>Disconnect</button>
  </main>
)
```

#### Testing the Changes

You should have a small amount of Sepolia ETH in your wallet. you can get some using this [faucet](https://sepoliafaucet.com/).

1. **Call the Deposit Function**: Please make sure you are on the Sepolia network inside the metamask then use the new deposit input and button to initiate a deposit.
   ![Alt text](upload://nHlcWuABjdksqw4dNbATskAEyUr.png)
2. **Confirm with MetaMask**: A MetaMask popup should appear asking for confirmation to proceed with the transaction.
   ![Alt text](upload://kD90vabTMfTOkPKDfu5PASTeNDP.jpeg)
3. **Check the Output**: After confirming, you should see a transaction hash.
   ![Alt text](upload://etef48vWA7MCgnNmiCmS3fhZRhq.png)

-------------------------

b3hr4d | 2023-10-21 19:30:48 UTC | #6

## Step 5: Wait for Transaction Confirmation

In this step, we'll implement a mechanism to wait for transaction confirmations before verifying the payment inside the canister.

### Create the `Confirmation` Component

Create a new file named `Confirmation.tsx` inside the `src/components` directory and add the following code:

```javascript
import { Hash } from "viem"
import { useWaitForTransaction } from "wagmi"

interface ConfirmationProps {
  hash: Hash;
}

const Confirmation: React.FC<ConfirmationProps> = ({ hash }) => {
  const { data, isError, error, isLoading } = useWaitForTransaction({
    hash,
    confirmations: 6, // 6 confirmations for be sure that the transaction is confirmed
  })

  if (isError && error) {
    return <div>Transaction error {error.toString()}</div>
  } else if (isLoading) {
    return <div>Waiting for confirmation…</div>
  } else if (data) {
    return <div>Transaction Status: {data.status}</div>
  } else {
    return null
  }
}

export default Confirmation
```

#### Understanding `useWaitForTransaction`

The `useWaitForTransaction` hook is used to wait for a specified number of confirmations for a given Ethereum transaction hash. Here's what each parameter does:

- **`hash`**: The transaction hash for which you are waiting for confirmations.

- **`confirmations`**: The number of confirmations to wait for before considering the transaction as confirmed. The default is 1, but in this example, we set it to 6 for added security.

### Update the `Deposit` Component

Replace the line that shows the transaction hash with the `Confirmation` component:

Change this:

```javascript
return <div>Transaction Hash: {data.hash}</div>
```

To this:

```javascript
return <Confirmation hash={data.hash} />
```

#### Testing the Changes

1. **Send Another Transaction**: Initiate another deposit transaction.

2. **Check the Output**: You should see the confirmation process in action. Once the specified number of confirmations is reached, the transaction status will be displayed.
   ![Alt text](upload://9pWCU1jk3lJrXWpDYUY1vximdG8.png)

-------------------------

b3hr4d | 2023-10-23 10:21:06 UTC | #7

## Step 6: Fetching Transaction On-Chain

In this step, we'll verify the Ethereum transaction on-chain by calling the Ethereum JSON-RPC API from within the canister.

### Create Rust Structs for API Response

1. **Copy API Response**: Copy the API response from the [eth_getTransactionReceipt](https://docs.alchemy.com/reference/eth-gettransactionreceipt-base) documentation.
   ![Alt text](upload://tyMLS5sBU5RjDd4iupYfBnBslIL.png)
2. **Generate Rust Structs**: Paste the copied response into this [online converter](https://transform.tools/json-to-rust-serde) to generate Rust structs.
   ![Alt text](upload://tVqLVshx7HFHJ4DSQw2FKAqwkrh.png)
3. **Save the File**: Save the generated code in a new file named `receipt.rs` inside the `backend/hello/src` directory.

### Add Dependencies

Add the following dependencies to your `Cargo.toml`:

```toml
serde = "1.0"
serde_json = "1.0"
serde_derive = "1.0"
```

### Create the `eth_get_transaction_receipt` Function

Here's the code snippet for the function:

```rust
mod receipt;
use serde_json::json;
use b3_utils::outcall::{HttpOutcall, HttpOutcallResponse};

const RPC_URL: &str = "https://eth-sepolia.g.alchemy.com/v2/YOUR_API_KEY"; // replace with you alchemy API key

async fn eth_get_transaction_receipt(hash: String) -> Result<receipt::Root, String> {
    let rpc = json!({
        "jsonrpc": "2.0",
        "id": 0,
        "method": "eth_getTransactionReceipt",
        "params": [hash]
    });

    let request = HttpOutcall::new(RPC_URL)
        .post(&rpc.to_string(), Some(2048))
        .send_with_closure(|response: HttpOutcallResponse| HttpOutcallResponse {
            status: response.status,
            body: response.body,
            ..Default::default()
        });

    match request.await {
        Ok(response) => {
            if response.status != 200 {
                return Err(format!("Error: {}", response.status));
            }

            let trasnaction = serde_json::from_slice::<receipt::Root>(&response.body)
                .map_err(|e| format!("Error: {}", e.to_string()))?;

            Ok(trasnaction)
        }
        Err(m) => Err(format!("Error: {}", m)),
    }
}
```
Note: Please always keep `ic_cdk::export_candid!();` at the very end of the `lib.rs` file.

#### Understanding the Function

The function `eth_get_transaction_receipt` performs the following tasks:

- **Prepare the JSON-RPC Payload**: It prepares the JSON-RPC payload using the `serde_json::json!` macro.

- **Make the HTTP Outcall**: It uses the `HttpOutcall` struct from `b3_utils` to make an HTTP POST request to the Ethereum JSON-RPC API.

- **Handle the Response**: It handles the API response, deserializes it into the `receipt::Root` struct, and returns it.

### Test the Function Using Candid UI

For testing the function, we'll use the Candid UI, which is a web-based interface for interacting with canisters. It's automatically generated when you deploy a canister using the DFINITY Canister SDK.

Add this function to your `lib.rs` file:

```rust
#[ic_cdk::update]
async fn get_receipt(hash: String) -> String {
    let receipt = eth_get_transaction_receipt(hash).await.unwrap();

    serde_json::to_string(&receipt).unwrap()
}
```

1. **Deploy the Canister**: Deploy the updated canister using the command `yarn deploy hello`.

2. **Navigate to Candid UI**: After successful deployment, navigate to the Candid UI using the link provided in the terminal.
   Somthing like this `http://127.0.0.1:4943/?canisterId=bd3sg-teaaa-aaaaa-qaaba-cai&id=bkyz2-fmaaa-aaaaa-qaaaq-cai`

3. **Test the Function**: Inside the Candid UI, you should see the `get_receipt` function. Test it by passing a transaction hash and observing the response.
   ![Alt text](upload://19qo5Lr5gXz13SmpuZFXksI2jN6.png)

-------------------------

b3hr4d | 2023-10-21 17:52:27 UTC | #8

## Step 7: On-Chain Verification of Transactions

In this step, we'll create a function to verify Ethereum transactions on-chain. This function will use the logs emitted by the smart contract to verify the transaction details.

#### Event Topics

The logs' topics are based on the `ReceivedEth` event, which has the following signature:
![Alt text](upload://iU1zjE3w3acS45YchisQtJslVot.png)

```solidity
ReceivedEth (index_topic_1 address from, uint256 value, index_topic_2 bytes32 principal)
```

- `log.topics[0]`: Event signature hash
- `log.topics[1]`: `from` address (index_topic_1)
- `log.topics[2]`: `principal` (index_topic_2)

#### Event Data

- `log.data`: `value` (uint256)

### Create the `verify_transaction` Function

Here's the code snippet for the function:

```rust
const MINTER_ADDRESS: &str = "0xb44b5e756a894775fc32eddf3314bb1b1944dc34";

use b3_utils::hex_string_with_0x_to_nat;
use candid::Nat;
#[ic_cdk::update]
async fn verify_transaction(hash: String) -> (Nat, String) {
    let tx = eth_get_transaction_receipt(hash).await.unwrap();

    if tx.result.status != "0x1" {
        panic!("Transaction failed")
    }

    let log = tx.result.logs[0].clone();

    if tx.result.to != MINTER_ADDRESS || log.address != MINTER_ADDRESS {
        panic!("Address mismatch")
    }

    if log.topics[2] != canister_deposit_principal() {
        panic!("Principal mismatch")
    }

    let amount = hex_string_with_0x_to_nat(log.data).unwrap();

    (amount, tx.result.from)
}
```

#### Understanding the Function

The function `verify_transaction` performs the following tasks:

- **Check Transaction Status**: It checks if the transaction was successful by comparing the `status` field to "0x1".

- **Verify Address**: It verifies that the `to` address in the transaction and the `address` in the logs match the minter address.

- **Verify Principal**: It verifies that the principal in the logs matches the canister's deposit principal. The principal is found in `log.topics[2]`.

- **Return Transaction Details**: It returns the amount and the sender's address.

### Create a Function to Return Canister Deposit Principal

For a more robust and secure way, create a new function that returns the canister's deposit principal:

```rust
#[ic_cdk::query]
fn canister_deposit_principal() -> String {
    let subaccount = Subaccount::from(ic_cdk::id());

    let bytes32 = subaccount.to_bytes32().unwrap();

    vec_to_hex_string_with_0x(bytes32)
}
```

#### Testing the Functions

1. **Deploy the Canister**: Deploy the updated canister using `yarn deploy hello`.

2. **Navigate to Candid UI**: After successful deployment, navigate to the Candid UI using the link provided in the terminal.

3. **Test the Functions**: Inside the Candid UI, you should see the `verify_transaction` and `canister_deposit_principal` functions. Test them by passing a transaction hash and observing the response.
   ![Alt text](upload://6tRH16BnLjTTaYFK8nJ0lyHsPT3.png)

-------------------------

b3hr4d | 2023-10-21 17:53:04 UTC | #9

## Step 8: Frontend Update for On-Chain Verification

In this step, we'll update the frontend to call the `verify_transaction` function after the transaction has been confirmed on-chain.

### Create the `VerifyTransaction` Component

#### Understanding the Component

The `VerifyTransaction` component performs the following tasks:

- **Call `verify_transaction`**: It calls the `verify_transaction` function from the canister when the `hash` prop is provided.

- **Display Status**: It displays the transaction details, including the amount and the sender's address, once the transaction is confirmed on-chain.

Here's the code snippet for the component:

```javascript
import { useEffect } from "react"
import { useActorMethod } from "service/hello"
import { formatEther } from "viem"

interface VerifyTransactionProps {
  hash: string;
}

const VerifyTransaction: React.FC<VerifyTransactionProps> = ({ hash }) => {
  const { loading, error, data, call } = useActorMethod("verify_transaction")

  useEffect(() => {
    call(hash)
  }, [hash])

  if (loading) {
    return <div>Processing…</div>
  } else if (error) {
    return <div>{error.toString()}</div>
  } else if (data) {
    return (
      <div>
        Transaction(<b>{hash}</b>) with <b>{formatEther(data[0])}</b>ETH from{" "}
        <b>{data[1]}</b> is confirmed on-chain.
      </div>
    )
  } else {
    return null
  }
}

export default VerifyTransaction
```

### Update the `Confirmation` Component

Replace the line that shows the transaction status with the `VerifyTransaction` component:

Change this:

```javascript
return <div>Transaction Status: {data.status}</div>
```

To this:

```javascript
return <VerifyTransaction hash={data.transactionHash} />
```

#### Testing the Changes

1. **Initiate a Transaction**: Initiate a deposit transaction and confirm it.

2. **Check the Output**: You should see the transaction details displayed once the transaction is confirmed and procceed on-chain.
   ![Alt text](upload://3mwI7CnSMRRT0ciLgVEUpD1zN2R.png)

-------------------------

b3hr4d | 2023-10-21 19:49:07 UTC | #10

## Step 9: Deploying to the Internet Computer Mainnet

In this step, we'll deploy our project to the Internet Computer mainnet. This involves a few key steps:

### Topping Up Your Wallet with Cycles

Before deploying to the mainnet, you'll need to ensure that your wallet has enough cycles.

1. **Quickstart**: Run `dfx quickstart` in your terminal and follow the process to top up your wallet.

2. **Faucet Cycles**: Alternatively, you can get some free cycles from the DFINITY [cycles faucet](https://forum.dfinity.org/t/cycles-faucet-is-now-live).

### Deploying the Canister

Run the following command to deploy your canister to the mainnet:

```bash
yarn deploy --network=ic
```

Alternatively, you can choose to deploy only the backend to the mainnet and run the frontend locally. To deploy just the backend, use:

```bash
yarn deploy hello --network=ic
```

To run the frontend locally, execute:

```bash
yarn dev
```

Upon successful deployment of the backend, you should see output similar to this in your terminal:

![Alt text](upload://g7jsWyoMAZesvi1wtzLjK3RW7lJ.png)

### Testing on Mainnet

1. **Open the Frontend**: If you've deployed the frontend to the mainnet, navigate to the frontend URL provided in the terminal. If you're running the frontend locally, you can access it via `http://localhost:3000` or the URL provided in your local development server.

2. **Initiate a Transaction**: Initiate a deposit transaction and confirm it.
   ![Alt text](upload://1kZuxvS20EELqY6AZLrztv1qr4K.png)

3. **Check Alchemy Logs**: Open your Alchemy dashboard to check the logs. You should see 13 different calls to the JSON-RPC, which collect consensus on the result and then send it to your canister. This ensures that you can trust the whole process as a successful payment.

Here's what you should see:
![Alt text](upload://nIuwKorgEtq2SBc2wStzp5meBmb.png)

-------------------------

b3hr4d | 2023-10-21 19:23:29 UTC | #11

## Step 10: Integrating with ICRC Standard

In this step, we'll integrate our canister with the ckETH ICRC standard to show the balance and enable ETH withdrawal.

### Adding Ledger Feature to `b3_utils`

First, add the "ledger" feature to the `b3_utils` crate in your `Cargo.toml`:

```toml
b3_utils = { version = "0.8.0", features = ["ledger"] }
```

### Setting Up Ledger and Minter Constants

Add the following lines at the top of your Rust code to specify the ledger and minter canister IDs:

```rust
const LEDGER: &str = "apia6-jaaaa-aaaar-qabma-cai";
const MINTER: &str = "jzenf-aiaaa-aaaar-qaa7q-cai";
```

### Creating the Balance Function

#### Understanding the Function

The `balance` function uses the `ICRC1` trait from `b3_utils` to fetch the balance of the canister in ckETH.

Here's the code snippet for the function:

```rust
use b3_utils::ledger::{ICRCAccount, ICRC1};
use candid::Principal;

#[ic_cdk::update]
async fn balance() -> Nat {
    let account = ICRCAccount::new(ic_cdk::id(), None);

    ICRC1::from(LEDGER).balance_of(account).await.unwrap()
}
```

#### Testing the ckETH Balance Function

1. **Deploy to Mainnet**: Run `yarn deploy hello --network=ic` to upgrade canister.

2. **Open Candid UI**: Navigate to the Candid UI and test the `balance` function. Note that the minting process might take some time.
   ![Alt text](upload://mb6stT1Yb2OjODufGiprvtdsoIY.png)

### Creating the Transfer Function

#### Understanding the Function

The `transfer` function allows the canister to transfer a specified amount of ckETH to another account.
The function uses the `ICRC1` trait from `b3_utils` to transfer the specified amount of ckETH to the recipient.

Here's the code snippet for the function:

```rust
use b3_utils::ledger::{ICRC1TransferArgs, ICRC1TransferResult};
use std::str::FromStr;

#[ic_cdk::update]
async fn transfer(to: String, amount: Nat) -> ICRC1TransferResult {
    let to = ICRCAccount::from_str(&to).unwrap();

    let transfer_args = ICRC1TransferArgs {
        to,
        amount,
        from_subaccount: None,
        fee: None,
        memo: None,
        created_at_time: None,
    };

    ICRC1::from(LEDGER).transfer(transfer_args).await.unwrap()
}
```

#### Testing the Transfer Function

1. **Deploy to Mainnet**: Run `yarn deploy hello --network=ic` to upgrade canister.

2. **Open Candid UI**: Navigate to the Candid UI and test the `transfer` function by passing the recipient's [ICRCAccount](https://forum.dfinity.org/t/icrc-1-account-human-readable-format/14682/56) comptible format string and the amount of ckETH to transfer.
   ![Alt text](upload://qdoQZalPiPu8JyO1tuAWRuioXKm.png)

### Approving the Minter to Spend ckETH

#### Understanding the Function

The `approve` function uses the `ICRC2` trait from `b3_utils` to approve the minter to spend your ckETH. This is a one-time action if you approve a large amount.

Here's the code snippet for the function:

```rust
use b3_utils::ledger::{ICRC2ApproveArgs, ICRC2ApproveResult, ICRC2};

#[ic_cdk::update]
async fn approve(amount: Nat) -> ICRC2ApproveResult {
    let minter = Principal::from_text(&MINTER).unwrap();

    let spender = ICRCAccount::new(minter, None);

    let args = ICRC2ApproveArgs {
        amount,
        spender,
        created_at_time: None,
        expected_allowance: None,
        expires_at: None,
        fee: None,
        memo: None,
        from_subaccount: None,
    };

    ICRC2::from(LEDGER).approve(args).await.unwrap()
}
```

#### Testing the Approve Function

1. **Deploy to Mainnet**: Again upgrade the canister using `yarn deploy hello --network=ic`.

2. **Open Candid UI**: Navigate to the Candid UI and test the `approve` function.
   ![Alt text](upload://tph5LqdKSV5ZpNb2mY9wb05G1X8.png)

-------------------------

b3hr4d | 2023-10-21 17:53:48 UTC | #12

## Step 11: Creating the Withdraw Function

In this step, we'll create a `withdraw` function that allows users to withdraw ETH from the canister.

### Defining Types from the Minter Canister

First, define some types that will be used for the withdrawal operation. These types are derived from the minter canister.

```rust
use candid::{CandidType, Deserialize};

#[derive(CandidType, Deserialize)]
pub struct WithdrawalArg {
    pub amount: Nat,
    pub recipient: String,
}

#[derive(CandidType, Deserialize, Clone, Debug)]
pub struct RetrieveEthRequest {
    pub block_index: Nat,
}

#[derive(CandidType, Deserialize, Debug)]
pub enum WithdrawalError {
    AmountTooLow { min_withdrawal_amount: Nat },
    InsufficientFunds { balance: Nat },
    InsufficientAllowance { allowance: Nat },
    TemporarilyUnavailable(String),
}

type WithdrawalResult = Result<RetrieveEthRequest, WithdrawalError>;
```

### Creating the Withdraw Function

#### Understanding the Function

The `withdraw` function uses the `InterCall` trait from `b3_utils` to make an internal canister call to the minter canister. The function takes an `amount` and a `recipient` as arguments and initiates the withdrawal process.

Here's the code snippet for the function:

```rust
use b3_utils::InterCall;

#[ic_cdk::update]
async fn withdraw(amount: Nat, recipient: String) -> WithdrawalResult {
    let withraw = WithdrawalArg { amount, recipient };

    InterCall::from(MINTER)
        .call("withdraw_eth", withraw)
        .await
        .unwrap()
}
```

#### Testing the Withdraw Function

1. **Deploy to Mainnet**: Run `yarn deploy hello --network=ic`.

2. **Open Candid UI**: Navigate to the Candid UI and test the `withdraw` function. Make sure to enter the amount in wei.
   ![Alt text](upload://aluKRIMkGdB5VrwdFoJ1gRmOQy0.png)

-------------------------

b3hr4d | 2023-10-22 09:20:10 UTC | #13

## Step 12: Adding Security and Functionalities

In this step, we'll add some security measures and functionalities to our canister.

### Adding Security Measures

#### Guards

We'll add guards to the `withdraw`, `transfer` and `approve` functions to ensure that only the controller can call them. Add the following line at the top of your Rust code:

```rust
use b3_utils::caller_is_controller;
```

Then, add the `guard` attribute to the `withdraw` `transfer` and `approve` functions:

```rust
#[ic_cdk::update(guard = "caller_is_controller")]
```

#### Transaction List

To prevent a transaction from being processed more than once, we'll use stable memory. Add the "stable_memory" feature to `b3_utils` in your `Cargo.toml`:

```toml
b3_utils = { version = "0.8.0", features = ["ledger", "stable_memory"] }
```

Then, add the following code to initialize stable memory:

```rust
use b3_utils::memory::init_stable_mem_refcell;
use b3_utils::memory::types::DefaultStableBTreeMap;
use std::cell::RefCell;

thread_local! {
    static TRANSACTIONS: RefCell<DefaultStableBTreeMap<String, String>> = init_stable_mem_refcell("trasnactions", 1).unwrap();
    static ITEMS: RefCell<DefaultStableBTreeMap<String, u128>> = init_stable_mem_refcell("items", 2).unwrap();
}
```

### Adding Functionalities

#### Item Management

We'll add functionalities to set items and their prices, and to get the list of items. Here are the functions:

```rust
#[ic_cdk::query]
fn get_transaction_list() -> Vec<(String, String)> {
    TRANSACTIONS.with(|t| {
        t.borrow()
            .iter()
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect()
    })
}

#[ic_cdk::update(guard = "caller_is_controller")]
fn set_item(item: String, price: u128) {
    ITEMS.with(|p| p.borrow_mut().insert(item, price));
}

#[ic_cdk::query]
fn get_items() -> Vec<(String, u128)> {
    ITEMS.with(|p| {
        p.borrow()
            .iter()
            .map(|(k, v)| (k.clone(), v.clone()))
            .collect()
    })
}
```

#### Buying Items

We'll add a function to buy items. This function will check the transaction list to ensure that the transaction has not been processed before. and check the amount to ensure that it's not too low.

Here's the function:

```rust
#[ic_cdk::update]
async fn buy_item(item: String, hash: String) -> u64 {
    if TRANSACTIONS.with(|t| t.borrow().contains_key(&hash)) {
        panic!("Transaction already processed")
    }

    let price = ITEMS.with(|p| {
        p.borrow()
            .get(&item)
            .map(|p| p.clone())
            .unwrap_or_else(|| panic!("Item not found"))
    });

    let (amount, from) = verify_transaction(hash.clone()).await;

    if amount < price {
        panic!("Amount too low")
    }

    TRANSACTIONS.with(|t| {
        let mut t = t.borrow_mut();
        t.insert(hash, from);

        t.len() as u64
    })
}
```

### Testing

1. **Deploy to Mainnet**: Run `yarn deploy hello --network=ic`.

2. **Testing Guards**: Use the terminal to execute functions with guards. For example:

   ```bash
   dfx canister call hello withdraw '(10000000000000000, "0xB51f94aEEebE55A3760E8169A22e536eBD3a6DCB")' --network ic
   ```

   To add a new controller, run:

   ```bash
   dfx canister update-settings hello --add-controller 'YOUR_PRINCIPAL' --network=ic
   ```

3. **Adding Items**: Add items using the terminal:

   ```bash
   dfx canister call hello set_item '("Pizza", 1000000000000)' --network ic
   ```

   Check the items inside the Candid UI using `get_items`.
   ![Alt text](upload://moMlZrWAcZcjOfVoOCtr9rNhejG.png)

-------------------------

b3hr4d | 2023-10-21 18:19:05 UTC | #14

## Step 13: Frontend Integration for Shop and Item Purchase

In this step, we'll integrate the frontend to display a shop and handle item purchases.

### Shop Component

Create a new file `Shop.tsx` inside the `src/components` directory and add the following code:

```jsx
import { useEffect } from "react"
import { useActorMethod } from "service/hello"
import Item from "./Item"

interface ShopProps {}

const Shop: React.FC<ShopProps> = ({}) => {
  const { data: items, loading, call } = useActorMethod("get_items")

  useEffect(() => {
    call()
  }, [])

  return (
    <div
      style={{
        marginTop: 10,
        display: "grid",
        gridTemplateColumns: "repeat(2, 1fr)",
        gridGap: 20,
      }}
    >
      {loading ? (
        <div>Loading...</div>
      ) : (
        items?.map(([name, price]) => {
          return <Item name={name} price={price} key={name} />
        })
      )}
    </div>
  )
}

export default Shop
```

This component fetches the list of items from the backend and displays them in a grid layout.

### Item Component

Create a new file `Item.tsx` inside the `src/components` directory and add the following code:

```jsx
import { useEffect } from "react"
import helperAbi from "service/abi.json"
import { useActorMethod } from "service/hello"
import { formatEther } from "viem"
import { useContractWrite } from "wagmi"
import Confirmation from "./Confirmation"

interface ItemProps {
  name: string
  price: bigint
}

const Item: React.FC<ItemProps> = ({ name, price }) => {
  const { data: canisterDepositAddress, call } = useActorMethod(
    "canister_deposit_principal"
  )

  useEffect(() => {
    call()
  }, [])

  const { data, isLoading, write } = useContractWrite({
    address: "0xb44B5e756A894775FC32EDdf3314Bb1B1944dC34",
    abi: helperAbi,
    functionName: "deposit",
    value: price,
    args: [canisterDepositAddress]
  })

  if (isLoading) {
    return <div>Buying {name}…</div>
  } else if (data?.hash) {
    return <Confirmation hash={data.hash} item={name} />
  } else {
    return (
      <div>
        <h3>{name}</h3>
        <div>{formatEther(price).toString()} ETH</div>
        <button onClick={() => write()}>Buy {name}</button>
      </div>
    )
  }
}

export default Item
```

This component handles the purchase of individual items. It uses the `canister_deposit_principal` and `deposit` methods to handle the transaction.

### Confirmation Component

Edit the existing `Confirmation.tsx` file to add the `item` prop:

```jsx
import { Hash } from "viem"
import { useWaitForTransaction } from "wagmi"
import VerifyTransaction from "./VerifyTransaction"

interface ConfirmationProps {
  item: string
  hash: Hash
}

const Confirmation: React.FC<ConfirmationProps> = ({ item, hash }) => {
  const { data, isError, error, isLoading } = useWaitForTransaction({
    hash,
    confirmations: 6
  })

  if (isError && error) {
    return <div>Transaction error {error.toString()}</div>
  } else if (isLoading) {
    return <div>Waiting for confirmation on Ethereum…</div>
  } else if (data) {
    return <VerifyTransaction hash={data.transactionHash} item={item} />
  } else {
    return null
  }
}

export default Confirmation
```

This component waits for the Ethereum transaction to be confirmed and then triggers the on-chain verification on the Internet Computer.

### Verify Transaction Component

Edit the existing `VerifyTransaction.tsx` file to add the `item` prop and work with the new `buy_item` method:

```jsx
import { useEffect } from "react"
import { useActorMethod } from "service/hello"

interface VerifyTransactionProps {
  item: string
  hash: string
}

const VerifyTransaction: React.FC<VerifyTransactionProps> = ({
  item,
  hash
}) => {
  const { loading, error, data, call } = useActorMethod("buy_item")

  useEffect(() => {
    call(item, hash)
  }, [hash])

  if (loading) {
    return <div>Processing Purchase on ICP...</div>
  } else if (error) {
    return <div>{error.toString()}</div>
  } else if (data) {
    return (
      <div>
        <h3>{item} bought!</h3>
        <div>Purchase ID: {data.toString()}</div>
      </div>
    )
  } else {
    return null
  }
}

export default VerifyTransaction
```

This component calls the `buy_item` method on the backend to finalize the purchase and display a purchase ID.

### Update Wallet Component

In your `Wallet.tsx`, replace `<Deposit />` with `<Shop />`.

### Testing

1. **Local Testing**: Run `yarn dev` to test the application locally.

2. **Deploy to Mainnet**: Run `yarn deploy --network=ic` to deploy the application to the Internet Computer mainnet.

3. **Live Example**: The live example can be accessed at [https://uu4vt-kqaaa-aaaap-abmia-cai.icp0.io/](https://uu4vt-kqaaa-aaaap-abmia-cai.icp0.io/).

Thank you for taking the time to explore this tutorial. I hope it serves as a helpful starting point for your journey into the Internet Computer ecosystem. If you'd like to dive deeper, you can clone the project and test it out yourself. Here's the GitHub repository for direct cloning: [eth_payment_tutorial](https://github.com/b3hr4d/eth_payment_tutorial).

Happy coding!

-------------------------

b3hr4d | 2023-10-21 18:01:21 UTC | #16

Great question! You can integrate with shipping services using another HTTP outcall. By sending a request to the shipping service's API, you can easily handle shipping logistics right from your canister. This way, you can automate the entire process from payment to shipping.

-------------------------

b3hr4d | 2023-10-24 09:18:08 UTC | #17

[quote="b3hr4d, post:10, topic:23938"]
**Check Alchemy Logs**: Open your Alchemy dashboard to check the logs. You should see 13 different calls to the JSON-RPC, which collect consensus on the result and then send it to your canister. This ensures that you can trust the whole process as a successful payment.
[/quote]

🔥 One of the most fascinating sections in this tutorial is where we dive into the JSON-RPC calls. You'll see 13 different calls to the JSON-RPC, each collecting consensus on the result before sending it to your canister. This ensures unparalleled trust in the entire payment process.

👉 This level of trust and security is hard to achieve outside of the Internet Computer ecosystem. And the best part? It's at least 1000x cheaper than running similar operations on AWS!

-------------------------

integral_wizard | 2023-11-06 07:28:47 UTC | #18

Wow. What a thoughtful guide. Thank you for creating it. 🙏 Hope it is also ingested into the dev LLM model.

-------------------------

abc | 2023-11-06 07:30:15 UTC | #19

https://forum.dfinity.org/t/entrepreneurship-groups-for-finding-the-right-people-to-work-with/3813/8?u=abc

-------------------------

vdve1997 | 2024-05-06 23:19:57 UTC | #20

Hey! Would there be any setbacks on doing this on a Motoko built dapp?

-------------------------

b3hr4d | 2024-05-07 08:00:54 UTC | #21

Hey, I don't think there would be any problem with using Motoko, especially considering the availability of tools like the [EVM RPC client](https://github.com/internet-computer-protocol/evm-rpc-canister). The only challenge you might face is the lack of certain conversion libraries in Motoko.

-------------------------

nolma | 2024-07-27 23:52:48 UTC | #22

Hello, thanks for the guide. I'm trying to follow it.

Update the Frontend Code

Navigate to the frontend code where the `useActorMethod` hook is used. This is typically found in a component file. Change the method from `"greet"` to `"deposit_principal"`:

```
const { call, data, error, loading } = useActorMethod("deposit_principal")
```

more has to be done here than shown - the service has to be updated. I'm trying this:

from the JS service:
```
import createReActor from "@re-actor/core"
import { canisterId, hello, idlFactory, createActor } from "declarations/hello"

export const {
  initialize,
  useActorMethod
} = createReActor(() =>
  createActor(canisterId, {
    agentOptions: {
      host: process.env.NEXT_PUBLIC_IC_HOST
    }
  })
)
```

and for the rust .did file - this did not regenerate when I ran deploy and the tutorial did not say to update this:

```
cat hello/hello.did 
service : { deposit_principal : (text) -> (text) query }
```

now when I run the code I get a "method deposit_principal not found" error in the UI, I think because the JS does not have the signature:

```
grep -nr "greet" ./src/
./src/declarations/hello/hello.did.d.ts:5:export interface _SERVICE { 'greet' : ActorMethod<[string], string> }
./src/declarations/hello/hello.did.js:2:  return IDL.Service({ 'greet' : IDL.Func([IDL.Text], [IDL.Text], ['query']) });
./src/components/Greeting.tsx:11: //   functionName: "greet",
```

as here it still has the greet reference, even after doing yarn build and npm run deploy hello.

How do I compile the rust did into JS?

-------------------------

b3hr4d | 2024-07-28 09:06:50 UTC | #23

Hello @nolma,

Thank you for reaching out and providing details on the challenges you're facing while following the guide.

Make sure you have `ic_cdk::export_candid!();` at the end of your Rust code, then try to run this script: [predeploy.sh](https://github.com/b3hr4d/eth_payment_tutorial/blob/ef41a4aea376cbce7628cf8f0d13f7551fd04a8f/predeploy.sh). 
```shell
sh ./predeploy.sh
```
It will generate the .did file automatically.

These steps should align your frontend and backend services properly, resolving the "method not found" error you encountered.

If you have further questions or need additional assistance, please feel free to ask.

-------------------------

nolma | 2024-07-29 00:02:11 UTC | #24

Hi, thanks for the quick response. The predeploy script fixed the did generation. I mistakenly rmeoved the export_candid and readded, thanks.

Now when I run, I enter the canister ID into the field and get a response "cyclic object value".

Is there some other frontend or backend change not shown in the tutorial?

It seems the `data` is being updated with an object that cannot render cleanly.

-------------------------

Stephen-Kimoi | 2024-07-29 18:47:19 UTC | #25

Hello @b3hr4d 

I tried interacting with the site and came across this error whenever I try to make a purchase:
![image|574x405](upload://zwT1yWzjOGnewxz64TtE8NxrizV.png)

-------------------------

b3hr4d | 2024-07-29 23:32:15 UTC | #26

[quote="nolma, post:24, topic:23938"]
It seems the `data` is being updated with an object that cannot render cleanly.
[/quote]
Actually the dependencies is not updated for a while, I probably should update the whole tutorial and make a new version soon!

Hello @Stephen-Kimoi 
Yes you are right, I'll fix the site soon!

-------------------------

Stephen-Kimoi | 2024-07-30 13:36:18 UTC | #27

Hello @b3hr4d 

I am trying to get the transaction receipt using HTTP outcalls but I am getting this error: 
``` 
Call was rejected:
Request ID: 75af36cca01a947fba819345e9a05fd015260cc354523153ab76244da0f818e1
Reject code: 5
Reject text: Canister bkyz2-fmaaa-aaaaa-qaaaq-cai trapped explicitly: Panicked at 'called `Result::unwrap()` on an `Err` value: "Error: Http body exceeds size limit of 1608 bytes."', src/canister_one/src/ck_eth_payments.rs:43:59
``` 

This is how the functions ``get_receipt`` and ``eth_get_transaction_receipt`` look like on my end. They have a similar implementation to yours: 
``` 
// Testing get receipt function 
#[ic_cdk::update]
async fn get_receipt(hash: String) -> String {
    let receipt = eth_get_transaction_receipt(hash).await.unwrap(); 

    serde_json::to_string(&receipt).unwrap()
}

// Function for getting transaction receipt the transaction hash
async fn eth_get_transaction_receipt(hash: String) -> Result<receipt::Root, String> {

    // Preparing JSON RPC Payload usnig the serde_json::json!
    let rpc = json!({
        "jsonrpc": "2.0",
        "id": 0,
        "method": "eth_getTransactionReceipt",
        "params": [hash]
    }); 
    
    // Using HttpOutcall struct from b3_utils to make an HTTP POST request to the RPC URL
    let request = HttpOutcall::new(RPC_URL)
        .post(&rpc.to_string(), Some(2048))
        .send_with_closure(|response: HttpOutcallResponse| HttpOutcallResponse {
            status: response.status,
            body: response.body,
            ..Default::default()
        });
    
    match request.await {
        Ok(response) => {
            if response.status != 200u16 {
                return Err(format!("Error: {}", response.status));
            }

            let transaction = serde_json::from_slice::<receipt::Root>(&response.body)
                .map_err(|e| format!("Error: {}", e.to_string()))?;

            Ok(transaction)
        }
        Err(m) => Err(format!("Error: {}", m)),
    }
}
``` 

How can I fix this :thinking: ?

-------------------------

b3hr4d | 2024-07-30 17:24:28 UTC | #28

I think we should replace the HTTP outcall with the [EVM RPC client](https://github.com/internet-computer-protocol/evm-rpc-canister) in this case. I'll update this tutorial soon!

-------------------------

laska189345938458347 | 2024-07-30 17:57:03 UTC | #29

Interesting, also we can use it for token pre-sale in ICP from Ethereum wallet

-------------------------

Stephen-Kimoi | 2024-07-30 21:44:51 UTC | #30

I implemented it and it worked. Here's a snippet of my code: 
``` 
// Function for getting transaction receipt the transaction hash
async fn eth_get_transaction_receipt(hash: String) -> Result<GetTransactionReceiptResult, String> {
    // Make the call to the EVM_RPC canister
    let result: Result<(MultiGetTransactionReceiptResult,), String> = EVM_RPC 
        .eth_get_transaction_receipt(
            RpcServices::EthSepolia(Some(vec![
                EthSepoliaService::PublicNode,
                EthSepoliaService::BlockPi,
                EthSepoliaService::Ankr,
            ])),
            None, 
            hash, 
            10_000_000_000
        )
        .await 
        .map_err(|e| format!("Failed to call eth_getTransactionReceipt: {:?}", e));

    match result {
        Ok((MultiGetTransactionReceiptResult::Consistent(receipt),)) => {
            Ok(receipt)
        },
        Ok((MultiGetTransactionReceiptResult::Inconsistent(error),)) => {
            Err(format!("EVM_RPC returned inconsistent results: {:?}", error))
        },
        Err(e) => Err(format!("Error calling EVM_RPC: {}", e)),
    }    
}
``` 

But now I have to add more helper functions to help me serialize the result and make it compatible with candid. 

Here are some of the helper functions I added: 
1.  ``ReceiptWrapper`` enum that mirrors structure of ``GetTransactionReceiptResult`` 
2. ``TransactionReceiptData`` struct to hold the data from the ``Ok`` variant.
```
#[derive(Serialize)]
enum ReceiptWrapper {
    Ok(TransactionReceiptData),
    Err(String),
}

#[derive(Serialize)]
struct TransactionReceiptData {
    to: String,
    status: String, // We'll convert Nat to String for serialization
    transaction_hash: String,
    block_number: String, // We'll convert Nat to String for serialization
    from: String,
    //
}
``` 

I've also implemented ``From<GetTransactionReceiptResult>`` for ``ReceiptWrapper`` to convert between the types.
```impl From<GetTransactionReceiptResult> for ReceiptWrapper {
    fn from(result: GetTransactionReceiptResult) -> Self {
        match result {
            GetTransactionReceiptResult::Ok(receipt) => {
                if let Some(receipt) = receipt {
                    ReceiptWrapper::Ok(TransactionReceiptData {
                        to: receipt.to,
                        status: receipt.status.to_string(),
                        transaction_hash: receipt.transactionHash,
                        block_number: receipt.blockNumber.to_string(),
                        from: receipt.from,
                        // ... map other fields as needed
                    })
                } else {
                    ReceiptWrapper::Err("Receipt is None".to_string())
                }
            },
            GetTransactionReceiptResult::Err(e) => ReceiptWrapper::Err(format!("Error on Get transaction receipt result: {:?}", e)),
        }
    }
}
``` 

I've also modified the ``get_receipt`` function, I convert the ``GetTransactionReceiptResult`` to our ``ReceiptWrapper`` and then serialize it.
```
#[ic_cdk::update]
async fn get_receipt(hash: String) -> String {
    let receipt = eth_get_transaction_receipt(hash).await.unwrap();
    let wrapper = ReceiptWrapper::from(receipt);
    serde_json::to_string(&wrapper).unwrap()
}
``` 

Seems like a lengthy way to do it.

-------------------------

b3hr4d | 2024-07-31 10:07:01 UTC | #31

Great job implementing this! Could you please submit a pull request with these changes, if possible?

-------------------------

nolma | 2024-07-31 12:06:49 UTC | #32

@Stephen-Kimoi please make the PR!

Btw, I found https://github.com/dfinity/erc20-icp/tree/main/ic which looks like an easy way to do tokens. If I understand this project, it's a way to more an erc-20 to and from IC. On IC it uses the ICRC-1 standard. Has anyone used this?

-------------------------

Stephen-Kimoi | 2024-07-31 21:49:57 UTC | #33

Thank you! 

Yes, I am already done, here's the [PR](https://github.com/b3hr4d/eth_payment_tutorial/pull/1)

-------------------------

b3hr4d | 2024-08-01 09:23:35 UTC | #34

[quote="nolma, post:32, topic:23938"]
Btw, I found [erc20-icp/ic at main · dfinity/erc20-icp · GitHub ](https://github.com/dfinity/erc20-icp/tree/main/ic) which looks like an easy way to do tokens. If I understand this project, it’s a way to more an erc-20 to and from IC. On IC it uses the ICRC-1 standard. Has anyone used this?
[/quote]

Regarding the ERC-20 support, we should definitely add it to this tutorial. If you're interested, feel free to open a new issue and submit a pull request. I'll be happy to assist you in incorporating it!

-------------------------

b3hr4d | 2024-08-03 09:26:34 UTC | #35

Hello everyone,

I wanted to let you all know that I've made some significant updates to the [eth_payment_tutorial project](https://github.com/b3hr4d/eth_payment_tutorial). The recent pull request includes:

- **Refactoring**: Cleaned up the codebase for better readability and maintainability.
- **New Features**: Integrated the use of the [EVM RPC canister](https://github.com/internet-computer-protocol/evm-rpc-canister) instead of HTTP outcall, thanks to @Stephen-Kimoi for the contribution.
- **Dependency Updates**: Updated all dependencies to their latest versions to ensure compatibility and security.
- **Integration with `@ic-reactor/react`**: Incorporated the [ic-reactor/react library](https://forum.dfinity.org/t/introduction-ic-reactor-react-for-react-developers/27930), simplifying authentication and canister interaction in React applications.
- **Simplified Steps**: Streamlined the tutorial steps to make it easier for developers to follow along and implement the features.

Thank you for your continued support and contributions!

-------------------------

Stephen-Kimoi | 2024-08-03 11:23:40 UTC | #36

I am glad to have participated in this!

-------------------------


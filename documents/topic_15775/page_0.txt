Fulco | 2022-10-06 09:00:42 UTC | #1

**Proposal**

There is a function on the management canister called `canister_status` which gives you information about the canister like its controllers, wasm hash, cycle balance. Currently this can only be called by the controllers of a canister. I propose we make this callable by anyone. 

**Background**

You can get some of the information from `canister_status` off-chain already like the wasm hash, and the controllers of a canister. 

The topic of getting this information on-chain has been raised on the forum multiple times, but always resulted in a discussion without a definitive answer on what to do next. (I hope we see a more formalized ICRC process soon!) 

https://forum.dfinity.org/t/getting-a-canisters-controller-on-chain/7531

https://forum.dfinity.org/t/canister-integrity-verification-on-chain-is-missing/10353/7

https://forum.dfinity.org/t/feature-request-provide-easier-access-to-canister-status/15398/8

There is also this RFC but it seems like that never really made it farther then initial thoughts / MVP

https://forum.dfinity.org/t/rfc-standardising-how-smart-contracts-expose-state/8544

I have seen people post hacks on how to get around this. Like using the outbound http requests or calling the `canister_status` as a non controller and then parsing the error message to get the controllers. But needing to use these hacks is a horrendous dev experience. 

During my time at DFINTY I was always in favor of making more canister info public, but now that I'm working on a DAO framework not being able to get this info easily on-chain is especially annoying.

**Arguments in favor**

- Prevent incidents like the lost IC turtles NFT collection. With **canister_status** being public anybody could have monitored the cycles and could have warned the owners or send in some cycles themselves. Imagine this happening to a token with a huge market cap. 

- Being able to trust a canister by confirming it has no controllers, the hash matches the code you expect, and it won't run out of cycles soon or that you know when to top it of yourself if the original devs abandon it. 

**Arguments against**

- You can just use something like the [blackhole canister](https://github.com/ninegua/ic-blackhole/blob/main/src/blackhole.mo) to expose the `canister_status`  if you want to expose it. 

I personally find this again a terrible developer experience needing to manage an entire extra canister and making sure that doesn't run out of cycles as well, just to expose this one call that I think should be public by default anyways. 

- An attacker could use knowing the cycles balance to initiate a cycle drain attack right when it gets low. 

I think the freezing threshold prevents this pretty well and I think important canisters running out of cycles because they get forgotten or nobody can monitor their cycles poses a far bigger risk to the ecosystem. 

**options**

- **option A** :  Making `canister_status` public to anyone. 
- **option B**:  Adding a new public API to the management canister that gives you the same information you can get off-chain like wasm hash, controllers, and running status without needing to resort to work arounds.
- **option C**: Make `canister_status` something that the controller can choose to expose or not with a flag which is set to public by default
- **option D**: Make `canister_status` something that the controller can choose to expose or not with a flag which is set to private by default
- **option E**: Do nothing


I suspect that option **A** would be the least engineering effort, but I would love to hear the opinion from the foundation as that is just a guess.

I can't imagine anybody being against option **B** at the minimum, but I really hope we can just go with **A** and potentially add a private flag in the future if there is sufficient demand. 


**Next steps**

The first step is for devs to voice their opinions here about which option they would prefer and why. I would really appreciate it if an engineer DFINITY who knows the management canister well could offer their thoughts as well with regards to the engineering effort.

If we reach consensus on which option seems to be the most popular I would love it if one of the existing named neurons who is used to making proposals could do it for me. This way I don't have to set up a 10 ICP neuron for making the proposal (I'd rather keep my personal one private). I can transfer the 10 ICP if it gets rejected.

-------------------------

wpb | 2022-10-06 12:32:50 UTC | #2

If you lead the deliberation on this topic and arrive at the final text you want to use in the proposal, then I’d be happy to submit the Governance Motion proposal for you.

Also, are you prepared to implement the code changes that would be needed for whatever form of the proposal passes the Governance Motion proposal stage?  In my experience, it’s difficult to tell if proposals that are passed by the community make it onto a priority list at DFINITY.  In this particular case, the idea has been discussed and is supposedly already on a backlog, so it doesn’t seem that passing a Governance Motion proposal will change that status.  However, it you develop the code, I suspect you can collaborate with DFINITY to get permission to implement it yourself through a proposal topic that actually changes the code.  I would love to see this happen and you may have the resources/connections to pull it off.

-------------------------

Fulco | 2022-10-06 11:57:27 UTC | #3

Thank you! that is greatly appreciated. 

I don't think coding it up is the main effort here. I believe option **A** would just be the removal of these lines in the code in canister_manager.rs:


```
// Skip the controller check if the canister itself is requesting its
// own status, as the canister is considered in the same trust domain.
if sender != canister.canister_id().get() {
    if let Err(err) = validate_controller(canister, &sender) {
        return Err(err);
    }
}
```

But the foundation would probably want to do a security review before removing those lines. 

I don't know if it would make sense for me to make the non-governance proposal(s). I would need to lockup 10 ICP (maybe more if every subnet needs an update) and go through the effort of creating the proposal. Something the foundation is already very experienced in. 

I don't know if this is on the backlog currently. This motion would be meant to get it on there or give it a higher priority. If it isn't something they would want to do in the near future we'll just have to resort to using workarounds like the outgoing http requests.

-------------------------

diegop | 2022-10-06 14:00:54 UTC | #4

[quote="Fulco, post:1, topic:15775"]
* **option D**: Make `canister_status` something that the controller can choose to expose or not with a flag which is set to private by default
[/quote]

My 2 cents: Frankly, something like this option D is what I prefer. 

I always rather start from a point of privacy as default when it comes to state. Inversely, if a developer or canister does NOT expose their status, their respective community should think hard about how much to trust it. 

This would also work well now so it does not have to grandfather all the old previous canisters.

-------------------------

infu | 2022-10-06 14:20:32 UTC | #5

I like option D too.
Showing hash & controllers :+1:
But there is another argument against showing cycles. An attacker can check which one of your functions costs the most cycles to run. Not good info to give.

-------------------------

oss | 2022-10-06 15:39:21 UTC | #6

Fully support this. At a minimum, I think controllers and wasm hash should be easily obtainable on chain. 
Currently also, if we make the `canister_status` call, the error already includes half the information we need. This is obviously hacky and a workaround, as we're doing string manipulation to extract principal ids from the error response, but still goes to show its silly to block that info or not provide it in another way

https://forum.dfinity.org/t/if-you-need-to-get-a-canisters-controllers-from-within-canister/15772?u=oss

-------------------------

paulyoung | 2022-10-06 20:41:29 UTC | #7

I think option D is appealing because it both preserves the existing behavior and enables your use case.

-------------------------

icme | 2022-10-06 20:43:41 UTC | #8

On board with D, except **without** providing public access to cycles remaining.

I believe one of the DFINITY teams is currently working on a project to expose the controller and wasm hash history. I’m on board with exposing these first two (verifying integrity of the canister code/owners), but @infu brings up a good point with respect to cycles.

[quote="infu, post:5, topic:15775"]
But there is another argument against showing cycles. An attacker can check which one of your functions costs the most cycles to run. Not good info to give.
[/quote]

Not to mention other inference attacks, such as potentially being able to infer sensitive information/logic in code by inferring a difference in cycles available to the canister between API calls.

If anything, the owner of the canister can implement a common API interface to provide additional metrics such as cycles if they choose to do so.

-------------------------

Omaxus | 2022-10-06 20:44:34 UTC | #9

[quote="Fulco, post:1, topic:15775"]
* **option D**: Make `canister_status` something that the controller can choose to expose or not with a flag which is set to private by default
[/quote]

I think this option is also what I would prefer too. The benefits to provide the status in general, however, outweighed to drawbacks. With option we have the benefit that it allows to preserve privacy as default.

-------------------------

infu | 2022-10-06 20:58:33 UTC | #10

On a side note, yesterday I tried to get the controller with this 
[ https://internetcomputer.org/docs/current/references/ic-interface-spec/#state-tree-canister-information ]
but I could only get the module_hash, the controller was null. Any ideas?
Considering hash and controller are already public data, I won't mind if they just go public inside IC without additional configuration if that's hard to do.

-------------------------

Fulco | 2022-10-06 21:13:30 UTC | #11

To clarify:

You think `canister_status` should never expose the amount of cycles left even when the dev needs to explicitly opt in to expose this? 

I think exposing the amount of cycles left is one of the core reasons you would want to have `canister_status` public. For example to create:

- automatic cycle top-up services
- reassuring tokenholders that the token canister still has plenty of cycles left

Alternatively instead of option **D** being a simple boolean flag it could also be a variant with something like:

```
variant {
   Private;
   PublicWithCycles; 
   PublicWithoutCycles;
}
```

-------------------------

icme | 2022-10-07 03:06:31 UTC | #12

[quote="Fulco, post:11, topic:15775"]
You think `canister_status` should never expose the amount of cycles left even when the dev needs to explicitly opt in to expose this?
[/quote]

The cycle data would still be available to the developer and controller(s), just not publicly available. I guess I’d be open to the opt-in if the developer can later retract this and opt-out at any time of their choosing (say some vulnerability pops up that hasn’t yet been discovered).

Another option would be to make the cycles data publicly available to through canister_status once the freezing canister threshold is hit, since at this point community assets could be at risk and there is no further risk of a cycle drain attack once the canister is frozen.


[quote="Fulco, post:11, topic:15775"]
I think exposing the amount of cycles left is one of the core reasons you would want to have `canister_status` public. For example to create:

* automatic cycle top-up services
* reassuring tokenholders that the token canister still has plenty of cycles left
[/quote]

If the canister wishes to provide cycles data access to a top-up service, they can expose this cycles data as an API.

If we’re talking about a NFT token collection and you want transparency, then the developer might open source the code, and one could match up the code with the wasm hash to verify the API is returning the correct amount of cycles.

-------------------------

Zane | 2022-10-07 06:47:09 UTC | #13

I don't have enough knowledge on the matter to give an informed opinion but this is what @rossberg had to say on the topic months ago:
https://forum.dfinity.org/t/canister-controller-and-cycle-balance-need-to-be-public/5591/19

-------------------------

diegop | 2022-10-07 06:10:37 UTC | #14

Fwiw Andreas’s posts are the ones that convinced me that a privacy-by-default approach may make sense in this case (with an option for developers to expose).

-------------------------

JaMarco | 2022-10-07 06:25:21 UTC | #15

Why does it worry you?

-------------------------

Zane | 2022-10-07 06:51:20 UTC | #16

My bad, was going to write something else initially and forgot to delete that part :sweat_smile:

-------------------------

dsarlis | 2022-10-07 08:29:22 UTC | #17

Hey everyone, I'd like to share some of the current thinking on this topic. Btw, thanks @Fulco  for bringing this up in a constructive way.

First of all, let's take a look at the result returned by `canister_status` (taken from the interface spec):
```
canister_status : (record {canister_id : canister_id}) -> (record {
      status : variant { running; stopping; stopped };
      settings: definite_canister_settings;
      module_hash: opt blob;
      memory_size: nat;
      cycles: nat;
      idle_cycles_burned_per_day: nat;
  });
```
In the result there are certain fields that are private to the canister and its controllers, like cycles, the rate of burning, memory size and settings. The reason I say these are private is because they can reveal information about the canister's status and an attacker could even exploit some of them to learn patterns about the canister's usage or even force specific cycle drain attacks. 

I think it's a slippery slope if we take an approach where such private fields become public by default: it would break potentially existing assumptions some canister developers have and (worse imo) can surprise many people that never even thought that such attacks could be possible. In a sense, I very much agree with the opinions others have voiced in this thread about keeping the privacy of these fields and potential issues if we change them to public.

That pretty much excludes options A and C imo right from the get go. Even if we believed that everything should be public, we cannot break existing applications which all they know so far is that this information is accessible to controllers -- that would also be very bad user experience.

Between B and D: we have discussed this internally a lot I must say. We are currently planning to provide B (essentially give access to the information that's already public like the controllers and wasm hash to anyone). The reason D should not be preferred imo is that it's better for the system to **not** provide an option that can backfire in some cases (think of attacks that attempt to analyze your canister's cycles usage) and leave the option to expose this completely to the application level (e.g. with the blackhole approach that Fulco mentioned or if the canister decides to expose an endpoint that returns its own balance).

Lastly, I must also admit I have not heard compelling arguments why there should be an option at the system level to expose the cycles balance of canisters publicly. The use case of making sure that a canister does not run out of cycles can be covered nicely with e.g. [tipjar](https://github.com/ninegua/tipjar) purely on the application side. I'm also a big fan of the idea that if something can be built on the canister-land it should be built there and not add more options to the system.

-------------------------

infu | 2022-10-07 09:03:53 UTC | #18

The cycles part can be solved if all canisters using a refilling service use a function like `__refill` which instead of giving cycles balance will specify how many cycles it wants and it can have its own threshold while rounding the number of requested cycles. Since you are all here, you can just agree on something and create the 'IC refill protocol'.

-------------------------

Fulco | 2022-10-07 11:37:20 UTC | #19

Thank you for weighing in @dsarlis!

I think most comments here have said they would be in favor of **D**, so I think when this comes to a proposal that would certainly be the one to be suggested. 

I'm not convinced that a sophisticated cycles drain attack is such a huge issue compared with all the other footguns the IC has. Cycles are very cheap compared to other blockchains, there is an instruction limit per call, and there are a limited amount of messages per second that a canister can handle. There is a nice protection mechanism with the freezing_threshold and just depositing a boatload of cycles into anything critical.

Personally when developing a canister I'm far more worried about exposing a single function somewhere that can be used to freely add state and can be used to fill my canister up with junk. 

With regards to doing anything that can be done at a canister level there I have to disagree. I heard the same arguments with adding variable intervals to the heartbeat functionality. Needing to rely on another canister is a pain for something so small. And after some feedback from the community it seems like DFINITY wants to provide it at the system level now. 

https://forum.dfinity.org/t/heartbeat-improvements-timers-community-consideration/14201

With ethereum and other EVM chains smartcontracts are immutable, can't run out of cycles, and they don't suddenly get errors when they reach a certain amount of state. 

When you rely on any other service on the IC for something critical you have to make sure that all these things are taken care of which comes down to needing to do a full security audit. And even then you still have to monitor the cycles of every service you are using yourself if you want to be absolutely sure that it won't break. 

I think anytime the system can provide something that is fairly basic that is a far superior option. Option **D** seem intuitively like far less work to me than the new heartbeat API. It's just adding an extra permission to an api that already exists.  

One thing that would be especially nice compared to the blackhole canister is that everybody calling this system API would have to pay the cycles for it themselves as opposed to the owner of the blackhole canister. 

I could just write a script that starts spamming the blackhole e3mmv-5qaaa-aaaah-aadma-cai for free right now. It could make any other canister relying on it way slower and also at the time of writing it only seems to have 4,019,244,002,015 / 1,000,000,000,000 = **4.019244** Trillion cycles.

-------------------------

dsarlis | 2022-10-07 14:03:18 UTC | #20

> I’m not convinced that a sophisticated cycles drain attack is such a huge issue compared with all the other footguns the IC has.

I think we should be careful to **not** add more footguns if we can avoid it.

> With regards to doing anything that can be done at a canister level there I have to disagree. I heard the same arguments with adding variable intervals to the heartbeat functionality. Needing to rely on another canister is a pain for something so small. And after some feedback from the community it seems like DFINITY wants to provide it at the system level now.

I believe a big selling point of the IC is the composability and interoperability among dapps. Having the system provide the minimum functionality to enable dapps should be the guiding principle and then people can build solutions on top of the basics (potentially multiple of them that can also cater for different use cases). The heartbeat example is actually a good example of the basic system functionality turning out to be incomplete.

> I think anytime the system can provide something that is fairly basic that is a far superior option. Option **D** seem intuitively like far less work to me than the new heartbeat API. It’s just adding an extra permission to an api that already exists.

I suppose this is the main part where we seem to come from different angles. I do not consider exposing private state of the canisters "fairly basic". I think it's something that's useful in certain use cases (like some you described in this thread) and not necessarily something that any dapp would want. The ability to optionally expose this for certain dapps already exists, so it's unclear to me what we gain by adding the option to the system as well.

> One thing that would be especially nice compared to the blackhole canister is that everybody calling this system API would have to pay the cycles for it themselves as opposed to the owner of the blackhole canister.

That's not entirely true. If `canister_status` is public, what would prevent a random user to send such requests? The canister itself would still need to pay for those requests. The management api is not available through query calls so you have to send ingress messages that are charged to the canister whose status you requested -- even if you could access it through query calls it would still be charged eventually when queries are charged in general and it would charge the canister. If **D** is to be implemented, we would also need to be careful about this aspect and not introduce potential attacks. So, to make it more clear, no I don't think it's about just adding a flag that allows `canister_status` to be read by anyone if the flag is true.

-------------------------

Fulco | 2022-10-07 15:13:52 UTC | #21

[quote="dsarlis, post:20, topic:15775"]
I think we should be careful to **not** add more footguns if we can avoid it.
[/quote]

I really think footgun is an overstatement. You don't need super careful analysis of the exact cycles balances to perform a cycle drain attack. When I look at the costs here https://internetcomputer.org/docs/current/developer-docs/deploy/computation-and-storage-costs/ the most expensive fixed costs are **ingress message reception** and **update call execution**. Both of which you know will be subtracted based on the reply of a call. 

Then you have **ingress byte reception** which you also know as an attacker. If somebody accepts Vecs / Text without a limit just make it a 2MB message. And finally you could measure the time to respond knowing that if it takes long there might be Xnet calls involved or larger computations. 

I also don't think people who don't open source their code would feel the need to set the flag to public. You can't trust their canister anyways. For the people who *do* opensource their code the attacker could just try out which function subtracts the most amount of cycles locally.

> I suppose this is the main part where we seem to come from different angles. I do not consider exposing private state of the canisters “fairly basic”

Yeah I do guess we have a difference of opinion here and that's okay. It's why I wanted to bring it to a vote, because it is not an issue or feature everybody agrees on. 

I think the "everything is public" model of Ethereum and other chains has brought some very powerful network effects with it. The ICP ledger certainly wasn't designed with privacy in mind, but made other tradeoffs. 

(sidenote: cycles already have monetary value through dexes like Sonic. Having private ways to store and send cycles could cause issues with regulators in the future because of AML) 

I would be interested in knowing what DFINITY would vote though as they have a pretty big chunk of voting power.

> The management api is not available through query calls so you have to send ingress messages that are charged to the canister whose status you requested 

I didn't know this and this would kind of devalue the option for making `canister_status` public. Why is the canister whose status is being requested being charged instead of the canister that initiated the call?

-------------------------

dsarlis | 2022-10-07 15:53:32 UTC | #22

> Why is the canister whose status is being requested being charged instead of the canister that initiated the call?

This is the case when the message is initiated by a end-user, not another canister (in the latter the sending canister is charged). Users can also control canisters and if they send management messages like `canister_status` we need to charge the target canister just like we do for other ingress messages (ingress messages cannot carry cycles so the "target" canister is the only option to apply the charge).

-------------------------

ulan | 2022-10-08 12:33:35 UTC | #23

I just wanted to chime in here and mention that making cycles balance public is not merely a footgun but rather a real security issue. That's because the attacker can learn how many instructions a specific message has executed by reading the cycles balance of the canister before and after the execution. This kind of side-channel attack is known as [Timing attack](https://en.wikipedia.org/wiki/Timing_attack) where the time in our case is represented by executed instructions and it is deterministic, making the attack much simpler.

This attack can be used to steal secret/private data from the canister. It is very difficult to protect against the attack in the presence of such a reliable and deterministic side channel. From the security point of view, I would suggest thinking of the public cycles balance as being equivalent to the public canister state. In other words, option D would be safe only for canisters that are fully public and ideally the developers confirm that with "I am okay if everyone can read the canister state" before enabling the flag.

-------------------------

DontKillRobots | 2022-10-08 16:43:50 UTC | #24

Im glad someone actually brought up a real argument against public cycles.

 Making cycles public does not make cycle draining more of a threat in my opinion and anyone who has tested cycle draining on their own canisters locally would realize that pretty quick.

But timing attack to read state would be an insanely complicated attack to pull off even with cycles exposed and that state they are trying to read is already exposed to node operators anyway so canister owners should probably not treat canister state as bulletproof in the first place

-------------------------

Fulco | 2022-10-08 17:37:39 UTC | #25

I don't think anybody should put any private data at all on the IC. Any node provider in the subnet could access it. I do think this is a more critical issue than a cycle draining attack. 

Note though that the official docs currently suggest the blackhole canister as a solution without this warning. https://internetcomputer.org/docs/current/concepts/trust-in-canisters

-----

Based on the comments from Dimitri and Ulan I have some newly formed thoughts about what I would like to see. 

**What I need to know as a canister/dev to trust other canisters for critical services**

- The controllers
- The module hash
- The **rough** cycles balance
- The freezing threshold

(perhaps when subnets become full and busy the memory and compute allocation will become important too) 

All this information is essential if I want to have a dependency on another canister in a trustless manner. I do not think services on the IC can be truly composable and interoperable without it. You'll always have to handle the case where the canister you rely on stop working. 

This is not the case on other EVM chains. People can happily build on e.g the uniswap protocol without worrying about the smart contract disappearing. 

**Why I suggested to make canister_status (optionally) public**

`canister_status` has all this information and already existed. It seemed like the least effort for the foundation and is an API devs are already familiar with. 

**Why I don't like the blackhole canister solution**

- It is a bad developer experience needing to manage / keep in mind an extra canister. 
- If you forget it or somebody drains it on purpose you'll never know your cycles balance again. This could not happen if it is included in the system API.
- I think it is bad from a security perspective to need to hand over all the permissions that come with being controller just to expose the canister status. What if somebody hacks the Internet Computer documentation page about the blackhole canister and puts their own malicious canister id instead of bxyoi-2iaaa-aaaag-aanhq-cai? It seems the opposite of the capabilities based system Rossberg was a fan of. 
- it doesn't prevent the issues mentioned by dsarlis and Ulan here.

**New suggestion based on the conversation here**

A new API that a canister can choose to expose with a flag

- Exposes the information in canister_status
- Where cycles are rounded down to the trillion
- Which can only be called by principals that are able to pay for it themselves


I know @dsarlis said the foundation is already planning to provide **B** I wonder if this is something that could potentially be added to it.

-------------------------

rossberg | 2022-10-08 19:17:30 UTC | #26

Amen to what @ulan said. After the whole Spectre disaster, from which our industry still hasn't fully recovered (and probably never will), it would be extremely unwise to remain knowingly shortsighted about these sort of risks.

@Fulco, AFAIK, a controller canister (black hole or otherwise) is not needed to publish cycle balance. If a canister so wishes, nothing prevents it from itself providing a regular method for inquiring its current balance. I would recommend against that, though.

Keep in mind that the ability to store private data safely in canisters is a stated future goal for the IC. Thus the work on using enclaves etc.

-------------------------

diegop | 2022-10-08 20:32:42 UTC | #27

[quote="ulan, post:23, topic:15775"]
In other words, option D would be safe only for canisters that are fully public and ideally the developers confirm that with “I am okay if everyone can read the canister state” before enabling the flag.
[/quote]

I agree 100% with this. I think there are lots of fully public use cases (NFTs for example), but definitely should be used with this in mind.

-------------------------

paulyoung | 2022-10-08 21:07:55 UTC | #28

Having read the follow up responses here I think I now prefer option B.

-------------------------

Fulco | 2022-10-08 22:19:34 UTC | #29

I think I'll refrain from making an NNS proposal. The foundation already seems to be building **B** and exposing cycles balance besides that seems like a more nuanced issue that I don't think is ready for an NNS vote. 

This issue seems more suited for something like a standards committee where different bigger players signal there support. Hopefully ICRC can be used for to decide on a common way to expose cycle balances that don't give away too much information (e.g by rounding it down to a certain level).

-------------------------

infu | 2022-10-09 08:46:18 UTC | #30

I wanted to drop this not very popular AgentJs feature here.
It currently provides "module_hash", but doesn't give "controllers"
I think the documentation says it should https://internetcomputer.org/docs/current/references/ic-interface-spec/#state-tree-canister-information
```
import { CanisterStatus, HttpAgent } from "@dfinity/agent";

const requestCanisterStatus = (canister_id) => {
  const agent = new HttpAgent({ host: `https://ic0.app` });
  //if (local) await agent.fetchRootKey();
  return CanisterStatus.request({
    canister_id,
    agent,
    paths: ["controllers", "module_hash"],
  });
};
```

-------------------------

dsarlis | 2022-10-10 08:22:53 UTC | #31

@infu I'm not sure what you meant here. Are you saying that there's some bug in AgentJS? If so, it should be raised as a separate topic (or directly as in issue in the repository). Indeed, you should be able to request both `module_hash` and `controllers` from the [system state tree](https://internetcomputer.org/docs/current/references/ic-interface-spec/#state-tree-canister-information).

-------------------------

saikatdas0790 | 2022-10-10 09:19:48 UTC | #32

Relevant post that I created sometime back:
https://forum.dfinity.org/t/feature-request-provide-easier-access-to-canister-status/15398

This would also make it possible for the canister itself to make that information public with its own public API if it so chooses.

-------------------------

ulan | 2022-10-10 11:56:00 UTC | #33

[quote="Fulco, post:25, topic:15775"]
Note though that the official docs currently suggest the blackhole canister as a solution without this warning. [Trust in Canisters | Internet Computer Home ](https://internetcomputer.org/docs/current/concepts/trust-in-canisters)
[/quote]

Thanks for pointing this out. I'll reach out to the owners to update the docs. I guess they were not aware of the side-channel attack.

FWIW, a variant of option D that is limited to fully public canisters seems very useful to me. For example, if the flag that the developer would set is named something like "public_canister" or "canister_with_public_state",  then exposing the cycles balance would useful and safe. In that case options B and D are not exclusive to each other and we could support both.

-------------------------

Fulco | 2022-10-10 12:38:33 UTC | #34

I would love to see a flag like that. While I said I would refrain from making the NNS proposal and that perhaps a standards committee could come together on a way to expose cycles I think just having such a flag is a far superior solution. 

We don't really have a standards committee and these things take a lot of time. I think all of the previous forum threads indicate a demand for such a flag and there are plenty of live use cases today like token or NFT canisters that should use it.

-------------------------

dsarlis | 2022-10-10 14:48:05 UTC | #35

Allowing a canister to query its own status was actually spec'ed out [recently](https://github.com/dfinity/interface-spec/commit/4d412720e02b0846cb1e22b37bdeda3173ea9390) and the replica that is being rolled out this week will also include this change. The reasoning being that reading its own status is safe for a canister to do since it's by definition in its own trust domain.

-------------------------

icme | 2022-10-10 18:49:22 UTC | #36

To get around this type of a Timing/Spectre attack, could the IC introduce a mask or some sort of Cycles cost randomization to the cycles balance returned? 

For example: **If you are a controlling principal**, then you will receive a 100% accurate cycles balance. 

However, **if you are a not a controller**, then you will receive the cycles balance +/- 50,000 cycles (randomized). The basic idea being that users with a vested interest in a canister's cycles balance will be able to have a general idea of how many cycles a canister has (if it needs to be topped up), but it will take a significant amount more work to extract any useful information due to the cycles mask.

-------------------------

kpeacock | 2022-10-10 19:40:44 UTC | #37

I Love to hear this!

-------------------------

rossberg | 2022-10-11 10:01:17 UTC | #38

@icme, that's the old idea of weakening the timing signal by injecting noise. Unfortunately, that doesn't really solve the problem, since it's usually easy enough for an attacker to strengthen the signal by repeating the probe sufficiently often.

The only measure that really helps is making all code paths equally costly. But that is quite difficult to achieve without special support from the engine. [Constant Time Wasm](https://github.com/PLSysSec/ct-wasm) is a research project experimenting with bringing such support to Wasm.

Edit: Somewhat more up-to-date [link to CT-Wasm](https://github.com/WebAssembly/constant-time).

-------------------------

ulan | 2022-10-11 12:36:34 UTC | #39

@Fulco: I discussed the public canister flag idea with @dsarlis and @Manu. We didn't immediately see any issues with the idea and its implementation. If you adjust your original proposal to be based on the public canister flag and drive the NNS proposal process, we would be happy to help on the  implementation side.

-------------------------

Fulco | 2022-10-11 13:06:38 UTC | #40

That's great to hear! I try to write something up. 

@wpb @paulyoung @jwiegley @infu  @skilesare @blockpunk 

As owners of named neurons which a developer background would you support a proposal for option **D**. Where:

- canister_status can be made public to be called by anyone with a flag
- this flag is set to non public by default
- this flag is called something "public_canister" or "canister_with_public_state" to indicate the implications clearly

If you do please let me know and I'll include your support in the proposal linking to this forum thread.

-------------------------

ulan | 2022-10-11 13:21:56 UTC | #41

It might be worthwhile to list all implications of the flag in the proposal.
E.g. if the canister sets the flag, then anyone would be able to read:

* the canister status,
* the Wasm source binary,
* the Wasm and stable memory pages.
* any other user-visible settings/fields of the canister.

Even if reading some of these is not technically possible today, it may become possible in the future and public canister should not break then.

-------------------------

Fulco | 2022-10-11 13:29:31 UTC | #42

Do you mean that it is the plan in the future for developers to be able to download.

* the Wasm source binary,
* the Wasm and stable memory pages.

And that in the future this flag would expose that publicly as well. Or do you mean that somebody could more easily find an exploit to retrieve that extra information with the flag enabled?

-------------------------

ulan | 2022-10-11 13:33:40 UTC | #43

> Do you mean that it is the plan in the future for developers to be able to download ...

Yes, a public canister should have no expectation of privacy. On the IC side we should be free to provide tools that allow anyone to download the code and the state of a public canister.

-------------------------

infu | 2022-10-11 13:36:44 UTC | #44

That's a good feature to have. However, probably need more flags. It's not worth becoming that public just to help scripts refill canisters

-------------------------

ulan | 2022-10-11 13:39:31 UTC | #45

That's my point about the side-channel attack: making cycles balance public is only safe for fully public canisters. If a canister have some secret data, then it must not make its cycles balance public (otherwise it may accidentally leak some bits of the secret data).

-------------------------

infu | 2022-10-11 13:46:45 UTC | #46

Have you considered placing the _refill (reporting how many cycles are needed) function inside CDK's, just like _tmp_if_hack is right now getting added inside all Motoko canisters?

-------------------------

skilesare | 2022-10-11 14:06:18 UTC | #47

I might just support this as the defacto state. Until we have enclaves we are all just pretending that any of this is private. A node provider could dump this for any canister at any time. 

If this was all public, downloadable, and if the replica would return a certifiable hash of the memory, then we could offload a good bit of read traffic to read only user run replicas.

-------------------------

ulan | 2022-10-11 14:23:21 UTC | #48

I hope the enclaves will come in the future and I consider that as an implementation issue.

At the protocol spec level I think it is worthwhile to keep the distinction between private and public canisters.

-------------------------

jwiegley | 2022-10-11 16:10:35 UTC | #49

Hi Fulco, I'd definitely support this as something that can be enabled by a flag governed by the controller. The ability to publish fully public canisters fits well within the IC ethos.

-------------------------

icme | 2022-10-11 16:51:49 UTC | #50

The only issue here would be that in between each call to `canister_status`, the canister is also supposedly open to and accepting calls from additional users, which makes it significantly harder for an attacker to attribute the next cycles balance completely to the call they just made. Imagine an attacker trying to thread the needle for this type of an attack on a larger application like DSCVR.

That being said, for inactive canisters, this would be easier. You could always up the variance on the mask to +/- 10,000,000 cycles, but a determined attacker could still potentially figure this out after enough time given the cycles balance distribution between calls (as long as the canister is inactive).


In response to @ulan's point here:

[quote="ulan, post:33, topic:15775"]
a variant of option D that is limited to fully public canisters seems very useful to me. For example, if the flag that the developer would set is named something like “public_canister” or “canister_with_public_state”, then exposing the cycles balance would useful and safe.
[/quote]

If a canister's source code is completely open sourced, one additional issue I see would be if a secret or access token to private data is inserted (dynamically) into the canister and stored. Then if some equivalence check is made, this secret or any sensitive data in the canister (not in the source code) could be deduced through a [Scepter](https://en.m.wikipedia.org/wiki/Spectre_(security_vulnerability))-style cycles attack.

In this scenario, open sourcing would make it easier for the attacker to simulate various scenarios and get to the point where they know the cycles cost of all different pieces of the API, and then be able probe for the specific data they wish to extract.

-------------------------

jorgenbuilder | 2022-11-11 21:46:48 UTC | #51

Been following this thread in it's entirety and the direction seems really promising. Much appreciation for all the thoughtful contributions thus far. There are two notes that would help bring this proposal home, for me anyways. First, on timing attacks:

[quote="ulan, post:45, topic:15775, full:true"]
That’s my point about the side-channel attack: making cycles balance public is only safe for fully public canisters. If a canister [has] some secret data, then it must not make its cycles balance public (otherwise it may accidentally leak some bits of the secret data).
[/quote]

Please excuse this stab in the dark that I'm about to take--I am not up to speed on timing attacks--but I want to poke at the notion that publishing cycles balance is tantamount to publishing all internal state. I'll start with a question, which essentially question boils down to this: how much surface area does an attacker need to compromise secrets via a timing attack? Let me expand.

[quote="rossberg, post:38, topic:15775"]
The only measure that really helps is making all code paths equally costly.
[/quote]

A canister can of course inspect message callers, restricting access such that only certain principal(s) stored in internal state can call any of its methods. (There's also [message inspection](https://internetcomputer.org/docs/current/developer-docs/build/cdks/motoko-dfinity/message-inspection/), but this doesn't cover inter-canister calls.) It seems to me that a canister sufficiently "locked down" in this manner might provide the exact same timing data in response to all of an attacker's messages, since methods would uniformly route them into the same "permission denied" trap. I'd test this notion, but perhaps those of us more familiar timing attacks could disprove this for me theoretically and save me some experimentation. 😁

--

Regardless of how right/wrong that idea is, I think it's easy to conceptualize a project that might want reveal cycles balance, without throwing open the barn doors of internal state, simply because it's possible to pick the lock. The suggestion here to lump in public stable memory pages seems like a possible overstep:

[quote="ulan, post:41, topic:15775"]
if the canister sets the [public canister status] flag, then anyone would be able to read:

* the canister status,
* the Wasm source binary,
* the Wasm and stable memory pages.
* any other user-visible settings/fields of the canister.
[/quote]

I would be in favor of an implementation of the "public canister status flag" that makes risks clear, makes good things easy and bad things hard, but doesn't necessarily decide really broad swathes of your project's security/privacy strategy for you.

This flag seems to be obviously useful and to have broad support in this thread. Perhaps I've missed the mark, but coupling it with "make my stable memory pages public" would turn many people off, and perhaps is not necessary. (Sorry if I'm asking you to make the same points again and again @ulan and @rossberg 😅)

While I do think the canisterland implementation of cycles balances seems quite workable for many purposes such as topups, community monitoring, etc., it might too heavy, intrusive, etc. for some projects to take the blackhole approach. Public cycles balances behind a flag could be a more attractive option in those instances, but making your canister's entire internal state explicitly public might kill that notion altogether.

-------------------------

ulan | 2022-11-14 12:13:42 UTC | #52

Hi @jorgenbuilder. Thanks for the thoughtful comment. You're right that in some cases the canister developer can protect against the timing attacks by allow-listing the caller principals (note that it is not the perfect protection because it doesn't protect against one principal learning private data of another principal).

I was mostly worried about the developers that write code like this:

```
#[update]
async fn foo(input: String) {
   if input != secret {
      return;
   }
   // Do more work.
}
```

The attacker can easily learn `secret` by calling the method with different input strings character by character and checking the cycle balance of the canister after each call.

It is difficult to catch timing attack issues because this kind of code can be deep inside a program. The developer would need to ensure that no private data processing depends on the user input. Even if the developer does the security audit and ensures this property for the canister now, some small change in the future can introduce a timing attack vulnerability. 

In summary, if we provide a flag that makes cycles balance public, then we would have to assume that some private data of some canisters may leak. To avoid misleading the developers, we would need to name the flag appropriately, e.g. `PUBLIC_CYCLES_BALANCE_MAY_LEAK_DATA`.  The unfortunate part here is that we don't know how to avoid leaking data and cannot give guidelines on using this flag safely. So we would be giving the developers a footgun. 

If the community feels that the benefits of the flag overweigh the risks, we could try putting that up for vote.

-------------------------

sat | 2023-06-29 11:22:50 UTC | #53

It's been a while since someone posted on this topic, and it's still an open issue.
IMHO by exposing an approximate value of cycle balance (e.g. rounded up/down or with jitter added), most if not all of the security concerns should be resolved.
There are also other smart things we can do to reduce risk. But IMHO it would be enough to say in the spec that an *approximate* value of cycle balance is exposed publicly, and then give no further guarantees or limitations.
So, with this, would be ready to submit a motion proposal?

-------------------------

levi | 2023-06-30 03:37:49 UTC | #54

@sat There is no need for it. Those who want the `canister_settings` api exposed can do so with a custom method or set the [black-hole canister](https://forum.dfinity.org/t/canister-controller-and-cycle-balance-need-to-be-public/5591/16?u=levi) or similar as a controller. 

At the [CYCLES-TRANSFER-STATION](https://cycles-transfer-station.com), users own their own cycles-bank which can hold and transfer the native cycles. It is better if the cycles-balance is kept private.  

Canisters can call the new [canister_info](https://internetcomputer.org/docs/current/references/ic-interface-spec#ic-canister-info) management canister api to get on-chain the wasm module hash and canister controllers of every canister.

-------------------------

Fulco | 2023-10-12 18:49:56 UTC | #55

Hey @kpeacock, just wanted to shine a light again on this `agent-js` bug that's still hanging around. When I use this snippet

```
import { CanisterStatus, HttpAgent } from "@dfinity/agent";

const requestCanisterStatus = (canister_id) => {
  const agent = new HttpAgent({ host: `https://icp0.io` });
  //if (local) await agent.fetchRootKey();
  return CanisterStatus.request({
    canister_id,
    agent,
    paths: ["controllers", "module_hash"],
  });
};
```

It's not giving me all the controllers. The blackhole controller is missing from the list, and there’s this weird thing happening: when I remove the blackhole controller, my `dfx` identity also suddenly disappears from the controller list.  

I see ways to work around it but this could be a security issue. 

It seems that when I go to icscan.io the same false controller list shows up so somebody could pretend that a canister doesn't have any controllers by showing icscan.io as false proof.

-------------------------

kpeacock | 2023-10-12 19:22:40 UTC | #56

Thanks for calling this out! I have some work in progress on another `canister_status` topic and this is a good time for me to look into it.

@Fulco do you have a mainnet canister ID I can use while troubleshooting?

-------------------------

Fulco | 2023-10-12 19:49:35 UTC | #57

Yes will send you a dm

-------------------------

integral_wizard | 2024-03-18 21:21:17 UTC | #58

Pinging this thread as I'm also interested in having this publicly known (or at the very least opt-in). I wish for an on-chain verified leaderboard of the Open Internet dApps. :pray:

-------------------------

domwoe | 2024-03-19 14:15:57 UTC | #59

@here This topic has now been open for a while and comes up again and again. For this reason, I'd like to start a small poll to gauge the current sentiment

[poll type=multiple results=always min=1 max=2 public=true chartType=bar]
* Allow canister_status to be made public with the understanding this could expose secrets and could be extended to make all code & state of the canister public, i.e, public canister status == public canister.
* Allow canister_status to be made public with a fuzzy or low-resolution cycles balance.
* Standardize a canister/app level status/metrics endpoint that includes this information.
* Don't do anything. Black hole canister approach is good enough.
[/poll]

-------------------------

skilesare | 2024-03-19 14:51:41 UTC | #60

I voted for a public canister option. I ran across a product called seatbelt that for Evm governance is able to simulate what a governance proposal is going to do because it has access to state. Eventually this would be great to have, especially for dao canisters so that we can track what other messages a governance proposal is going to trigger. This will require being able to pull state and wasm. This would be great for public infrastructure.

-------------------------

Gekctek | 2024-03-19 15:26:53 UTC | #61

It doesn't seem unreasonable to me. I think people expect it to be due to other blockchains and I have been making my app under the assumption that it eventually will be publicly accessable

-------------------------

alexander | 2024-03-19 15:44:21 UTC | #62

I would consider the idea that it should be up to the canister owner to decide what level of openness is acceptable for their canister. It should be easily enabled and disabled. Why enforce it? Why not make it optional? Additionally, the platform should provide such an option to avoid forcing every project to come up with their own solution.

-------------------------

domwoe | 2024-03-19 15:59:29 UTC | #63

Ah, sorry if this wasn't clear, but with "Allow..." I meant this to be optional, i.e. with a flag as proposed prior in this thread.

-------------------------

erikblues | 2024-03-19 17:56:23 UTC | #64

[quote="domwoe, post:59, topic:15775"]
Standardize a canister/app level status/metrics endpoint that includes this information.
[/quote]

I like this option, standarized is best. Make it the same for all dApps.

Could this be extended into a full Canister Analytics API to replace cPanel Analytics / Google Analytics?

It could be great to have an analytics tool controlled by the ICP central NNS, it would result in the first time users can vote+control what of their data is tracked.

Does this make sense in this conversation or is this off topic?

https://x.com/fairtal3/status/1770119988491309355?s=20

-------------------------

Ajki | 2024-03-19 18:43:32 UTC | #65

I voted in favor, provided that it's optional for any canister.Why not extend such a capability when there might be a demand for it?

-------------------------

icme | 2024-04-02 20:29:30 UTC | #66

Following this poll from @domwoe, it seems as if there is universal support to provide an opt-in (optional) ability to make a canister's metric data via `canister_status` public.

From our experience building [CycleOps](https://forum.dfinity.org/t/meet-cycleops-proactive-automated-no-code-canister-management-for-the-internet-computer/20969), and as shown by the adoption of both CycleOps and CanisterGeek, developer teams generally want a readily available monitoring tool or service instead of having to build one themselves. It saves developers time in not having to reinvent the monitoring wheel, and allows them to focus their time instead on building great apps.

The ability to monitor canisters through the protocol via `canister_status` gives 3rd party applications a frictionless and smooth path for integrating monitors with developers and project teams. However, the approach of needing to verify & add a blackhole as controller to start monitoring - even with open sourced code, a [mechanism for verifying the legitimacy of the blackhole](https://github.com/CycleOperators/BalanceCheckerVerification), and social trust of other applications using the blackhole, is a point of friction for many.


I'd therefore like to suggest moving this proposal forward with some rough, but concrete ideas for how it can be implemented.

1. Provide the ability for a controller to make the `canister_status` of a specific canister id public. This can be done through a `set_canister_status_public` API on the management canister, where the controller of a canister can choose to make that canister status public or not.
``` 
type SetCanisterStatusPublicArgs = record {
  // is the canister' status currently public?
  is_public : bool;
  // if not public, this is ignored, if public defaults to Exact unless specified
  cycles_granularity : opt variant {
    Exact;
    Fuzzy;
  };
};
type SetCanisterStatusPublicResult = variant { Ok; Err : PossibleErrorVariants };
set_canister_status_public: (SetCanisterStatusPublicArgs) -> (SetCanisterStatusPublicResult);
```
2. Add the canister's `is_public` status, as well as the canister's current `cycles_granularity` to the response that comes from the current `canister_status` endpoint on the management canister. <br/>
This way, a controller of the canister can easily check to see if they've made their canister status public, and any 3rd party that calls `canister_status` on a public canister is informed that the cycles balance returned is fuzzy or exact, and can then reliably surface that information.

#### Addressing security concerns by providing the ability to surface fuzzy or exact cycles balances

Some in this thread, such as @ulan have brought up potential inference attack vulnerabilities with making a cycles balance public. This is a valid concern, where the attacker could potentially bypass an poorly secured conditional statement by probing an API with different parameters and checking the cycles balance difference in order to probe an internal variable or equivalence in a conditional statement and bypass the check or extract the value of the internal variable.

Therefore, I think it's beneficial to give the developers the option of not just making their canister status public or not, but providing the ability to choose between `Exact` or `Fuzzy` cycles granularity, with a default of `Exact` if the `canister_status` has been made public (see proposed variant above).

Ideally, a `Fuzzy` cycles balance would randomly oscillate between +/- 1000 cycles of the true cycles balance, with over time the average of all deviations approaching zero.

I'm curious if anyone has any suggestion as to the actual implementation of how the deviation is calculated, as well as figuring out what the best and most efficient form of randomness to use in the deviation calculation, so as to not slow down the `canister_status` API (i.e. maybe the management canister holds a new random value or seed each round of consensus and then transforms the exact responses of all canisters).

-------------------------

Manu | 2024-04-03 08:13:33 UTC | #67

I like that suggestion! Wrt fuzzy, wouldn't simply rounding be good enough, eg you always get an integer number of billion cycles?

-------------------------

rossberg | 2024-04-03 11:25:44 UTC | #68

As I said before, I'd be highly cautious of naive noise injection as a means for seemingly establishing security. At best it is reducing attacker bandwidth.

There is nothing more dangerous than a false sense of security, and this feature squarely sounds like luring users into that very trap.

-------------------------

skilesare | 2024-04-03 22:28:32 UTC | #69

Just curious, would this concern be relevant for OpenSourced canisters with transaction logs that allow for reconstruction of state?  Wouldn't it all pretty much be an open book at that point(I realize there are many use cases where that won't be the case...just hopeful there are some where we don't need to worry about one more attack type).

-------------------------

icme | 2024-04-04 08:08:22 UTC | #70

Yes, rounding should be good enough!

As previously mentioned, a probing attack would be the main vulnerability exposed by the `Exact` cycles balance setting for a public canister status. So if you have a canister that performs execution that is gated by an argument like a string instead of authorizing via a caller principal.

[quote="ulan, post:52, topic:15775"]
I was mostly worried about the developers that write code like this:

```
#[update]
async fn foo(input: String) {
   if input != secret {
      return;
   }
   // Do more work.
}
```
[/quote]

If on top of this, if the above code is open sourced but the secret is not, deducing the secret would be even easier picking for the attacker. 

(As an aside, the above code is an example of an already insecure API, even without public canister status. If you're guarding sensitive data or logic with code like the above, you should 100% rewrite this to use caller principal authorization)

[quote="rossberg, post:68, topic:15775"]
I’d be highly cautious of naive noise injection as a means for seemingly establishing security.
[/quote]

This is a valid concern, which is why the source of randomness and fuzzy deviation range should be taken seriously. That being said, [securely generated randomness](https://internetcomputer.org/docs/current/developer-docs/smart-contracts/advanced-features/randomness) is already one of the strengths of the Internet Computer, so I can't imagine this would be too hard for the DFINITY engineering team to take an implement. In fact, @Manu gave a [community conversation on randomness on the IC in 2021](https://www.youtube.com/watch?v=nl5BuiWClD0), so I'm sure he's well aware of how this could be implemented.

One key piece I want to bring up is that however the fuzzy randomness is integrated into a public `canister_status` API, that randomness needs to be performant (so it doesn’t slow down the `canister_status` API). This is because once made public, I expect the `canister_status` API of the management canister will get called a lot more (heavy monitoring traffic).

-------------------------

domwoe | 2024-04-08 13:43:58 UTC | #71

Given that the majority of the participants in the poll voted in favor of the first option

> Allow canister_status to be made public with the understanding this could expose secrets and could be extended to make all code & state of the canister public, i.e, public canister status == public canister.

and we might raise a false sense of security if we add rounding or noise, I'd suggest that we move forward with this proposal.

Independently, we could start working on a more flexible ICRC standard that exposes more application-level metrics, that could optionally include a less granular cycles balance.

-------------------------


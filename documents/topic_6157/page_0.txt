diegop | 2021-08-19 21:47:23 UTC | #1

**Summary**

The Internet Computer does not have an official NFT standard. It is up to the Internet Computer community to discuss and propose a preferred NFT standard.

**Status**  
Discussing

**What you can do to help**

* Ask questions
* Propose ideas

**Key people involved**

@ililic

-------------------------

Hazel | 2021-08-17 14:40:31 UTC | #2

Most likely worth sharing this here - https://github.com/DepartureLabsIC/non-fungible-token

Accepting PRs and thoughts :slight_smile:. Will add my thoughts on the above implementations limitations and strengths later.

-------------------------

diegop | 2021-08-17 20:48:40 UTC | #3

Yes, thank you @Hazel !!

-------------------------

senior.joinu | 2021-08-21 23:34:20 UTC | #4

Here we go again.

## We should switch our focus from proposing countless token standards to finding better canister integration techniques

Yes, this might look like an unreasonable statement, but I hope in this series of posts I'll be able to change your mind.

---

Hello everyone. After creating the thread https://forum.dfinity.org/t/thoughts-on-the-token-standard/4694 a couple of months ago I worked a lot on my understanding of what tokens really are and how to use this concept for a better good on the IC. Also, I did invest some of my free time to develop a couple of token implementations as well as some general architecture patterns for the IC.

Here I want to present these token implementations and also to share some thoughts about tokens and
tokenization in general.

-------------------------

senior.joinu | 2021-08-21 23:27:40 UTC | #5

### 1. Why do they need token standards on Ethereum?

I believe, there is a single reason, and it's purely technical - they can't upgrade their tokens once
deployed. Everything else is a consequence of this limitation. Once tokens are minted and have some
market value, this value is trapped inside an implementation that would never evolve.

* Programmers figured out some cool new cost optimization algorithms? The token is unable to use it.
* A new exchange is out, which uses very convenient and performant, but non-standard APIs? The token
can't be listed there.

How do you handle such a situation? Plan your APIs in advance - declare a new standard - exactly what they have to do. 
But on the IC we're blessed with canister upgrades, so our **token canister can be upgraded**, once there are new 
requirements to them, without losing its value.

While on the IC, you could simply implement new features (optimizations or integrations) on-demand, 
when your community needs it. So, there is no point in constraining token implementation with some
standard. Once a new feature is requested, you just implement it and upgrade your canister. Once a 
new DEX is out, you just integrate with it. No loses.

They can't do this on Ethereum, but we can. And we should use this advantage to focus on more important things.

> Q: But how could I keep this feature, after I blackholed the controller of my token canister?
> I can't upgrade it anymore, and this is very reasonable thing to do with a token - to let go the
> control over it.

> A: This is by design. Once blackholed, canister can't be upgraded and can't evolve, so don't blackhole
> your token, if you want it to continue evolving. Instead, you can hand over the control over it to
> its own token holders with the help of some powerful DAO (which is not implemented yet, but one day...)

-------------------------

senior.joinu | 2021-08-21 23:30:41 UTC | #6

### 2. Term "token" considered harmful

The next thing I want to talk about is how the word "token" messing with our brain interfering our understanding
of this concept.

> I'm not saying that this word should never be used again. I'm saying we should understand what's going on
> under the hood using it.

When you think about the word "token", what do you imagine? Something physical, like a coin, right? Something
you can __hand over__ to another person or lay down on a table in front of you. But this is not how
it works. In reality, when we say "I have a token" it just means that our address is listed in some
__registry__. 

Correct words build correct abstractions. And this is a very important thing for us to always remember - 
while it is considered bad and inconsistent to have many-many different tokens, each serving its purpose; it is absolutely fine to have many registries.

But why don't we call them __registries__ in that case? Because tokens have a unique feature - access control. It is only __you__ who can transfer your currency. It is only __you__ who can participate in a voting. It is only __you__ who could sell that house.

This brings us to a conclusion - it is a token __only__ when it treats its users differently (only when
it cares, what principal did make a call). And this is actually what web2.0's `authorization token` is -
just a record in a database that says "the user with this email has this set of permissions".

If you keep thinking this way, you may find yourself in a very interesting place - where every fact of
access rights checking could be expressed as a token. 

> Example. Some of you already deployed their canisters to the mainnet. If you also did, you know that you're
> now a "canister controller" - only you decide whether to upgrade or to turn off your canister. So, one
> might interpret this fact as "I have a canister controller token".
> 
> Fun fact: since you can transfer ownership of this token, you could sell it on some auction...

And this is all very interesting. I believe, this is the main reason why everyone unconsciously wants to 
make a "universal" token standard, that would fit every need. Because the core idea is so tiny and concise. But such a "universal" token would be very dumb and would provide almost no abstraction.

So, I believe, instead of that we should do the opposite - to build many different tokens tailored
to solve their exact tasks.

-------------------------

senior.joinu | 2021-08-21 23:31:41 UTC | #7

### 3. The world of great tokens
And saying the word "different" I mean it. Should we use the same token to represent both: currency and shares? Well, we could, but it would be much better to implement separate tokens for them, which may share some common functions. For example, you can mint, transfer and burn both of them, but you can only participate in votings with the shares token.

Should we use the same token standard to represent a painting and a house? Or a house and a car? Or... hell no! The only common thing between all these tokens is that they are tokens - there is some kind of access control going on. But everything else is different. You can rent a house, but you can't rent a painting the same way. You can unlock the car (letting somebody in), but it is not the same as to unlock a house's door.

> This is the problem with current NFTs, as I see it. Nobody understands what the kind of magic are they, so prices just skyrocket.

Everytime it seems like these entities have common interface it is so only if they are the same kind of entities. All the other times there are nuances which would affect the implementation.

So, I propose, we should __embrace__ it. 

You want to tokenize cars? Okay, no problem. Hire some lawyers and make a token
that would be very convenient to use in real world.

You want to tokenize voting power? Okay, study some math, politics and democracy theory and create a token that can easily handle any possible voting use-case.

Etc. Don't generalize tokens. **Specialize them instead**. Make them powerful, slick and easy to use. Incorporate beautiful custom frontends for them to make your users happy.

And another important thing - make them integrable. Integration is the thing you really want to generalize. The easier it is to integrate your canister, the better the Open Internet could be. The easier it is for us to collaborate, the more we could achieve together.

-------------------------

senior.joinu | 2021-08-21 23:28:41 UTC | #8

### 4. Currency token

I want to start from myself and present you a token, I've been working on for some time now, that (at least in
my opinion) should represent a __currency__ really well. 

https://github.com/seniorjoinu/tokens/tree/master/currency-token

Take a look at it and let me know what you think! I see this repository as a library of different tokens which you 
could clone, modify and use in your projects.

Here I'm going to tease some of its core features and new concepts.

#### Overview
```
service : (InitRequest) -> {
    "mint" : (TransferRequest) -> ();
    "transfer" : (TransferRequest) -> ();
    "burn" : (BurnRequest) -> ();
    "get_balance_of" : (GetBalanceOfRequest) -> (GetBalanceOfResponse) query;
    "get_total_supply" : () -> (GetTotalSupplyResponse) query;
    "get_info" : () -> (GetInfoResponse) query;
    "update_info" : (UpdateInfoRequest) -> (UpdateInfoResponse);

    "get_controllers" : () -> (GetControllersResponse) query;
    "update_info_controller" : (UpdateControllersRequest) -> (UpdateControllersResponse);
    "update_mint_controller" : (UpdateControllersRequest) -> (UpdateControllersResponse);

    "dequeue_recurrent_transfer_tasks" : (DequeueRecurrentTaskRequest) -> (DequeueRecurrentTaskResponse);
    "get_recurrent_transfer_tasks" : (GetRecurrentTransferTasksRequest) -> (GetRecurrentTransferTasksResponse) query;
    "dequeue_recurrent_mint_tasks" : (DequeueRecurrentTaskRequest) -> (DequeueRecurrentTaskResponse);
    "get_recurrent_mint_tasks" : () -> (GetRecurrentMintTasksResponse) query;
}
```

The main signature of this actor is based on what we've seen in almost any fungible token before. We have same `mint`,
`transfer`, `burn`, `balance_of` and `total_supply` functions and their core idea stayed the same - these are a basic
functions which any developer should find familiar themselves with.

The only difference here is that instead of separate `name`, `symbol` and `decimals` fields, we have a single field
`info` that incorporates all this data inside it. This is done for encapsulation purposes. Fewer details, more could fit 
inside.

-------------------------

senior.joinu | 2021-08-21 23:38:45 UTC | #9

#### Batches
As you might notice, all basic functions now have a single argument instead of their traditional signature. The one reason for that is the same old encapsulation, and the other is that each `update` method now supports batch requests. This means that if you need to perform multiple `transfer`s, you could to them all at once, during a single function invocation. The same goes for `mint`s. This would help with cost efficiency of this token.

`query` methods do not support batches right now, but I believe they should, since one day queries will also charge cycles, so it is reasonable to optimize them as well.

#### Granular control
Other thing you might see in the candid above is several "controller"-related methods. Yes, a canister has a controller, but what are these methods for?

A token itself has several permissions. A token could be minted - this is a permission not everyone should have. So, there is a list of principals which should. In the candid this list is referred as `mint_controllers`. Only principals from this list are able to mint this token. If the list is empty - no one could mint it anymore.

Current controllers are able to modify their controllers list. So, if you're a `mint_controller` of this token, you can also add your friend to it, so you both could mint tokens for everybody else. This is done via `update_mint_controller` function. Or you could pass an empty vec to this method, letting go the control over minting the token.

The same goes to token info - there is an `info_controllers` field also. Yes, `name`, `symbol` and `decimals` can also be changed at runtime, if there is a need for such a thing.

Why do we need such a thing? As the title says, it lets you (and potentially, your token holders) to control your token with better granularity. For example, the `info` could be controlled by some trusted person, while minting could be performed via third party canister.

> Fun fact: being in the `mint_controllers` list you could say "I have a mint controller token of this token"

-------------------------

senior.joinu | 2021-08-21 23:29:22 UTC | #10

#### Recurrent payments with ic-cron

https://github.com/seniorjoinu/ic-cron

Yes, honest authorized on-chain recurrent payments. You can set a recurrent transfer task, that would transfer funds
on your behalf, for example, each week. Just add a special argument to your `transfer` call, and you're good to go.
Tasks could be listed and unscheduled using functions at the end of mentioned candid interface. 

Recurrent mints are also supported.

#### Integration through events with ic-event-hub

https://github.com/seniorjoinu/ic-event-hub

Each time a transfer, a mint or a burn occurs, the following event is emitted to every event listener:

```rust
#[derive(Event, CandidType, Deserialize)]
pub struct TokenMoveEvent {
    #[topic]
    pub from: Option<Principal>,
    #[topic]
    pub to: Option<Principal>,
    pub qty: u64,
    pub event_payload: Payload,
}
```
which is enough to integrate this token with almost any other canister.

For example, let's imagine you're building a transaction ledger for one of these tokens. All your ledger need to do
is to listen for all of these events and to simply log them formatting the data the way you need it.

> Moreover, one could implement a ledger canister, supporting Rosetta API and ic-event-hub. Such a ledger will automatically
> work with every token, which can emit such events, automatically making them exchange-ready.

Another example: you're implementing a DEX and you want to integrate such tokens, so your users could exchange them.
All you need to do is to listen for events which have your DEX's principal in their `to` field. That way the DEX canister
can be sure, that someone sent some tokens to it, and then use `event_payload` to determine what exactly did sender wanted 
to do (sell or buy).

Events are a very convenient way to integrate canisters. They let your canister tell it's going through something to
"the world", not knowing who will receive this data. Moreover, once the `heartbeat` mechanism is ready to use, `ic-event-hub`
will be updated to use `ic-cron` (so events could be sent in batches). This will optimize "hot" integrations (with lots 
of events flying each block), making this kind of integrations not only more convenient, but also more cost-effective.

-------------------------

senior.joinu | 2021-08-21 23:40:05 UTC | #11

#### Rust client and membership token
There is also a rust canister client - a struct that wraps `ic_cdk::call` invocations into type-safe operations for ease of use from another canisters.

In a sibling directory you'll find another token implementation - a much more permissioned `membership-token`. Which could be used by organizations to, for example, reflect their employees in form of token.

#### Final overview
With all these features, I think it is fair to claim, that this currency token is the most advanced one presented to this day. And I believe we could make it much better together. 

### Key takeaways
* we don't need token standards, we need better tokens, which solve their tasks
* we don't need to generalize tokens, we need to generalize integration

-------------------------

senior.joinu | 2021-08-21 23:40:42 UTC | #12

While currency token is a fungible one, ideas from these posts fit both fungible and non-fungible tokens. Moreover, I don't actually see any significant difference (not anymore) between these two categories, so I will just let it lay here.

-------------------------

diegop | 2021-08-23 21:52:34 UTC | #13

Hey folks,

I wanted to let folks know (specially @senior.joinu who definitely put time and effort) that Igor Lilic (@ililic ) will be the person who manages this thread from the Foundation side. This project is clearly very early compared to other much more baked ones (see [Increased Canister Storage)](https://forum.dfinity.org/t/increased-canister-storage/6148/13), but I wanted to let people that I am working to get every thread spinning, engaged, and with the same clarity as the more baked ones.

In the meantime... please feel free to discuss, tell the community what you agree/disagree on from prioritization to implementaton.

-------------------------

mparikh | 2021-08-25 00:03:43 UTC | #14

Thanks, @senior.joinu , pretty in depth about tokens. Here's my understanding of your explanation in a couple of paragraphs and then rephrasing of your key question. Please let me know what you think.


A token is  described through a set of common behaviors and characteristics for a collection of things; for it to be suitable to be owned and used; according to the it's perceived value in time and space.

The richness of different tokens comes from the variety of behaviors and characteristics that makes each type of token unique.

# why ethereum wants token standards (rephrased your original question):

In certain instances of token types, it is useful to proveably "fix" certain behavior so that it can be never changed( "thou shalt not mint more than 21M tokens of this type; the last one of which will come out in 2140"). This implies that there is some expectation,  at the time of token acquisition, of some stability over what does it mean to be that token.

-------------------------

jzxchiang | 2021-09-02 22:50:06 UTC | #15

I just read a work of art.

Thank you for this story. The point about canister upgradability is salient and compelling.

-------------------------

ICVF | 2021-09-03 02:23:48 UTC | #16

My thought : 1. The ETH ecosystem has been nurtured by the availability of real-world asset based tokens such as USDT and USDC. At IC, we can have a base stable currency (already being implemented by some as wrapped cycles) that can be based on the XDR. The advantage here is that the price discovery for this is already being done by a powerful DAO - IC! 2. Another key operator in the ETH ecosystem is the Oracle, key player being Chainlink. Should the powerful DAO IC play the Oracle role for a few key real-world stables, and not just for the XDR/cycles computation? - I think this is a question worth debating over. 3. Another question which I think is worth debating over is whether there should be a registry maintained by IC itself, providing the ability to independently verify current supply (and max supply) and other primary info of a token (akin to Etherscan).

-------------------------

benny | 2021-09-05 16:09:08 UTC | #17

I'm currently drinking from a crypto firehouse (or maybe a blockchain dump truck) and trying to absorb as much as I can. I entered crypto with a casual investment interest. Since discovering IC, I'm now *engaged* with a developer interest. After listening to Dominic's interview recently on the [Epicenter poscast](https://epicenter.tv/episodes/406) I knew this was something different (good listen...their was contention/curiosity w/ the hosts trying to imply as-is blockchain technology to IC). 

I'm trying to interpret as much as I can from this thread, and the [token standard](https://forum.dfinity.org/t/thoughts-on-the-token-standard) thread, and ending up with some doubt regarding the current handful of NFTs on IC.

Consumers of these NFTs are assuming the (blockchain) implementation is comparable to Ethereum (others). Though given the below references, it seems we're a **dfx** command (malicious update, stop, delete) away (via canister owner) from validating the authenticity of what's currently in circulation. 

I'm wondering if anyone else shares these thoughts, or maybe I haven't fully appreciated the conversations/develops docs yet.


[https://forum.dfinity.org/t/how-does-the-storage-mechanism-in-dfinity-works/2733/6](https://forum.dfinity.org/t/how-does-the-storage-mechanism-in-dfinity-works/2733/6)

[quote="kpeacock, post:6, topic:2733"]
The state is stored in memory and managed through consensus. In Motoko, it’s as simple as assigning it to a stable variable. Calls simply are not transactions, and there won’t be a list of transactions for your canister unless you choose to add one for your particular use case.
[/quote]


[ Immutability (Read-Only Code)](https://forum.dfinity.org/t/thoughts-on-the-token-standard/4694/65)
[quote="ililic, post:65, topic:4694"]
Due to canisters having an ability to be upgraded over time, there exists a possibility that the API of a canister as well as its underlying implementation may change at any time. This is different from other blockchain environments where contracts are immutable upon deployment and upgrade paths require re-deployment and migration of state.

As a result, there exists the potential for malicious token implementers to deploy a canister that seems benign at first but then upgrade the canister at some later date to some implementation that is not to the end users’ expectations, or which manages to steal funds or do other harm to consumers of the canister.
[/quote]

[https://sdk.dfinity.org/docs/developers-guide/working-with-canisters.html](https://sdk.dfinity.org/docs/developers-guide/working-with-canisters.html)
[quote]
If you want to permanently delete a specific canister or all canisters for a specific project on a given Internet Computer network, you can do so by running the dfx canister delete command.

Deleting a canister removes the canister identifier, code, and state from the Internet Computer network. 
[/quote]

-------------------------

kpeacock | 2021-09-06 04:09:39 UTC | #18

You can remove all the controllers from a canister, so the API can no longer be changed. Soon we will have a setup so you can have a dao-like group serve as a controller, to allow for decentalized approval of updates.

-------------------------

jzxchiang | 2021-09-06 07:19:07 UTC | #19

These are actually great points.

I wish more details were made available about the IC price oracle.

-------------------------

jonit | 2021-09-07 17:13:43 UTC | #20

In order to protect artists from copyright theft and people minting works they don't own, is there a way to either guarantee correct copyright within an NFT token on IC? Or can we have something like the tick on twitter, when we know that an NFT is defiantly from a certified artist?

-------------------------

jonit | 2021-09-07 17:18:01 UTC | #21

A certified NFT could potentially be more valuable than a non-certified

-------------------------

benny | 2021-09-08 12:31:28 UTC | #22

That's great to know, and possibly an alternative to the Black Hole previously mentioned. Will stay tuned for the DAO'ish functionality.

I think the main thought I would like to continue, is the community could benefit from having an approach for retrofitting current/new NFT implementations as standards are adopted. 


[Immutability (Read-Only Code)](https://forum.dfinity.org/t/thoughts-on-the-token-standard/4694/65#immutability-read-only-code-9)

[quote="ililic, post:65, topic:4694"]
Alternatively, token contracts may adopt using tools like [Black Hole ](https://github.com/ninegua/ic-blackhole) in order to make the canister public and immutable.
[/quote]



On a related note (and more valuable to discuss outside of this thread), I have an unwarranted sense of urgency to know if existing NFT implementations are immutable, recording transactions, and making those transactions (ICP & token exchanges) available through some easily accessible medium other than traversing ic.rocks. 

It seems to be a hot topic on the socials, and it would be unfortunate for people to blindly buy into a speculative trend and have an unintentional (canister) update wipe out existing data, leaving people with the inability to prove their stake of ownership in this slice of internet culture...let alone recoup any ICP.

-------------------------

LevenSton | 2021-09-09 06:04:52 UTC | #24

I think nft on dfinity is different from Ethereum, nft on dfnity can be an independent canister that has own specific combination of functions,  
https://github.com/C3-Office/standards
it's the first draft NFT standards written by our team, and we will launch an NFT on dfinity according to this standard soon, 
welcome comment and submit PRs

-------------------------

dpdp | 2021-09-09 18:21:43 UTC | #25

I think the `approve` function must allow the user to specify a `memo` (which could be a `Nat64`) rationale behind that is with Internet Identity, the `Principal` that owns an NFT in `Platform A`, will have a different `Principal` in `Platform B`; So the `Platform B` will need to creates an unique `UserId` which would serve as `Memo`;


> As the owner `Principal` of `NFT id X`, I approve `Platform B` Canister to make any transfer on my behalf with a reference to the account `UserId`.

-------------------------

lastmjs | 2021-09-10 19:27:31 UTC | #26

The NNS can always change a canister though, correct?

-------------------------

jonit | 2021-09-12 12:23:21 UTC | #27

Can an NFT be modified by an action in such a way that the NFT gets rewritten? 
For example if owning a particular NFT gave you access to a reward, you'd only want that reward to be claimed once. A new owner of the NFT would need to know the reward is already claimed.

-------------------------

benny | 2021-09-12 22:54:37 UTC | #28

I'll preface this with stating that I'm still learning about NFTs, but willing to share some thoughts. I'm on the fence on some of them though.

This is a great question, and has led to some great internal deliberation, summarized by this fictitious conversation:
>A:  On this reward NFT we're working on, can the reward (w/ a unique ID) represent the same metadata while still being non-fungible?

>B : Yes, because each reward has a unique id. 

>A:  But what if the reward's metadata represent the same number of games points? For example, reward 1 and reward 2 could both be for a reward of 25 points.

>B: I see your point. So does that mean they're fungible, since we could swap them with each other, and still receive the same number of game points?

>A: Hmm...

>B: Hmm...

>A: How about we separate concerns, and have two NFTs; one representing *access to a reward* and one representing the *reward*. The 1st one will contain an ID for a *reward* NFT (and will be immutable) and the 2nd will contain the number of free game points & claim status. That way, if we swap our *access* NFTs, they're still unique because they're pointing to different reward NFT IDs.

>B: Sure, I guess, but I think you're moving the problem further downstream. The NFTs we swapped are unique/immutable, but the point values could still be the same in the *reward* NFTs!

>A: You're right! Maybe we don't get caught up in trying to call them NFTs and just make sure we're fully transparent to our users how the reward process works. 

>B: Good plan! I'll make sure our source code is visible and that all transactions are captured/visible and the necessary APIs are available to see who currently owns each reward (and claim status). I know that the IC blockchain is ensuring the calls to our canisters are fully legit, but it's up to us to make sure we're fully transparent about what our dapp does. Just because we're hosting a dapp on IC that allows people to swap unique things, doesn't automatically make it an NFT.

>A: Next time, let's make the game rewards unique, that way there's no question about their non-fungibility. 

I think it all depends on the expectations of the consumers of your dapp/(N)FT. The expectations can be established by somehow proving that your code (1) will do what it says it will do, (2) permanently captures all events (as a result of function calls), and (3) has a way for anyone to view those events.

1. This can be accomplished by sharing the source code for your NFT and have some (yet to be developed) verification process to ensure its credible.
2. The IC blockchain provides the means to do so (as long as the container hosting the NFT's code is somehow made immutable). However, as stated in other posts, IC does not inherently have a mechanism where all transactions are automatically captured in a way for public consumption. 
3. You would need to develop this functionality or rely on an (yet to be developed) app that can interrogate your NFT for the necessary data.  

I've seen services on other blockchains permit (only) the URI to change after the token is minted. The URI could point to a JSON file containing metadata on a centralized server. This could lead to the same situation though. Two JSON objects could potentially contain the same data over time. 

From my current understanding of NFTs, irregardless of blockchain, is that the consumer (at a minimum) expects the NFT to be unique. Someone a bit more in tune with the technology, will want reassurance the data cannot be *funged* with after the fact and that there's a full transaction history from genesis until now. 

In your situation, if every reward is unique, then I would say that it is okay for the *claim status* to change. I would want to be reassured though, that after the reward is claimed, it cannot be claimed again. If the rewards could represent that same value (ex: 10 game points), then I feel they fall more into the category of fungible tokens. 

An alternative approach, is to avoid putting a token label on it, and just call it a reward.

-------------------------

jonit | 2021-09-13 15:07:30 UTC | #29

thanks for the considered reply! Yes I guess altering an NFT makes it fungible. 
Maybe something simple like a rewards data base could work.It tells you if certain awards due to that NFT have been claimed, and if you input your NFT details it tells you what rewards you can or can't claim with it.

-------------------------

benny | 2021-09-13 16:22:46 UTC | #30

Possibly.

Altering an NFT makes it mutable. Being able to interchange a token with another makes it fungible.

Picture walking into an art gallery where there are 3 original paintings by an artist. Alongside that there are 20 prints of one of the paintings (ie: printed copies of the original).

The art gallery announces that the first 23 customers will get a ticket to receive either an original painting or a print. The tickets are labeled respectively, one with the word "painting 1", "painting 2", "painting 3", and 20 others with the word "print".

The 20 people with the tickets labeled "print" could swap these with each other all day long, and still only receive a print. I would consider these to be fungible.

The 3 individuals who received the tickets labeled "painting #" would end up with a different painting if they swapped. I would consider these to be non-fungible.

-------------------------

jonit | 2021-09-13 17:22:38 UTC | #31

thanks for the clarification on the terms, makes perfect sense

-------------------------

skilesare | 2021-09-13 18:12:10 UTC | #32

Here are some of my thoughts

https://twitter.com/VitalikButerin/status/1433235640175382528

I’m going to say some things that I know will run into the brick wall of prevailing thought/memes/culture, but I’m going to say them anyway because I think they are right.

NFTs suck right now.  And I say this as someone fairly deep into the NFT realm.

I’ve commented in the past that “tokens” are just data in a database.  ERC20 tokens are data in a crypto secure database, but they are still just data.  They are a useful abstraction because the world caught on to them made the abstraction useful.  A lot of times what someone means when they say they want a token, or that they want to tokenize something, what they really mean is that they want to put data in a crypto-secure database.  They don’t know that that is what they want to do...they think they want a token...but ultimately that is what they want to do.  

Generally an ERC-20 or Fungible token is a crypto-secure entry in a uniform table with one variable, “the balance”, in the table roughly analogous to the magnitude of shares out of the total supply that that record represents and one variable containing ownership info.  When these tables are smart contracts, some of these variables(but generally not the balance) can be functions that depend on inputs and other state in the table.

NFTs are currently undergoing the same abstraction mess. Since the world has grabbed ahold of the abstraction, everyone wants everything to be an NFT.  But everything isn’t an NFT....or maybe everything is an NFT and thus the label becomes worthless.

If we look at the original ERC 721 spec we see a pretty definite definition of what an NFT is:
https://eips.ethereum.org/EIPS/eip-721


```
“NFT” Word Choice

“NFT” was satisfactory to nearly everyone surveyed and is widely applicable to a broad universe of distinguishable digital assets. We recognize that “deed” is very descriptive for certain applications of this standard (notably, physical property).

Alternatives considered: distinguishable asset, title, token, asset, equity, ticket
```

The keyword here is “distinguishable”.  This implies a degree of, or perhaps an absolute amount of uniqueness.  In our uniform tables, each entry had a unique ownership field. In theory, each entry in an ERC20 table is an “NFT”.  You will have a rough time transferring your account because usually the ownership is tied to a private key that you wouldn’t want to share with anyone and that they wouldn’t trust you transferring to them.  So instead you swap the balance.  NFT really did 2 things.  

The first was to say that a thing is going to own itself.  Its physical(or rather digital) properties will determine what is in the ownership column. If two things have the same properties then they are the same thing...they are indistinguishable.

The second was to add an ownership squared, ownership of ownership, or meta ownership filed to the scheme. 

You could also just say that they added a uniqueness column to the table, but I think the transformation and idea of a thing owning itself...having its own sovereignty...is really instructive.  It is how crypto addresses work as well.  Crypto addresses are able to have sovereignty over themselves and the things the world ascribes to them because of cool math.  NFTs have sovereignty over themselves and have the properties that the world ascribes to them because their properties are observable and identifiable.

Classically(as in the last what...5 years), the properties NFTs have dealt with have been media files.  These have their own set of challenges when it comes to distinguishability, but let’s wait to talk about those.  Let’s consider a perfect world where everyone acts in good faith and each possible image is attributable to a creator.  This is great and NFTs now give us an amazing mechanism for our creators to own, sell, and trade their work.  Based on the digital properties of your media file(the order of the ones and zeros plus the decoder you use to translate those into physical properties - how it appears on screen, how it sounds) you can distinguish each image from another.

Now NFTs have always had a bit of a problem when it comes to the manifestation of these digital properties into physical properties.  Change the pixel color of one pixel by one integer and the thing is now vastly different by digital measurement tools but indistinguishable by the human eye.  “There is nothing either good or bad, but thinking makes it so.” sha256 is ba118b93ee1ad0694e79571d4c902d0bf0ea993db6838f20263d35591fd4afe4 and “There is nothing either good or bad, but thinking makes it so” is 90c9df0d556ab1dc558c98fe3566ba473c5c8418e748b28fd70ab594d4137e43.  But are they really unique?  Should Not-Shakespeare J. Simpson be able to remove a period and claim new ownership? Or did a pen drip?

What if I take Punk 4743 and convert it from 24x24 to 48x48. Again, a simple sha256 gives me much different identities even though they should be indistinguishable.  Now if I compress the 24x24 and 48x48 I should get these same digital signatures provided I know what form of media I am using and that my upsampler didn’t so something magical in the process.  So maybe that is interesting.  Does distinguishability have components?

Problem 1: Compressibility.

This is all a much bigger problem with Ethereum than it should be with the IC if we approach it the right way. On the IC we should be able to have the digital bits live alongside our ownership records.  But there is still nothing keeping two canisters claiming the same image is unique.  To do that you need governance of some kind that ascribes and proves ownership, perhaps in an ongoing way.  Probably within a reasonable time frame for decision-making.

Problem 2: Uniqueness

I’ve also heard of people talking about NFTs that change.  I think this just nullifies the ability for us to even have a discussion about this.  Unless the changes are deterministic based on a seed and unless the current state is within a computable space for all reasonable times t, I don’t think we can consider something to be distinguishable.  We can loop back to crypto addresses here and even use the crypto that the IC uses as an example. Key shares are roughly infinite on the IC and they move forward in time so that old keys can be invalidated.  So they change and change almost infinitely, but in a way that is deterministic such that you can trace them back to the root key.  If you are making a morphing NFT that can’t be traced back to its seed in a programmatic manner(probably within the calculation scope of what the IC can do) then you probably aren’t making a distinguishable item(an NFT).

Problem: 3 Determanism

All of this is not to say that you can’t have other fields in your distinguishable and crypto secure row that do all kinds of non-deterministic, cool, repeatable, behavior.  Again we call these smart contracts for a reason and we want to do all kinds of as-of-yet unforeseen things with them.  But, if we’re going to come up with a standard around NFTs we can’t throw in the whole kitchen sink of “what I want an NFT to be today”.

This is not an exhaustive list, but I’d propose we have to answer these questions as we discuss the standard:

1. How do I prove my uniqueness to the world?
     a. How do I compress my digital properties in a consistent manner?
     b. Who is enforcing this methodology?
2. What parts of me are deterministic enough to be considered part of the NFT?

A couple of initial thoughts:

1a and 1b. An NFT should describe their compressibility and enforcement methodology themselves so that they can declare their own provability.  For images and sound, this should be easy.  We publish a blackholed canister that takes in a file, does a standard bit of compression and performs a statistical analysis of the remaining bits in context and produces some kind of signature that will be unique for all appropriately distinguishable media files.  I have a suspicion this is some of what Orygin is working on.  This interface could be generalized to a registry as well so that we end up with a kind of copyright dao registry where media goes in and it get registered and awarded if it passes the uniqueness checks.  This might get complicated when it comes to composability.  We should talk more about that.  If I combine two images by puting one next to the other, Have I created enough of a thing for it to get awarded uniqueness?  Or should it be derivative of the components?  Can we detect that?

2. We just need to get honest with ourselves on this one and stop calling everything an NFT.  Smart contracts are smart contracts.  Some are NFTs, but not all of them.  If you are going to funge your NFT in the future in an indeterministic way then you probably aren’t making an NFT.  Could it be a valuable, cool, smart object that people want to pay a bunch of money for?  Sure! We just have to draw the boundaries somewhere for our standard that won’t fit inside the tent.  Does this move a lot of game-oriented objects outside the boundaries? Yes, it does.  But there is probably an equally memetic name for those that we can come up with that will catch fire as well.

Other random thought after reviewing the departure labs most recent NFT spec:  I think it might be helpful to move all the http stuff out of the “standard”.  I think the http wrapper should be its own thing.  It makes sense to publish them together, but ideally, the standard should be modularized into the pieces that are necessary to reason about the NFT and those that are not.

Generally, I think we shold all start to think in terms of “interfaces” instead of “standards”.  An NFT “standard” could be made up of the following “interfaces” : com_token_ownable, com_token_transferable, com_token_approvable, com_nft_royalty, com_nft_unique_provability, com_notify_subscribable, etc

...not a complete set of thoughts...but what I had on my mind this past weekend.

-------------------------

xiaozhu | 2021-09-14 04:21:38 UTC | #33

If everything needs to be on the chain in the future, then the copyright of the image is reasonable as an artwork NFT, but what is the standard of the NFT and what value will the NFT leave to people after the hype?
I think it may be a set of standards, a set of standards that can be used for the Internet of Everything in the future.

-------------------------

xiaozhu | 2021-09-14 04:25:51 UTC | #34

But just like the NFT that attracted attention because the giants entered the market, the standard voice of NFT may also be in their hands, but our decentralized blockchain feels like a people’s revolution. Maybe this time it will be different. .

-------------------------

benny | 2021-09-14 11:02:56 UTC | #35

This is awesome!

The part I have time to comment on at the moment is this:

[quote="skilesare, post:32, topic:6157"]
Generally, I think we shold all start to think in terms of “interfaces” instead of “standards”.
[/quote]

I think the topic of retention has an opportunity to be addressed. Would you recommend this be up to the implementor instead of this "standard" , or maybe it warrants its own standard that can be adopted in addition to an NFT interface?

For example, a controller might delete a canister or decide not to top up their cycles. This is a unique problem space to IC that I've been contemplating.

Thanks!

Edit:
I do like the term "standard". It's a way to communicate direction and intent. The interfaces, part of the standard, provide ways to adhere to the direction.

-------------------------

skilesare | 2021-09-14 16:19:23 UTC | #36

[quote="benny, post:35, topic:6157"]
I do like the term “standard”. It’s a way to communicate direction and intent. The interfaces, part of the standard, provide ways to adhere to the direction.
[/quote]

The issue I have with "standard" is that implies both interface and behavior as well as complete description.  We very rarely have "complete description" in the smart contract world because the devil is in the implementation.

Example:  An early draft of an ICP20 token had a seemingly innocent line in it that specified that the balance of the two accounts involved in a transfer should always add up to the original balance.  Make sense right? Except that it rules out any number of valid token contracts that have a carrying cost or tax built into them to sustain the underlying system.  A catallax token has a carrying cost that is taken out on each transaction and dumped to a UBI pool that flows backward through the ledger.  Should the standard be so descriptive that it rules out those kinds of applications?

I think we really just need to focus on the signature of how canisters talk to each other and avoid specifying implementation.  Support systems pop up that implement these interfaces and we end up getting interactions with a wide range of tools "for free."  A token can implement a wide range of very specific or very general behaviors.  Most of the general behaviors fall into a nice set of logical groupings.

-------------------------

goose | 2021-09-15 08:34:21 UTC | #37

The copyright fee of the creator should be taken into account

-------------------------

nithivandhana | 2021-09-21 13:16:29 UTC | #38

Thank you @senior.joinu

The Key Difference between these fungible and non-fungible tokens is, Fungible is entirely exchangeable with each other one. And, Non-Fungible Token is completely the opposite of fungible token. its un-exchangeable and Unique.

-------------------------

goose | 2021-09-27 09:06:55 UTC | #39

https://github.com/Ceto-Labs/non-fungible-token, Explore the implementation of erc1155 on dfinity

-------------------------

Odacchi | 2021-10-18 05:18:28 UTC | #41

> Generally, I think we shold all start to think in terms of “interfaces” instead of “standards”. An NFT “standard” could be made up of the following “interfaces” : com_token_ownable, com_token_transferable, com_token_approvable, com_nft_royalty, com_nft_unique_provability, com_notify_subscribable, etc

That's right.
Extensibility is important, but a minimum interface standard is required. A world with different fingerprints of methods to get names and properties for each NFT collection is too barren.

Imagine, for example, creating an NFT marketplace. How do you create a marketplace if each NFT interface is different?
In particular, It is speculated that the marketplace on IC, Entrepot, is facing this challenge.

-------------------------

skilesare | 2021-10-18 12:59:41 UTC | #42

Yes.....not sure how many standards there are, but I know there are already some name collisions like transfer() in ext and departure labs being different.  Might be worth calling a summit to iron out those differences before we get too far along.

-------------------------

Sherlocked | 2021-10-18 14:52:39 UTC | #43

DAB (https://dab.ooo) solves the multiple NFT interface issue. DAB wraps each standard to allow for one common interface.

-------------------------

LightningLad91 | 2021-10-18 17:18:26 UTC | #44

I thought DAB was intended to be temporary solution?

-------------------------

MCLYang | 2021-10-19 04:24:02 UTC | #45

Hey, administrator might pin the featured git repositories? Appreciate very much.

-------------------------

Jupes_M | 2021-10-21 23:23:14 UTC | #46

[quote="senior.joinu, post:4, topic:6157"]
We should switch our focus from proposing countless token standards to finding better canister integration techniques
[/quote]

imo, Token standards were created so that the blockchain would have something on it, besides its native coin, for people to spend their money on. Creating something exciting/hyped for people to FOMO into has been around since before I got into(jan '14) Crypto. The current 'cutting-edge' of standards for NFTs is the addition of an attributes field and the creation of optional royalties. 
If ERCs were very mature standards, I'd see value in emulating them. But, as senior.joinu has done a great job of pointing out, Eth and ICP diverge almost right after the word 'Token'. For instance, what if I want to create a dns system in which, depending on the NFT owned, will shape the response given? ICP lends itself well to this, but Ethereum does not.

-------------------------

skilesare | 2021-10-22 01:53:53 UTC | #47

Hey @rossberg, @claudio, etc....what chance is there of function overloading on the IC/Motoko.  Right now we have a collision on transfer for Departure Labs and EXT. It sure would be nice if we could have overloading and support both based on the candid type that comes in.  If not overloading, then some kind of way to pre parse a candid input and transform it?  Just a thought...it would solve a good bit of stressing about standards.

-------------------------

rossberg | 2021-10-22 07:27:21 UTC | #48

You mean overloading for canister methods? I don't think that can work. The IC can only distinguish by name, so it would have to become a single method from the IC/Candid perspective that does something different based on the argument type. Pretending these are two methods inside Motoko would be a leaky abstraction at best, since it could not really separate them (consider function references). It would also be super-hairy and likely impossible to reconcile with Candid's interface evolution subtyping.

I'm not sure I follow how a method name clash can even happen in Motoko, given that there has to be a single place where an actor and its methods are defined. Can you elaborate?

-------------------------

claudio | 2021-10-22 13:25:26 UTC | #49

My guess is that you are using a single actor to implement two separate interfaces that happen to have two methods with a common name but different signature?

-------------------------

rossberg | 2021-10-22 14:06:13 UTC | #50

In that case, overloading wouldn't be a general solution either, even ignoring everything else, because the clashing methods may happen to have similar types.

I'd suggest that actor interfaces defined to be implemented by _other_ actors should take care of properly namespacing method names, e.g., by some "owner" prefix. We might want to think about establishing some conventions for that.

-------------------------

skilesare | 2021-10-22 16:10:54 UTC | #51

> My guess is that you are using a single actor to implement two separate interfaces that happen to have two methods with a common name but different signature?

Exactly.  Departure Labs has transfer(to : Principal, id : Text) and EXT has transfer: shared (request : TransferRequest) -> async TransferResponse; where TransferRequest and Response are


```
public type TransferRequest = {
    from : User;
    to : User;
    token : TokenIdentifier;
    amount : Balance;
    memo : Memo;
    notify : Bool;
    subaccount : ?SubAccount;
  };
  public type TransferResponse = Result.Result<Balance, {
    #Unauthorized: AccountIdentifier;
    #InsufficientBalance;
    #Rejected; //Rejected by canister
    #InvalidToken: TokenIdentifier;
    #CannotNotify: AccountIdentifier;
    #Other : Text;
  }>;
```
So if I want to write an NFT canister to support both, I currently can't.  I'd love for the community to come to some resolution and extensibility with prefix/post fix would be a great solution.

If every interface in the IC was namespace it would fix a lot. It would also be kind of ugly.

transfer_com_ext and transfer_com_departure

That is going to look pretty ugly inline in code.

Another option is to get everyone to agree to always use one interface function that takes a standard variant type:


```
public shared(msg) _interface(command: VariantType) : async Result<VariantType, Text> {
     switch(Command){
          case(#Class(val)){
               let command = VariantHelper.findProperty("command");
               switch(command){
                    case(null){return #err("command required")};
                    case(?command){
                        if(command == "transfer"){
                            let namespace = VariantHelper.findProperty("namespace");
                            switch(namespace){
                                case(null){
                                      //default;
                                      let result = transfer_ext(VarientHelper.unwrap(VariantHelper.findProperty("paramaters", EXTTypeDefHelper));
                                      return VarientHelper.wrap(result,EXTTypeDefHelper);
                                 };
                                case(?namespace){
                        if(namespace == "com_ext_nonfungible"){
                                let result = transfer_ext(VarientHelper.unwrap(VariantHelper.findProperty("paramaters", EXTTypeDefHelper));
                                      return VarientHelper.wrap(result,EXTTypeDefHelper);
                        } else if(namespace == "com_departure_nonfungible"){
                               let result = transfer_ext(VarientHelper.unwrap(VariantHelper.findProperty("paramaters", DepartureTypeDefHelper));
                                      return VarientHelper.wrap(result,DepartureTypeDefHelper);
                        };
                    };
               };
                        }; //else other commands
                    };
               };
          };
    };
};
```

To me, the above seems extraordinarily clumsy.

Could candid have a namespace that is applied behind the scenes so the code stays clean but behind the scenes the namespaces are appened to function?

Something like:

type DepartureNFT = actor{
    transfer: (Principal, Text) -> Bool;
} : com_departure_nft;

type EXTNFT = actor{
    transfer: (Principal, Text) -> Bool;
} :: com_ext_nft;

and then in motoko actor:

public shared(msg) transfer::com_departure_nft(Principal, Text) : Bool {//code};
public shared(msg) transfer::com_ext_nft(TransferRequest) : TransferResponse {//code};

Behind the scenes, both Motoko and candid are appending or pretending the namespaces to the function calls?  Maybe that is not much better and I'm not a language designer.

> In that case, overloading wouldn’t be a general solution either, even ignoring everything else, because the clashing methods may happen to have similar types.

In that instance, wouldn't you be doing the same thing anyway.  I guess if one had a publish(Text) that was supposed to send an event and one had a publish(Text) that was supposed to post a blog post you might have that issue.  But in the context of a token, two standards *probably* mean the same thing by transfer.  Maybe not....in any case if you need the context of what 'kind' of call intention you had....maybe some kind of automagical namespacing...would help?

-------------------------

Hazel | 2021-10-23 15:13:49 UTC | #52

[quote="skilesare, post:51, topic:6157"]
Exactly. Departure Labs has transfer(to : Principal, id : Text)
[/quote]

What areas of overlap would give you the biggest uplift? Likely 
 can accommodate.

-------------------------

skilesare | 2021-10-23 15:53:18 UTC | #53

I think ext and departure labs should put their heads together and come up with a standard....invite others....maybe the standard should go beyond just tokens...that fixes this glitch. We need a design pattern we can push and teach to new devs. Would be good to do it while we have 20 NFT projects, before we have 200, and before the first person blackholes their canister and can't upgrade.

-------------------------

bytesun | 2021-10-25 04:12:45 UTC | #54

I always have a liability concern about canister as smart contract engine.  Maybe I am wrong. as my understand canister's controller can always make change of actor and canister need cycles to keep it live. 
On the contrary, smart contract on Ethereum can not be changed and offline ever.  If it's true, maybe consider some technical methods to avoid it as NFT standard.

-------------------------

rossberg | 2021-10-25 10:43:02 UTC | #55

[quote="skilesare, post:51, topic:6157"]
If every interface in the IC was namespace it would fix a lot. It would also be kind of ugly.

transfer_com_ext and transfer_com_departure
[/quote]

Yeah, but you only need it for interfaces that others are supposed to match. I'd use a prefix convention that is simple enough:
```
ext__transfer    departure__transfer
```
[quote]
That is going to look pretty ugly inline in code.

[...]

Could candid have a namespace that is applied behind the scenes so the code stays clean but behind the scenes the namespaces are appened to function?
[/quote]

Theoretically, yes, but would writing `a::f` in actual code be any less ugly than `a_f`? And it'd be introducing quite a bit of extra machinery for it for all parties involved (Candid, Motoko, all other language bindings).

[quote]
In that instance, wouldn’t you be doing the same thing anyway.
[/quote]

I wouldn't necessarily assume that. More importantly, we shouldn't be satisfied with a solution that would be limited to the specific needs of tokens.

I have seen horribly overengineered solutions to the namespacing problem. Ultimately, they just push the need for agreeing on a good naming convention elsewhere.

-------------------------

tnpxu | 2021-10-25 12:56:45 UTC | #56

NFT ledger canister must then be deployed on the System Subnet ( like ICP ledger canister on system subnet)

-------------------------

bytesun | 2021-11-13 17:56:03 UTC | #57

some transaction fees should go to the ledger to keep the canister live

-------------------------

cnr | 2021-12-06 21:36:06 UTC | #58

I like this line of thought. 

There's an alternative to this approach to solving compressibility, determinism, and uniqueness, which comes from embracing the idea that all tokens are non-fungible. 

I have perhaps a very long post to write about semi-fungibility, but it's summary is, "most tokens are neither fungible nor non-fungbile, they instead occupy a point on the spectrum of fungibility." 

For example, USD is perfectly fungible until you need to deposit more than 10k into a bank at one time. At that point its effective fungibility is limited because the U.S. government wants to prevent money laundering and terrorist financing. 

On the other hand, even perfectly distinguishable items can have fungible properties. E.g. [the famous rai stones on the island of Yap.](https://www.sciencealert.com/the-original-bitcoin-still-exists-as-giant-stone-money-on-a-tiny-pacific-island) These stones were so large they couldn't be physically transferred to one another. Ownership was instead tracked through community consensus. 

In other words, I think the emphasis on fungibility is overstated. Instead, what's interesting is the degree of fungibility and the price inference mechanisms to make fungibility possible. 

My claim is that everything becomes perfectly fungible, including NFTs, as long as you have a sufficiently subscribed price inference mechanism. I think this is non-controversial, but it doesn't seem like what it offers has been metabolized.

To give a quick example: let's say there's an NFT generating canister that outputs an image with 4 pixels that are each 1 of 4 colors. The probability of a red pixel is 4/10, of a blue is 3/10, of a yellow is 2/10, and a green is 1/10. An NFT image with all green pixels would have low, 0.01%, probability of occurring, it's the least probable image. Let's say an all green NFT is generated. Will it be highly desired or not? 

Right now, the default price inference mechanism that we reach for is scarcity. The rarer the item, the more highly we value it. But what if instead the market had a strange preference for the color blue (as it should, blue is better. **HODL BLEU** becomes the mantra.) A completely blue image wouldn't be all that uncommon, still quite rare, but not as rare as the all green. However, the preference for blue would still drive up the overall price. Maybe this is what Vitalik means about memes: if each person believes that every other person values blue above all else, then blue would have more value. The value is driven (in part) by the expected fungibility of the asset once you own it. Fungibility is about subscribing to a price inference mechanism.

So, memes are a mechanism to drive prices. As people subscribe to memes, the assets that represent those memes can take on value. I know this is basic, but it seems like lots of people prefer to think about NFTs and fungible tokens as if they're different things. In reality, fungible tokens are just a class of nfts, backed by some set of memes that make price inference easy. 

E.g. a government that says your dollar can be exchanged for a new one, no matter how tattered your dollar may be, has introduced a mechanism that makes price inference easy. 

Notice that one way to make an NFT more accepted as a currency is to make more of them. You can either collateralize an asset with tokens, or have many similar assets, each with one token. The reason a singular and unique nft performs worse than Bored Apes is because Bored Apes is actually a fungible token. You know that others know how to value it. This is also why Bored Apes would be less successful if it were perfectly random, perfect randomness defies parsimonious valuation. 

My bet is that if more people bought this idea we'd have tokens that do more interesting things. In the next post, this claim will also allows us to unify nfts and fts into a single implementation.

See [this post](https://forum.dfinity.org/t/non-fungible-token-nft-standard-community-consideration/6157/62?u=cnr) for another example of a non-fungible, yet still "fungible" token.

-------------------------

cnr | 2021-12-07 18:10:49 UTC | #59

On the internet computer, given that storage is quite cheap, we can have many effectively-fungible, still technically non-fungible tokens. These kinds of token will each have different data associated with them (non-fungible), but they'll still be easily compared (fungible).

Our question is: is it possible to make a fungible token standard that inherits from the non-fungible one?

A 'fungible' NFT (which I'll hereon just call "nft") would basically work like this:

1. On mint, Alice receives an nft whose data is just a number "balance" that represents the starting tokens in circulation
2. On `send`, Alice intends to send `x` tokens to Bob. Alice's nft burns `x` tokens in order to create a new nft with a starting balance of `x`, then Alice's nft transfers ownership *of the new nft* to Bob.

What's cool about this approach is that these are atomic operations. We can use that attribute to solve the [DEX problems](https://forum.dfinity.org/t/thoughts-on-the-token-standard/4694/111?u=cnr) that the token standard conversation is talking about.

To do so, introduce 2 new functions and a new rule:

**New "share" function**: To share an nft let's create a function `share(quantity, target)`. When called it creates a new nft that mints the desired quantity of tokens, and shares ownership of this new nft with the target address (after share, the token is co-owned by both the original nft owner and the target address). Unlike `send` it doesn't burn tokens before minting, you'll see why next. 

**New transaction rule that the nft respects**: If the nft has more than one owner (it is shared) it cannot call the `send` method. It can only `share` and `revoke` ownership. This makes it so that nfts with multiple owners are valueless, at least until revoke is called.

**New "revoke" function**: To revoke ownership of an nft (which you'll want to do so that the address you shared it with can spend it), let's create the function `revoke()`. In order to revoke ownership, the calling nft must burn the amount of tokens specified as the starting quantity when `share(quantity, target)` was called.

How about an example?

Let's say Alice has an nft called Token A with a starting balance of 500, she wants to use a decentralized exchange (DEX) to swap 200 Token As for Token B. Here's what happens:

1. Alice calls the method `share(200, DEX)` on the Token A nft that she holds. This prompts Token A to create a new Token A nft that mints 200 new tokens, let's call it Token A_1.  Alice's Token A still has 500 tokens, and Token A_1 has 200. However, Token A_1 is now co-owned with the DEX canister and  therefore *valueless* because it can't be spent, so the total quantity of tokens in circulation is equivalent to before calling `share`. 
2. The DEX canister calculates the number of tokens to request of Token B, let's call this value `q` where `q = exchange rate * 200`
3. The DEX canister now requests that Token B also shares its tokens with DEX. Token B calls `share(q, DEX)`, following the same process as Token A: split the nft token, share ownership of the newly created nft which we'll call Token B_1.
4. DEX now shares ownership of Token B_1 with Token A, and shares Token A_1 with Token B. The swap has happened, but at this point, Tokens A_1 and B_1 are still valueless since they have more than one owner. (in fact, they each have 3 owners: DEX, Token A, and Token B)
5. Upon receipt of Token B_1, Alice's Token A revokes ownership of Token A_1, burning 200 tokens to do so.
6. Upon receipt of Token A_1, Token B revokes ownership of Token B_1, burning `q` tokens to do so.
7. DEX still co-owns both nfts right now, so they're still worthless. DEX now has to revoke ownership. DEX first ensures that Token A and B have already revoked ownership of A_1 and B_1 respectively. Upon confirmation, DEX revokes its ownership of Token B_1 and Token A_1 finally making them usable. The swap is complete.

It's elegant because the process can fail at any point as if nothing happened. No need to roll back any transfers. You can run out of cycles at any time or be as malicious as you want, you'll only complete the exchange if it went right.

-------------------------

cnr | 2021-12-07 06:22:58 UTC | #60

~~I know these have lots of grammatical and formatting errors. I tried to go back and edit but I keep getting 403 errors. Perhaps this is because the posts are so long. You'll have to put up with the mistakes until I can figure out the issue :/~~

~~Figured out the issue, I was using uBlock Origin and that seemed to be triggering some security stuff on dinity.org's side.~~ Nope, that wasn't it. You now just get to read this in four posts instead of 2. They're worth it though, I promise ;)

-------------------------

cnr | 2021-12-06 21:33:30 UTC | #62

[Note: This was originally included in my [first post](https://forum.dfinity.org/t/non-fungible-token-nft-standard-community-consideration/6157/58?u=cnr), but had to be moved so I could edit the original without a 403 error]

Let me give one more example so that you can get the flavor of how nfts can become fungible with the right price inference mechanism. Let's say there's a wallet + nft scheme such that when the nft is transferred it checks to see what its "special value" is. If the special value is prime, the nft thereafter can't be transferred to another account (it becomes worth 0). To find that special value we first number each nft by its order of creation:
0
1
2 
etc. 

Then, each transaction is numbered. The special value is `transaction number + creation number`. If it's prime you can't transfer it. The prime tokens die.

In this market, if I sent you token \#3, and my payment to you was the 1018th transaction in the network's life then, bummer, your newly received token would be worth nothing (because 1018 + 3 = 1021 which is prime)!

In principle, this system is still "fungible" because you *can* (at a certain computational expense) estimate the likelihood that each token's special value will be prime. E.g. larger numbered tokens will have higher probability of being safe, since prime density is approximately `n/log(n)`. Similarly, tokens will have higher value if they are transacted later in the network's life (i.e. they become more fungible as the transaction count increases, for the same `n/log(n)` reason). Classes of tokens will change in value depending on the timing. E.g. if someone held tokens 10 000, 10 001 and 10 002, then as the market approached 21 398 transactions the value of their tokens would go up in value and stay high until the market got closer to 21 466 transactions. This is because tokens 10 000 through 10 002 have no special number primes for the transactions from 21 389 through 21 466. 

The fungibility of these tokens would be a function of the price inference mechanism you put in place. If evaluated manually by each human for each transaction, you can bet that it would be considered highly non-fungible. But, you could create a second layer to this network that computationally priced each token, rolling up all the uncertainties of the value of a wallet into a single "fungible" number that told you how much you'd have to transfer for the other person to get the value they care about. 

**This is a proof, of sorts, that fungibility is created by the price inference mechanism.**

-------------------------

cnr | 2021-12-06 21:38:50 UTC | #63

[Note: This was originally included in my [**second** post](https://forum.dfinity.org/t/non-fungible-token-nft-standard-community-consideration/6157/59?u=cnr), but had to be moved so I could edit the original without a 403 error]

### In Summary
1. Fungibility is defined by your price inference mechanism, not by your token standard. 
2. All "fungible" tokens can be implemented as types of non-fungible tokens, where the data portion of the non-fungible token tracks the current "balance" and follows certain ownership and burn rules. 
3. Treating fungible tokens as a type of non-fungible token gives us advantages over classic fungible tokens. For example, it makes it possible to implement a decentralized exchange without ever needing rollback. 

Finally, and perhaps most importantly, **this approach can likely dramatically simplify the token standard that each wallet needs to support.** The nft itself will carry the logic and permissions, and wallets can call simple handles like `share`, `transfer`, and `balance`. 

I'd like to at some point explore implementing this standard but I'm still learning rust. If anyone else finds anything interesting about the idea of unifying nfts and fts into a single standard feel free to steal, riff, rip, and repurpose. 

**An open question is how much additional cost overhead in terms of storage and compute this approach would incur.**

Also, please let me know the ways in which I'm wrong.

-------------------------

jzxchiang | 2021-12-07 00:28:29 UTC | #64

This is actually really deep. I'm still trying to fully understand it:

> 4. DEX now shares ownership of Token B_1 with Token A, and shares Token A_1 with Token B.

I thought in order to `share` a NFT, the caller has to specify an amount to "lock up" and split the NFT? Does the DEX canister do that here?

> 7. DEX still co-owns both nfts right now, so they’re still worthless. DEX now has to revoke ownership.

Like the above, doesn't the DEX canister have to burn tokens to revoke ownership? Or maybe NFTs only get split or burned when the caller of `share` and `revoke` is the first owner, but not for subsequent owners?

-------------------------

cnr | 2021-12-07 00:54:20 UTC | #65

Hi @jzxchiang, I was hoping you would see this. Excited to hear your thoughts :)

[quote="jzxchiang, post:64, topic:6157"]
I thought in order to `share` a NFT, the caller has to specify an amount to “lock up” and split the NFT? Does the DEX canister do that here?
[/quote]
`share()` could infer from its arguments whether it's a split share, or just a co-own share. If `share(addr)` it's clearly just trying to co-own with addr. 

Alternatively, `share(0, addr)` could be taken to mean that you're sharing ownership without duplicating any tokens. 

Less elegantly, but equivalently and perhaps more pragmatically, you could have two functions: `splitShare(quantity, address)` and `share(address)`. 

[quote="jzxchiang, post:64, topic:6157"]
Like the above, doesn’t the DEX canister have to burn tokens to revoke ownership? Or maybe NFTs only get split or burned when the caller of `share` and `revoke` is the first owner, but not for subsequent owners?
[/quote]

Yeah I think you have to require the original owner to burn to revoke. That's the only thing that makes sense if you want to preserve fungibility.

-------------------------

cnr | 2021-12-07 02:21:25 UTC | #66

This is a total distraction, but I played with the idea of allowing anyone to revoke for free as long as there still remain 2 other owners. 

[details=tl;dr. It doesn't work for fungible tokens.]

It produces two problems: 

1. In the DEX example, Token A could `revoke` right after sharing. That would force Token B or DEX to pay the burn bill. Maybe you can get around that by making `burn` a separate function that DEX tells Token A to call. Hard for me to understand the consequences of that.

2. Allowing anyone to pay to revoke ownership would create weird floating token pairs. They have no real value, but can still be shared, perhaps making for weird economics wherein people end up valuing the co-ownership of the token. They feel like [Cooper Pairs](http://hyperphysics.phy-astr.gsu.edu/hbase/Solids/coop.html) of the token world because local rules give rise to weird collective "virtual" behavior. 

Given that 2 remaining owners is an arbitrary threshold, you could play with implementing nfts that pay burn fees if `n` or fewer owners remain. For this, the more general approach would probably be to charge `burn due / n - 1` to burn.

For example, given an nft with 100 tokens that has been shared, we can vary the `n` that defines the revoke threshold. This would change the burn fee:
n | burn fee
2 | 100 
3 | 50 
4 | 33.33.. 
5 | 25
etc.

If someone pays the burn fee, the remaining "burn due" is decreased by that amount. E.g. with an `n` of 5, when I pay my 25 tokens to revoke ownership now the remaining group needs to pay off 75 tokens. there's 4 of them so with that formula `burn due / n - 1` that would be 75  / 3 or still 25 to revoke. However, if they could find another address to share it with it would go down to 18.75. 

What's wild about this is it creates an economics of negative pressure: either you have to find a new co-owner to take your spot, or you have to pay to leave the organization. In that world, people would want tools to prevent themselves from *receiving* tokens, and would have no qualms about sharing | "spending" them. In fact, in that world I would be willing to pay other people to accept ownership. 

There's no reason money has to work as a thing we want. It could also be a thing we flee from. I can see how the behavioral side probably works out better if you're trying to accrue things rather than avoid accruing them, but it's still interesting to think about. 

This might be an interesting economic model to explore for abundance pricing. What if currency was something you desperately wanted to give away? You go to a restaurant, but instead of them accepting your money, they give this negative pressure token to you. You accept participation in the token in exchange for eating the food. Now, you go to work and they pay you by accepting your negative tokens, etc. It's a bit like debt, but you'd own it as a group.

Alternatively, maybe you could use it for externality pricing. If I'm an oil company I can accept ownership of a negative pressure token that allows me to drill in a certain area. Years later there's an oil spill and an oil spill-tracking dao causes the weekly fees associated with carrying the token go up and it becomes expensive for me. I'll pay an oil cleanup company if they'll take the token off my hands. The cleanup company fixes the mess and the weekly fees go down, the cleanup company pockets the difference between the payment they received for accepting it and the cost of cleanup. Of course if the cleanup is more expensive than they bargained, they're stuck paying the weekly fees. 

One weird thing about it would be that given that the price to call your personal `revoke` is `burn due / n - 1` but the cost of collective action is `burn due / n`, this could create an incentive for people to pay for collective projects since `burn due / n - 1 > burn due / n`. It's like taxation with compensation, you pay toward the community effort and you actually earn money (or really, lose loss). 

Maybe this could be some sort of alternative to quadratic voting for addressing problems of collective action.

---

[/details]

To me this behavior is really interesting, but probably not what you mean by fungible token. File it under the category of, "interesting behavior you could implement in your fungible nfts by playing with the rules."

There's lots of that sort of thing, by the way. 

Treating fungible tokens as just a type of this special nft makes operations more atomic, and I believe it would be simpler to implement (no more rollbacks). But the real benefit is the way in which it increases the space of functionality we can implement. 

[Two functions and one rule](https://forum.dfinity.org/t/non-fungible-token-nft-standard-community-consideration/6157/59?u=cnr) are needed to implement fungible tokens. But what would you get if you had different internal rules? What if you could `share` but a shared nft could still be spent by all owners? What if you needed a minimum agreement threshold for spending upon share? What about a minimum agreement threshold for sharing with a new address? You can see how this approach to tokens creates an intermediate space between daos and tokens. Not quite an org, but much more than a token.

-------------------------

jzxchiang | 2021-12-07 05:34:00 UTC | #67

Really interesting stuff, thanks for sharing.

A couple of dumb questions to make sure I understand the mechanics:

* Where are the tokens burned from when `revoke` is called? For example, in step 5 Alice burns 200 tokens to revoke ownership of Token A_1. But aren't those 200 tokens supposed to go to Bob (or whoever the owner of token B is)?
* When you say "That would force Token B or DEX to pay the burn bill", are you referring to the cycle cost of calling the DEX and token canisters?

The share/revoke mechanism kinda reminds me of a counting semaphore in programming, but instead of N threads being able to access a shared resource in parallel, we have N owners who **cannot** access a shared token until the other owners revoke access (kind of the opposite in some sense). :thinking:

-------------------------

cnr | 2021-12-07 06:07:18 UTC | #68

It's probably not a dumb question but rather a dumb explanation. 

[quote="jzxchiang, post:67, topic:6157"]
Where are the tokens burned from when `revoke` is called? For example, in step 5 Alice burns 200 tokens to revoke ownership of Token A_1. But aren’t those 200 tokens supposed to go to Bob (or whoever the owner of token B is)?
[/quote]
By the time revoke is called, Bob already owns the nft with 200 tokens in it. The tokens were minted there when Alice first called `share`. Alice's Token A still has 500 tokens. Because Token A_1 has 2 owners, it's currently valueless. 

When Alice wants the transaction to be complete, she can do so by `revoke`ing her ownership. In order to revoke (and thus complete the transaction) we require her to burn 200 tokens in Token A, this way the total number of tokens in circulation remains constant. 

[quote="jzxchiang, post:67, topic:6157"]
The share/revoke mechanism kinda reminds me of a counting semaphore in programming, but instead of N threads being able to access a shared resource in parallel, we have N owners who **cannot** access a shared token until the other owners revoke access (kind of the opposite in some sense). :thinking:
[/quote]
Ooh, that is a fascinating analogy. It makes sense it would show up here, IC is async. I never really understood semaphores to be honest. I think the name always made me feel like they're so sophisticated and I felt intimidated.

-------------------------

cnr | 2021-12-07 06:08:00 UTC | #69

Going to update the prior post to try to make that clearer.

-------------------------

jzxchiang | 2021-12-07 07:39:56 UTC | #70

[quote="cnr, post:68, topic:6157"]
In order to revoke (and thus complete the transaction) we require her to burn 200 tokens in Token A, this way the total number of tokens in circulation remains constant.
[/quote]

Hmm interesting, so when Alice first called `share` to "split" her NFT of 500 tokens, she never actually split the 500 into a 300 and a 200. It's not until she calls `revoke` later on that the real token split happens. Does that sound right?

-------------------------

cnr | 2021-12-07 18:08:12 UTC | #71

Yep that's exactly right! 

This way, if the DEX transaction were to fail (let's say Bob never sends her his Token B_1s because he ran out of cycles) Alice still has all of her tokens that she started with. No rollback required

-------------------------

cnr | 2021-12-07 18:11:58 UTC | #72

In fact, I suppose `send` could just be implemented as a `share` and then a `revoke`.

-------------------------

Dali1986 | 2021-12-10 13:34:25 UTC | #73

I am fairly new to The Internet Computer but it seems to me that it may be worth supporting multiple standards and also looking at things as well as ETH style standards. 

Over on WAX (an eosio chain with a focus on NFTs) there is an interesting dominant standard called Atomic Assets.   It organises metadata neatly and has a features like author royalties and notifications built in. 

This effectively runs at contract level which I am assuming is similar to cannister level. 

I'd be interested in community members thoughts on this.

-------------------------

cnr | 2021-12-31 23:49:41 UTC | #74

Pretty interesting, seems no one has taken you up on the opportunity to explore this more. 

Would you be able to share more about how Atomic Assets is implemented?

-------------------------

Dali1986 | 2022-01-08 15:27:32 UTC | #75

Thanks, yes

The atomic assets contract is running under a single contract on WAX (and some other eosio chains I believe). It has a number of large community projects / guilds on the multisig on this contract as eosio contracts can be updated rather like canisters can I believe. 

This contract allows for collections to be set up - within collections are schemas - within schemas are templates and within templates are assets. Think of this a bit like 
collection = pokemon, 
schema = actual pokemon, items, NPCs
templates = pickachu, bulbasaur etc.. for the actual pokemon schema, candy, potions etc.. for items and so on
assets = all actual assets

Collections, schemas and templates have set attributes - main ones for the collections are the ownership details and authorised minters. 

Schemas set the fields that the templates within the schema will have.

Templates can set a maximum number of assets that can be minted based on the particular template and give the default information for the assets that can be minted.

Assets inherit from templates when being minted but can be overriden - attributes on assets can also be mutable or immutable.  Images/videos are generally held on IPFS and the hash is usually held against an 'image' attribute. 

Full details can be viewed on the pinknetworkx github.

Disclaimer: I'm not involved with this project but I have used the NFT marketplaces it enables a lot.

-------------------------

ricky18F | 2022-01-25 04:31:26 UTC | #76

It would be great if we would have an official standard of NFT, and how we should manage with them.

-------------------------

Dustin | 2022-03-08 13:37:59 UTC | #77

Where are royalties defined within all the standards?
Are these part of the standard or are they marketplace specific? For example on Ethereum, royalties are not part of the ERC721 or ERC1155 standard, so if an NFT is minted on Opensea and then sold on Rarible, the royalty is not ensured. There was a royalty standard ([EIP 2981](https://eips.ethereum.org/EIPS/eip-2981)) released last year which tries to unify royalties across marketplaces, but not sure how adopted they are yet. Is there something similar on ICP or even implemented within a standard?

-------------------------

MCLYang | 2022-04-08 07:40:10 UTC | #78

Very great question. I review most of the code and I think we still have to define by ourselves. Most likely migrate from eth standard, or check Entrepot and see how do them manage the royalties? https://entrepot.app/

-------------------------

ovictor | 2022-06-21 20:35:53 UTC | #79

Hi everyone,  there is a piece of NFT/Tokens on IC that I can't figure out how to address.  NFT minting depends upon a canister owned by someone, if the canister owner does not tip cycles, the NFT is gone.
 
When NFT comes to my mind it is an asset registered on chain that will live forever like on ethereum network(I known there are some caveats there too).
 It seems to me that NFT on IC does not have any differentiation than a traditional web 2.0 Application on that perspective. 
What are your thoughts on that?

-------------------------

AdamS | 2022-06-22 17:15:28 UTC | #80

The purpose of a blockchain system is to decentralize it. Nobody owns the hosting, and if it's blackholed, nobody owns the service itself. If the canister runs out of cycles, simply deposit more and it'll be back up again. A blackholed canister does live on chain forever, and can be defrosted at any time; it just needs gas to function, except somewhere between a thousandth and a millionth of what Ethereum does (and stably pegged to the XDR to boot).

-------------------------

CatPirate | 2022-06-22 18:11:48 UTC | #81

***Sad NFT enjoyooooooor noises***

*What is in a standard* by catspheare, will be available to mint soon. For Whitelist drop ur seed phrases in this thread

-------------------------

Julianchuk | 2022-06-23 02:13:09 UTC | #82

Just after this first message into thread must be pinned the last update official status, not just for this but all developments, anybody will read the whole thing and can be persisting questions already solved...

-------------------------

Zane | 2022-07-01 00:34:05 UTC | #83

But what about the state of a frozen canister? Does it get reset after a while? Otherwise there would be ton of state bloat for data nobody is paying for.

-------------------------

domwoe | 2022-07-01 07:49:31 UTC | #84

The canister still needs to pay for its storage, but is not able to do any computation. Actually, when you set the `freezing_threshold` of a canister you set it in seconds and the IC calculates the actual threshold in cycles based on the idle cycle consumption at a given point. Per default the `freezing_threshold` is approx. 30 days. If the canister doesn't get topped before finally running out of cycles it gets deleted.

You can read more about this in the Interface Specification:
https://internetcomputer.org/docs/current/references/ic-interface-spec#canister-cycles
https://internetcomputer.org/docs/current/references/ic-interface-spec#canister-cycles

-------------------------

ovictor | 2022-07-05 14:26:08 UTC | #85

From a business perspective,  I can not understand why someone would trust buying NFT or a custom token on IC due to this reverse gas model. A token can just not exist anymore and you lose everything. This gas model has some advantages for sure, but it not seems to be suitable for any kind of custom token. To be trusted it should be backed by dfinity, like the ledge canister.

If I'm misunderstanding something I would really like to hear another point of view. I was thinking SNS, for example, if the token is a DAO supported by SNS, it might be more reliable, maybe it's a way forward.

-------------------------

skilesare | 2022-07-05 16:45:11 UTC | #86

Anyone can fund a canister.  If you own an NFT that is about to freeze you can just fund the canister with a few cycles and it gets new life.  You will see management services emerge that do this automatically.  We're early, but I don't think you have anything to worry about unless the NFT you are producing is GBs in size.

-------------------------

CatPirate | 2023-05-19 02:24:03 UTC | #88

is this post still relevant @diegop

-------------------------

diegop | 2023-05-19 13:21:00 UTC | #90

There has been a NFT technical working group with community members for the last year. They work on this but not familiar with their state:

https://wiki.internetcomputer.org/wiki/Ledger_%26_Tokenization

-------------------------


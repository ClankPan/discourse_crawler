diegop | 2021-09-30 17:49:58 UTC | #1


## Summary

Currently, Canister Smart Contract stable memory storage is capped due to Wasm limitations at 4 GB per Canister. To improve scaling, a new system API will be offered to Canisters that allow them use as much memory as available on their subnet (currently 300 GB).

### Status
- Community approved the design via NNS
- NNS proposals with code updates coming soon

## What you can do to help

* Ask questions
* Propose ideas

## Documentation

[Proposed design to review and vote on.](https://forum.dfinity.org/t/increased-canister-storage/6148/37?u=diegop)

## Key people involved
 @akhilesh.singhania @dsarlis  @stefan-kaestle @ulan 

## Timelines
- [x] [Community Conversation - Increased Storage](https://www.youtube.com/watch?v=YGG1s37juDY&t=7s ): August 25, 2021, 11 AM PDT / 8 PM CEST
- [x] [Draft plan for feature](https://forum.dfinity.org/t/increased-canister-storage/6148/37?u=diegop) posted on the forum for review: August 26, 2021, 15:00 UTC 
- [x] [NNS Motion Proposal submission](https://dashboard.internetcomputer.org/proposal/18337):  September 1, 2021, 15:00 UTC 
- [x] [NNS Motion Proposal expiration](https://dashboard.internetcomputer.org/proposal/18337):  September 3, 2021, 15:00 UTC 
- [x] [NNS Motion proposal passed
- [ ] NNS proposals that upgrade the network's code (as per design which passed Sep 3):  Week of Sep 13


## Relevant Background

Currently, a canister on the IC has two types of storage available to it:

* A wasm heap which is constrained to 4 GiB because currently [wasmtime](https://github.com/bytecodealliance/wasmtime) does not support the [wasm64](https://github.com/WebAssembly/memory64) specification and hence has 32 bit addressing.
* A[ stable memory](https://sdk.dfinity.org/docs/interface-spec/index.html#system-api-stable-memory) which is also currently constrained to 4 GiB because it too only has 32 bit addressing.

So a canister can under normal conditions store 8GiB of storage. However, when a [canister is upgraded](https://sdk.dfinity.org/docs/interface-spec/index.html#system-api-upgrades), its wasm heap is wiped so for all practical purposes, it only really has access to 4GiB of storage in the stable memory. In the past we demonstrated a proof of concept of BigMap which is a solution to enable an application to scale its storage by sharding its data across multiple canisters.

Based on discussions with external developers and with developers within the DFINITY foundation, we made the following observations:

* For a lot of applications that developers are currently trying to build, the 4GiB of a single canister is not quite enough. However, the capacity of a single subnet (300 GiB) is sufficient for the time being.
* BigMap is a good solution to scale storage to the capacity of multiple subnets but is not ready for use in production yet.
* It also appears that BigMap might be too heavy-handed an approach for scaling to the storage capacity of a single subnet and other mechanisms could be designed which are simpler to build and simpler to use.

Based on the above observations, the goal of this feature is to enable canisters to scale to the capacity of a single subnet by expanding how much stable memory it can store. At a high level, this will be done by offering a stable memory API that enables 64 bit addressing thereby allowing canisters to address 16 Exabytes of stable memory storage (probably more storage than what will ever be available on a single subnet). The feature also involves investigations into and making sure that the current data structures used for managing the stable memory of the canister can scale appropriately when they store a lot more than 4GiB of storage.

-------------------------

lastmjs | 2021-08-16 21:49:57 UTC | #2

[quote="diegop, post:1, topic:6148"]
a new system API will be offered to Canisters
[/quote]

I was hoping that canisters would simply have access to more memory through orthogonal persistence. Is there going to be some API that will be required? I think to be of the greatest benefit to developers, the heap of the canister needs to be greatly increased. You should be able to just create data structures and fill them with data, scaling up to the capacity of the subnet.

And in the future...I think it would be great to figure out a way to scale a single canister beyond the bounds of a subnet, but perhaps we can discuss that later.

-------------------------

diegop | 2021-08-16 21:51:53 UTC | #3

I believe "new API" is not a developer-facing API, but API between Canisters and the IC so it is transparent to developers and still be "Orthogonal Persistent."

-------------------------

diegop | 2021-08-16 21:54:01 UTC | #4

[quote="lastmjs, post:2, topic:6148"]
And in the future…I think it would be great to figure out a way to scale a single canister beyond the bounds of a subnet, but perhaps we can discuss that later.
[/quote]

Yes, those are different efforts. This is to use 64bit memory addressing which can be handled entirely via execution layer.

Increasing beyond subnet would require different skills/components, and still the goal of BigMap proposal.

(Clearly, I need to fill out more of these descriptions ;) )

-------------------------

lastmjs | 2021-08-16 21:55:22 UTC | #5

That would be amazingly beautiful.

-------------------------

jzxchiang | 2021-08-26 16:17:32 UTC | #6

I asked about this in another [question](https://forum.dfinity.org/t/relshared-in-cancan/6474?u=jzxchiang), but I'm wondering how this will work practically.

For example, what if I want to use a data structure (like `HashMap`), but because it's not a stable type I store the data instead in a stable variable (like `Trie`). And in the pre-upgrade I convert from `Trie` to `HashMap` and in the post-upgrade I convert from `HashMap` back to `Trie` for persistent storage.

If stable memory goes up to 300 GB but non-stable memory stays capped at 4 GB, this wouldn't really work.

-----

As an aside, how is stable memory currently implemented? How can every canister have 300 GB available on a subnet? Where does this extra RAM come from? Do the subnet nodes have enough to begin with?

-------------------------

flyq | 2021-08-17 03:21:35 UTC | #7

I think the 4G is the stable memory, this single canister limits caused by the wasm32's pointer size. The 300G is also the stable memory, this subnet limits caused by mechines, as a server has 3 TB memory, but they need to store the copies:
https://github.com/dfinity/ic/blob/master/rs/config/src/execution_environment.rs#L9-L19

-------------------------

akhilesh.singhania | 2021-08-17 07:31:07 UTC | #8

Currently, the wasm heap is capped at 4GiB so we cannot expand it further.  Once wasmtime stabilises support for wasm64, then we could allow heaps to grow beyond 4GiB as well.  However, then we also have to worry about how does a canister with a ton of heap upgrades itself (because we currently wipe the heap on upgrades).  So supporting wasm64 will open other issues that also need to be addressed.

-------------------------

akhilesh.singhania | 2021-08-17 07:36:45 UTC | #9

Extending 64bit stable memory is just first step in the process.  After this more work would be needed.  At a high level, one idea to use the expanded stable memory with just 4GiB of wasm heap is to do something like the following:

* When a canister starts executing a message, it will first have to identify where in the stable memory the relevant block of data resides.
* It will then copy over the relevant block of data from stable memory to heap.
* It can now operate on the data on the heap.
* Once done, it can now copy the updated data back to the stable memory.

Identifying where in stable memory the relevant data lies will involve building some sort of index in the wasm heap or a HashMap structure that can operate over the stable memory API.  This part is not being actively worked on currently by the team.  We expect that this may not necessarily need system support and could be built purely in the application space.

-------------------------

nomeata | 2021-08-17 12:29:59 UTC | #10

Note that even already now, the Internet Identity canister does precisely that: Keep all relevant data in stable memory, and use the heap only as scratch space. Makes upgrades simpler.

I guess expanding stable memory beyond 4GB means that the Internet Identity service does not need to scale out for space reasons any time soon. (Maybe for throughput.). @kritzcreek will be happy to hear that :-)

-------------------------

akhilesh.singhania | 2021-08-17 15:26:05 UTC | #11

Indeed, that is where we got the inspiration.

-------------------------

diegop | 2021-08-17 20:25:28 UTC | #12

I just updated the **Summary** at the top of this thread with more info, including relevant folks.

-------------------------

flyq | 2021-08-18 03:25:18 UTC | #13

[quote="nomeata, post:10, topic:6148"]
use the heap only as scratch space.
[/quote]

Thanks, is there any documents about stable memory and heap of canister? what do the devs need to do to use the different memory style?

Maybe vars used `stable` keyword will be storaged in stable memory.

-------------------------

akhilesh.singhania | 2021-08-18 09:55:26 UTC | #14

The way the two memories are used differs depending on whether you are writing in Rust or Motoko.

CC: @claudio for motoko documentation.

In Rust, you can use the heap as a normal wasm heap and the stable memory via the API as defined in https://github.com/dfinity/cdk-rs/blob/main/src/ic-cdk/src/api/stable.rs.  Note that this will be extended when the 64bit stable memory extension lands.

-------------------------

claudio | 2021-08-19 07:34:41 UTC | #15

Motoko indeed uses stable memory as the backing store for stable variables.

https://sdk.dfinity.org/docs/language-guide/upgrades.html

Before an upgrade, the stable variables are serialized from wasm memory to stable memory. After an upgrade, the stable variables are deserialized from stable memory into wasm memory. Motoko doesn't read or write to stable memory during execution outside of upgrades.

This solution, though simple, is not ideal as the (de)serialization steps can both run out of cycles for large data structures, preventing upgrade when they do.

We are currently exploring support and an API for (almost) raw access to (32-bit) stable memory that we hope to extend to 64-bit stable memory in the future. The idea to allow both high-level Motoko stable variables and (abstract) stable memory to co-exist in a single canister so that canisters that prefer to maintain their data in stable memory throughout execution (to avoid the problem with exhausting cycles on upgrade) can does so if they wish, at the conceptual cost of using a much lower-level API.

-------------------------

akhilesh.singhania | 2021-08-19 08:49:43 UTC | #17

Hi all, a brief update on this feature.

We have had some discussions about what is the best way to introduce new APIs on the IC.  We want to expose new APIs to let developers experiment with them and to solicit feedback.  It is possible that based on the feedback we get, it turns out that the API needs some adjustments.  And if developers have deployed canisters using the API, then making adjustments will be difficult.  So we are planning on coming up with a process that allows us introduce APIs in an experimental phase.  I'll make a separate post about the process after some of the ongoing discussions have concluded to solicit feedback on this process.

I imagine that the community will not  want to block the release of this feature / API till we have figured out what the best way to do experimental APIs is yet.  So, the current plan is that when we release this API, we will document it as being in experimental phase and ask developers not to use it on any critical canisters yet.  And if based feedback, some adjustments to the API are needed, then the existing canisters using it will be impacted.  We will of course discuss and announce impending changes so that the everybody has an opportunity to upgrade their canisters.  We will also have to figure out what to do if someone removes the controller from their canister and then they cannot be upgraded (hopefully no one does that :crossed_fingers:)

I apologise in advance for any difficulties this might cause you.  And I hope that you can appreciate that introducing a process to iterate on APIs will allow us all to build a better IC without a lot of cruft.  Thank you for understanding.

-------------------------

ulan | 2021-08-20 13:45:27 UTC | #18

DFINITY engineer here. In the initial roll out we will limit the stable memory size to 8GB. We will increase it in future release after gathering feedback.

-------------------------

lastmjs | 2021-08-20 14:17:27 UTC | #19

So should increasing the Wasm heap be another roadmap proposal entirely? Increasing stable memory is a good step, I hope that increasing the heap won't be thought of as less useful or put off for too long. Copying over chunks of stable memory into the heap is still going to be a complication for library authors and developers to deal with, and having a 300 GB heap would be ideal.

-------------------------

akhilesh.singhania | 2021-08-20 14:36:03 UTC | #20

@lastmjs : absolutely!  Please do not think that we will stop after shipping this feature.  This is just a small step in helping developers access tons of storage in an ergonomic way.  We absolutely realise that asking developers to copy chunks of memory back and forth from stable memory to heap is complicated, froth with footguns, and also inefficient!  We are actively discussing designs in this space and I will keep you guys posted on developments here.

-------------------------

lastmjs | 2021-08-20 14:51:11 UTC | #21

Sounds just swell, thanks!

-------------------------

jzxchiang | 2021-08-20 23:13:30 UTC | #22

Interesting idea to let canisters directly access stable memory during runtime outside of upgrades.

If they can do that, then what's the need for a wasm heap? Can't canisters use stable memory for all computation in that case, including scratch space? Is it slower to access the wasm heap versus stable memory via this hypothetical API? Does it cost more to store data in stable memory?

Thanks!

-------------------------

nomeata | 2021-08-21 07:48:19 UTC | #23

[quote="jzxchiang, post:22, topic:6148"]
Can’t canisters use stable memory for all computation in that case, including scratch space? Is it slower to access the wasm heap versus stable memory via this hypothetical API? Does it cost more to store data in stable memory?
[/quote]

That was the vision all along: that wasm code has multiple memories they can use, with different lifetimes, and all accessed via Wasm memory instructions, so fast.

The stable memory API through expensive bulk system API function calls was just a make shift. Unfortunately the necessary webassembly extension (multiple memories) didn't make it in time into the Wasm tools we use, so we are stuck with this transitional API for now. But in principle you are absolutely right.

-------------------------

jzxchiang | 2021-08-24 06:34:17 UTC | #24

[quote="nomeata, post:23, topic:6148, full:true"]
[quote="jzxchiang, post:22, topic:6148"]
Can’t canisters use stable memory for all computation in that case, including scratch space? Is it slower to access the wasm heap versus stable memory via this hypothetical API? Does it cost more to store data in stable memory?
[/quote]

That was the vision all along: that wasm code has multiple memories they can use, with different lifetimes, and all accessed via Wasm memory instructions, so fast.

The stable memory API through expensive bulk system API function calls was just a make shift. Unfortunately the necessary webassembly extension (multiple memories) didn't make it in time into the Wasm tools we use, so we are stuck with this transitional API for now. But in principle you are absolutely right.
[/quote]

Hm, when you mean "expensive bulk system API function calls", do you mean that storing data in stable memory is more expensive than in non-stable memory? (If not because of any differences in storage cycle cost but instead due to the additional computation required to transfer data in and out of stable memory in pre- and post-upgrade functions?)

-------------------------

nomeata | 2021-08-24 07:49:29 UTC | #25

In terms of actual running time, normal memory is accessed using Wasm memory instructions which are compiled to memory instructions, so that’s native speed fast. Accessing stable memory with the current API requires function calls into the host, bounds checking, explicit copying etc., so definitely more expensive. Whether that cost is currently reflected also in cycle costs (which you probably care more about than running time) I don't know, but we can assume that cycle costs will be refined to match real costs eventually.

In the original vision, building on Wasm multi memory support, stable memory would be accessed the same as the main memory, and would likely have the same access cost. One wouldn’t speak of “main” memory at that point any more, as there can be any number of memories, of varying lifetimes (per message, maybe per call, per module version, permanent).

It might help if the people at DFINITY could share the “Refining persistence” document by Andreas Rossberg, which explains this better.

-------------------------

lastmjs | 2021-08-25 01:14:11 UTC | #27

I would love access to said document

-------------------------

nomeata | 2021-08-25 10:30:33 UTC | #28

It seems the code for 64 bit stable memory is live! The IC runs this revision:
```
~/dfinity/ic $ curl https://ic0.app/api/v2/status|cbor2yaml.rb|grep impl_version
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100   331  100   331    0     0    565      0 --:--:-- --:--:-- --:--:--   564
  impl_version: 27e1eadbcbe90abfe56d9c8dfd39e1a78e52c624
```
which, according to the code dump repo history, is dumped as 89446f5
```
~/dfinity/ic $ git log --oneline
35dd8f9 Update from revision 8a5b9a2e1468dfb286c77084a9b3597b9e3993b5
e362530 Update from revision d8dabe1cb0bb1e60a11e5bb8033d1615fefb252f
89446f5 Update from revision 27e1eadbcbe90abfe56d9c8dfd39e1a78e52c624
```
and indeed it’s there https://github.com/dfinity/ic/blob/89446f5/rs/embedders/src/wasmtime_embedder/system_api.rs#L610-L655.

So early adopters can probably start playing around with it, even if it didn’t make it to https://sdk.dfinity.org/docs/interface-spec/index.html or https://github.com/dfinity/ic-hs yet.

It would be helpful to the outsiders if the code dumps would include a changelog (maybe auto-generated from the internal repo?), to easier see what changes to look out for.

-------------------------

akhilesh.singhania | 2021-08-25 11:58:17 UTC | #29

@nomeata : no the code is not actually live yet.  These are stub implementations.  See https://github.com/dfinity/ic/blob/89446f5a04f053040b4863eab5458446d925ed0e/rs/system_api/src/system_state_accessor_direct.rs#L201.  

Some more of the implementation will get pushed out in the next upgrade.  However, we are also planning on doing an NNS proposal where we will ask the community to vote on whether or not this feature should be enabled or not.  Only if the vote passes, then we will push the final changes that will enable the feature.

-------------------------

skilesare | 2021-08-25 15:57:29 UTC | #30

What would be the ETA of getting these system APIs into Motoko once they are live?

-------------------------

akhilesh.singhania | 2021-08-25 16:27:45 UTC | #31

cc: @claudio .  Maybe he can share his thoughts.

-------------------------

diegop | 2021-08-25 17:32:22 UTC | #32

Hey Folks!

This project is our guinea pig project for what public roadmap projects will look like, and the next 7 days will have a lot of activity surrounding it.

1. **Today, August 25** - [Community Conversation](https://www.reddit.com/r/dfinity/comments/p6y4n9/community_conversations_increased_canister/) on Increased Canister Storage

2. **Thursday, August 26** - Draft proposal posted on the forum for review. We will post to [the developer forum thread on the project](https://forum.dfinity.org/t/increased-canister-storage/6148) a markdown doc (hosted on [Github repo for NNS proposals](https://github.com/ic-association/nns-proposals/tree/main/proposals)) that explains the project design and intent so people can see what the project is about and how we intend to achieve the desired goal.

3. **Wednesday, Sep 1** - This is the nuanced part: I will submit to the NNS a proposal (without a binary that upgrades the IC) asking the wider IC community to vote on whether the Foundation and wider community should continue working, and ultimately deploy, the work for increasing smart contract canister storage. ***We are essentially using the NNS's voting mechanisms to let the community express themselves.***

4. **Friday, Sep 3** - NNS Proposal has a 48-hour expiration so the decision will be completed by then.

There will be two possible outcomes from this:

a. **Proposal passes** - if it passes, then the project team will submit an NNS proposal to actually upgrade the IC. In the case of Increased Canister Storage, this will happen relatively quickly since a lot of the groundwork had been done so the actual changes will be light. This is an exception. Many times in the future, if a proposal to "work on this version of the plan" passes, it may take weeks or months to have an implementation ready.

b. **Proposal fails** - I think this is very unlikely, but worth considering that this means the community does NOT want this change. In which case, we will not continue to work on this plan, but potentially go back to the drawing board and discuss it further with the community

**Please note:** in order to let the community truly express themselves, ***the DFINITY Foundation will vote as late as possible***. We know lots of people's neurons follow the DFINITY Foundation so we want to let the community time to breathe.

-------------------------

diegop | 2021-08-25 17:52:32 UTC | #33

Our Community Conversation on Increased Canister Storage with @akhilesh.singhania  goes live in a few min:

Join the conversation to be able to participate in our live Q&A :tada:

https://dfinity.zoom.us/webinar/register/WN_E3Z09PM7RBCml7viWIMcxA

-------------------------

lastmjs | 2021-08-25 18:32:59 UTC | #34

Will DFINITY or the ICA be "banned" from voting on this proposal? How can we ensure the vote actually represents the will of the community if very large players vote?

-------------------------

diegop | 2021-08-25 18:38:08 UTC | #35

[quote="diegop, post:32, topic:6148"]
**Please note:** in order to let the community truly express themselves, ***the DFINITY Foundation will vote as late as possible*** . We know lots of people’s neurons follow the DFINITY Foundation so we want to let the community time to breathe.
[/quote]

Not sure if you saw this in my note above.

-------------------------

diegop | 2021-08-25 20:05:03 UTC | #36

I don’t want to sound more opinionated or “final” than i actually intend so I think I should write the facts and the intents:

The facts
- there is no mechanism to ban anyone from voting 
- I think this is a very popular proposal 

The Intent
- the foundation intends to get as much community feedback as possible 
- the foundation intends to Vote last (with the knowledge of what the community voted), but it does intend to vote (as member of community)
- this is very much an interactive and iterative process so If there are any unintended consequences of this model, we will iterate. Not set in stone. Maybe for more controversial proposals, we can try something different.

-------------------------

akhilesh.singhania | 2021-08-26 14:20:39 UTC | #37

As we discussed earlier, we are posting our plan for Increased Canister Storage. You can read our intent, design decisions trade-offs, caveats, and rollout plan.

As Diego mentioned, the current plan is that on Wednesday September 1, Diego will submit an NNS proposal for the community to vote whether the final version of the plan should be implemented. 

Please give us feedback, so we can improve and give the IC the best possible plan to increase smart contract canister stable memory.

# NNS Proposal: Add 64-bit stable memory API

Main authors: @ulan , @akhilesh.singhania 

## Objective

Currently canisters are effectively limited to 4GiB of storage. This is because stable memory uses the 32-bit addressing scheme and when a canister is upgraded, its Wasm memory is wiped.

A number of applications can benefit from access to additional storage without having to partitioned into multiple canisters. The goal of this proposal is to introduce a stable memory API that allows canisters to address more than 4GiB of memory allowing canisters to have more storage bound [eventually] only by the actual capacity of the subnet.

The goal of this proposal is to increase the amount of memory that canisters can access [eventually] bound only by the actual capacity of the subnet. Since, the [Memory64 proposal](https://github.com/WebAssembly/memory64) is not [standardized](https://github.com/WebAssembly/proposals) yet and [its implementation](https://github.com/bytecodealliance/wasmtime/pull/3153) in Wasmtime is not production ready yet, this proposal enables the increase by introducing a new stable memory API.

## Background

When the stable memory was first designed and implemented, the [Memory64 proposal](https://github.com/WebAssembly/memory64) was not [standardized](https://github.com/WebAssembly/proposals) yet and only recently it was [implemented](https://github.com/bytecodealliance/wasmtime/pull/3153) in Wasmtime but the implementation is not production ready yet. Further, the multiple memories proposal is still in [Phase 3](https://github.com/WebAssembly/proposals#phase-3---implementation-phase-cg--wg). With this in mind, stable memory was designed with a 32-bit addressing scheme so that it could eventually be replaced by Wasm native features.

Supporting 64-bit Wasm memory presents a number of performance challenges for the Internet Computer. Currently Wasmtime can efficiently eliminate bounds checks for 32-bit memory accesses by using guard pages. A similar optimization is not possible for 64-bit memory accesses making them more expensive. Besides that more optimization work around `memory.grow()` needs to be done before the implementation is production ready.

Since bringing the Memory64 support to IC may take a while and some canisters need large memory now, we propose an extension of the stable memory API to 64-bit instead.

## Proposal

We propose to add four new functions to the [System API](https://sdk.dfinity.org/docs/interface-spec/index.html#system-api) that mirror the existing 32-bit functions:

* `ic0.stable64_write: (offset: i64, src: i64, size: i64) -> ()`
  * Copies the Wasm memory region specified by `src` and `size` to the stable memory starting at the given offset. Note that this API uses 64-bit addressing for the Wasm memory even though at the moment the Wasm memory only supports 32-bit addressing. This is done to keep the possibility of supporting 64-bit Wasm memory open in the future.
* `ic0.stable64_read: (dst: i64, offset: i64, size: i64) -> ()`
  * Copies the stable memory region specified by `offset` and `size` to the Wasm memory starting at the given address `dst`.
* `ic0.stable64_size: () -> (page_count: i64)`
  * Returns the number of 64KiB pages in the stable memory as a 64-bit integer. Note that it would be possible for this function to continue to return a 32-bit integer as the 32-bit version of the API does. With the page size of 64KiB, a 32-bit integer could address up to 256 TiB which could be sufficient for a very long time. However, it was felt that there should be a clear distinction between the 32-bit and 64-bit versions of the API and having this API return a 64-bit integer should not have any negative impact.
* `ic0.stable64_grow: (additional_pages: i64) -> (old_page_count: i64)`
  * Tries to grow the memory by `new_pages` many pages containing zeroes. If successful, returns the _previous_ size of the memory (in pages). Otherwise, returns `-1`.

As the specification repo of the Internet Computer is not open source yet, please see the proposed diff [here](https://gist.github.com/ulan/8cc37022c72fe20dc1d57fdfd0aaf1fd).

## Backwards compatibility

In order to ensure smooth transition and upgrade we allow canisters to use the 32-bit and 64-bit versions interchangeably up to 4GiB. In other words, both versions operate on the same stable memory. As soons as the size of the stable memory grows beyond 4GiB the 32-bit versions cease to work. Calling them will result in a trap.

## Risks

The main risk is canisters mixing the 32-bit and 64-bit functions after the stable memory grows beyond 4GiB. We somewhat mitigate the risk by ensuring that 32-bit functions will trap in such a case so that the canister execution stops instead of continuing with a wrong result.

## Alternatives Considered

1. One alternative is to introduce a completely new 64-bit stable memory that is disjoint from the existing 32-bit memory. While it is a cleaner design, it would complicate canister upgrades because canisters would need to copy the existing state from the 32-bit stable memory to 64-bit stable memory.
2. Another alternative we considered was to say that once a canister uses the 64-bit version of the API then using any of the 32-bit API will result in a trap. We felt that this would allow canisters to more easily detect problems in switching between APIs however we felt that this may overly complicate the implementation.
3. Another alternative is to wait until the [Memory64](https://github.com/WebAssembly/memory64) and [Multiple Memories](https://github.com/WebAssembly/multi-memory) proposals are production ready. Then the stable memory can be represented as one of the multiple 64-bit memories removing the need for the new System API.

## Rollout plan

When introducing a new functionality to any production environment, there are two types of risks that should be managed:

* Regardless of all the testing done before the rollout, there is still a risk of the new functionality introducing some bugs in production.
* Regardless of all the initial feedback gathered about the new API, using it in production may reveal some shortcomings requiring adjustments to the API impacting the canisters that already depend on the API.

Hence, the rollout plan for this proposal would be the following:

* Even though the new API allows canisters to address the entire capacity of the subnet, the stable memory of a given canister will initially be capped at 8GiB.
* The API will be marked as experimental and use of the API in essential canisters will be strongly discouraged. This way the community can feel encouraged to make and accept future proposals to break existing canisters using the API in order to not support deprecated APIs thereby keeping the API as clean and easy to understand as possible.
* After we gain confidence in the API and in its implementation, over subsequent NNS proposals, we will gradually increase the size of the stable memory and mark it as no longer being experimental.

-------------------------

akhilesh.singhania | 2021-08-26 15:34:08 UTC | #38

There was a question about how we will test this feature before we deploy it to production.  I will write a small text here about how we do testing in general.  I will also ask the testing team to write a more detailed post to provide more details.  

* As we use Rust, we rely heavily on its unit testing framework for writing unit tests
* Then we have a e2e integration testing framework where we can bring up a simplified version of the Internet Computer on a single machine and validate a number of properties.
* Next we have the [reference implementation](https://github.com/dfinity/ic-hs) of the Internet Computer which is used to validate a number of additional properties.
* Next we have a number of testnets where we deploy fully functioning Internet Computers to further test in an environment as close to production as possible.

We have a CI / CD pipeline that runs various tests using the above mechanisms.  We run some tests on each PR as it is merged and we run some tests on an hourly basis, some on a nightly basis, etc.

-------------------------

nomeata | 2021-08-26 17:58:29 UTC | #39

Thanks! All sensible and well done. I endorse this proposal! (I should probably get a neuron that people can follow if they like my endorsements.)

[quote="akhilesh.singhania, post:37, topic:6148"]
Note that it would be possible for this function to continue to return a 32-bit integer as the 32-bit version of the API does.
[/quote]

I think an even better argument for returning `i64` here is that the `memory.size` Wasm instruction will return an `i64` [in the `memory64` extension](https://github.com/WebAssembly/memory64/blob/master/proposals/memory64/Overview.md#validation), and the stable memory API should stay close to the wasm instructions it stands in for.


[quote="akhilesh.singhania, post:37, topic:6148"]
As the specification repo of the Internet Computer is not open source yet
[/quote]

I like the word “yet” in this sentence.

[quote="akhilesh.singhania, post:37, topic:6148"]
Calling them will result in a trap.
[/quote]

Your prose sounds as if accessing the first 4GB will trap if the memory is large than 4GB, which I think is good. But the diff adds the check
```
if offset+size > 2^32 then Trap
```
This probably should say
```
if |es.wasm_state.stable_mem| > 2^32 then Trap
```
in `stable_read`, `stable_write` and `stable_size`.

[quote="akhilesh.singhania, post:37, topic:6148"]
the stable memory of a given canister will initially be capped at 8GiB.
[/quote]

I expect soon there will be a demand for a way for canisters to find out how much memory they _can_ use (besides trying). But I don’t mind that not being part of the API, as there is no such functionalities for real WebAssembly memories, and sticking close to the native Wasm experience is probably useful.

-------------------------

LightningLad91 | 2021-08-26 19:44:51 UTC | #40

Thank you for providing this information. I'd really like to learn more about the testnet environment. Hopefully there will be a lot of detail on this topic in the test team's post.

-------------------------

diegop | 2021-08-26 19:55:06 UTC | #41

Foundation actually has a dedicated testing team so we have asked them to help document and write more about this for folks. thanks for the feedback!

-------------------------

diegop | 2021-08-26 19:56:03 UTC | #42

[quote="nomeata, post:39, topic:6148"]
Thanks! All sensible and well done. I endorse this proposal!
[/quote]

pack it up, we are good to ship then ;) 

[quote="nomeata, post:39, topic:6148"]
(I should probably get a neuron that people can follow if they like my endorsements.)
[/quote]

You totally should!

-------------------------

nomeata | 2021-08-26 20:18:52 UTC | #43

Oh, and more more issue with the proposed spec: the code for `stable_grow` _must_ return -1 if the new size would be above 2^32 bytes. The current code would allow a 32 bit API using canister to grow the canister above 4GB (and then start trapping in every call).

-------------------------

diegop | 2021-08-26 20:19:40 UTC | #44

In all seriousness, thank you for taking the time to read in earnest, Joachim

-------------------------

diegop | 2021-08-26 20:20:07 UTC | #45

[quote="nomeata, post:43, topic:6148"]
The current code would allow a 32 bit API using canister to grow the canister above 4GB (and then start trapping in every call).
[/quote]

@ulan @akhilesh.singhania

-------------------------

mparikh | 2021-08-26 22:22:04 UTC | #46

Thanks @akhilesh.singhania for your detailed technical explanation of this change. Thanks @diegop for your follow-through and involving different teams. I do think that proposal adds significant value to the development of IC; with the increased canister storage.

I agree, in part,  with @lastmjs on the voting issue with Dfinity Foundation. i.e. I believe that **Dfinity Foundation should abstain from voting** (even if the proposal fails); even if there is no mechanism to ban Dfinity Foundation from voting.

**Democracy, even liquid democracy, assumes (nay requires) that all voting participants are equally informed about all issues surrounding the topic that they are interested in voting on**. In software development, it is NOT sufficient to just to show a diff to the voters who do not have access to the source code versus others (in Dfinity Foundation and others bound by NDAs) who do. In asking for such a vote, **we are inadvertently creating different classes of voters; one  class that is not completely informed (unless the source code is open sourced) and one class that is informed through access to source code.** By not providing access to Unit and Integration Test cases, we are once again creating a divide. We are saying to the folks that do not have access, please trust the ones that do have access in their testing.

I disagree, in part, with @lastmjs in context of how bigger players have bigger say in the voting. This is the underlying structure that I believe that I agreed to when I decided to participate in the IC eco-system. I understood my neuron may not have the same voting power as someone else's neuron. I am ok with it.

The notion of abstinence in voting should certainly not alien; especially since the source code is expected to be open-sourced at some time.

-------------------------

skilesare | 2021-08-27 02:09:03 UTC | #47

Regarding alternative 1: isn’t this fairly easy to route around via an upgrade? Upgrade a 32 bit canister to include export routines to move data to a trusted backup canister, upgrade to a 64 bit canister with an empty memory that has rehydrate functions to pull data back. Then upgrade and remove the hydration functions?

If it is cleaner it may be worth making existing 32 bit canister jump through this while we only have a relatively small number.

I’m all for the upgrade, but think we should run out all the options and beat them up. We don’t want to generate a bunch of needless complexity.

-------------------------

diegop | 2021-08-27 03:09:32 UTC | #48

These are all very reasonable points, and very compelling ones!

I am a big believer in “laying out the Legos on the table and seeing what we can build together.”

With that in mind, there is an additional lego I want to lay out on the the well-reasoned table you’ve set:

I think there is a silent group of people who TRUST and want the foundation to make technical choices (they make this choice by following the neurons). For the foundation to NOT vote would be to rob this group of some weight or say.

Are there people who follow the foundation out of sheer default? Very likely. But I also think there are many earnest folks who express their will through following. I have been thinking a lot about this group and how to make sure they are also heard.

I don’t have all the answers, but I wanted to lay out all the Legos on the table…

-------------------------

mparikh | 2021-08-27 06:45:05 UTC | #49

Thanks, @diegop for your Lego Block. My concern, per se, is not about liquid democracy. In fact all four of my neurons follow the foundation and therefore I trust the foundation to make the correct decision on my behalf. As a matter of fact, I don't have the time to go through the code that I am asking to be shown. Again I signed up for liquid democracy when I decided to invest in the IC eco-system. I am ok with it.

However in our fledgling liquid democracy experiment, it is important to call out issues that need to be called out for others as well. A potential future resolution could be to NOT bring a proposal prior to all the source code being viewable ; if approval is required on the code itself. 

I anticipate that this issue, while fairly innocuous now, may become quite contentious  in the Threshold EDSCA Signature case. This is because Dfinity Foundation might WANT to hang on to the source code and the papers in private; in the belief that this gives IC a leg up visa-ve competitors. But then how does one get the community to vote on it as an informed citizenry; especially the community will need to trust this code for IC-BTC integration?

-------------------------

jzxchiang | 2021-08-27 06:42:23 UTC | #50

[quote="skilesare, post:30, topic:6148, full:true"]
What would be the ETA of getting these system APIs into Motoko once they are live?
[/quote]

This would be awesome!

-------------------------

nomeata | 2021-08-27 08:22:59 UTC | #51

[quote="skilesare, post:30, topic:6148"]
What would be the ETA of getting these system APIs into Motoko once they are live?
[/quote]
Well, for the way Motoko uses stable memory now, e.g. as the backend for the fully automatically managed `stable` variables, using the new API is pretty simple, but also not very useful, as you still need the stable data in main memory between upgrades, so still bound by 4GB.

Changing the implementation of `stable` variables to, say, load them on demand would allow Motoko to hold more data and have many other benefits (e.g. no out-of-cycles worries when upgrading), but would be a bigger undertaking.

A middle ground is giving developers mostly raw access to stable memory. @claudio is working on that ([design doc](https://github.com/dfinity/motoko/pull/2626)). 32 vs. 64 won’t make a big difference here, but it’s still WIP.

-------------------------

ulan | 2021-08-27 17:50:03 UTC | #52

[quote="nomeata, post:39, topic:6148"]
`if |es.wasm_state.stable_mem| > 2^32 then Trap`
[/quote]

Good catch! That was the actual intention.

[quote="nomeata, post:43, topic:6148, full:true"]
Oh, and more more issue with the proposed spec: the code for `stable_grow` *must* return -1 if the new size would be above 2^32 bytes. The current code would allow a 32 bit API using canister to grow the canister above 4GB (and then start trapping in every call).
[/quote]

Another good catch! Thanks a lot. I'll fix the spec diff today/tomorrow.

-------------------------

diegop | 2021-08-27 17:56:59 UTC | #53

[quote="ulan, post:52, topic:6148"]
Good catch!
[/quote]

Boom! Open design process :)

-------------------------

diegop | 2021-08-27 18:02:22 UTC | #54

These are all great points, and ones I struggle with internally (as I weigh cons/pros and trade-offs) to be honest, I don't feel I have clarity of thought (yet) to add anything, and I am a big believer in "*whereof one cannot speak, one must remain silent*", I have no great need to be clever, write for sake of writing, or win arguments, so you should know that I am certainly listening and absorbing. Let me brew on this a bit, but definitely know that this process is meant to be iterative and interactive. We will adapt.

-------------------------

levi | 2021-08-27 18:02:48 UTC | #55

Which source code are you talking bout that’s not open ?

-------------------------

nomeata | 2021-08-27 20:51:11 UTC | #56

The asciidoc sources of the [Interface Specification](https://sdk.dfinity.org/docs/interface-spec/index.html)

-------------------------

Nick | 2021-08-28 01:18:53 UTC | #57

FWIW I have chosen to follow the DFINITY foundation's neuron, and I do **not** want them to abstain from voting. Isn't that the whole point of vote delegation? I trust the foundation's decisions on these early, foundational proposals. If at some point I disagree with the foundation's decisions, I will manually vote, or delegate my votes to someone else.

-------------------------

saikatdas0790 | 2021-08-28 06:20:23 UTC | #58

I AM one of these people. I trust in Dfinity the same way I trust in my doctor. I might not understand every little decision that they take for my well being but I trust in their expertise to make the best educated guesses even in cases of uncertainty.

-------------------------

ulan | 2021-08-28 18:19:30 UTC | #59

I updated [the proposed spec changes](https://gist.github.com/ulan/8cc37022c72fe20dc1d57fdfd0aaf1fd) to address @nomeata's comments. Here is the [diff](https://gist.github.com/ulan/8cc37022c72fe20dc1d57fdfd0aaf1fd/revisions) to what @akhilesh.singhania posted initially.

-------------------------

nomeata | 2021-08-28 21:11:39 UTC | #60

LGTM, as far as I can tell at 11pm.

-------------------------

ililic | 2021-08-31 23:15:21 UTC | #61

<iframe name="lb24" frameborder="0" height="960px" loading="lazy" width="100%" class="lb24-iframe" scrolling="auto" src="//v.24liveblog.com/iframe/?id=2865685865434475158"></iframe>

-------------------------

ililic | 2021-08-31 23:16:20 UTC | #62



-------------------------

diegop | 2021-09-01 04:44:51 UTC | #63

**Update**: We are on track to Submit the proposal to vote on at 15:00 UTC on Wednesday Sep 1st as scheduled ;)

-------------------------

diegop | 2021-09-01 14:58:19 UTC | #64

The proposal is live : https://nns.ic0.app/#/proposal/18337

-------------------------

diegop | 2021-09-01 15:03:52 UTC | #65

Check out the new Dashboard page for NNS proposals: https://dashboard.internetcomputer.org/proposal/18337

great work by @Dylan !

-------------------------

diegop | 2021-09-03 15:27:24 UTC | #66

*The proposal for the design passed!*

https://dashboard.internetcomputer.org/proposal/18337

Next steps:

- @ulan will submit NNS proposals with code upgrades that follow the design proposal community agreed on.

-------------------------

Soncb | 2021-09-14 05:34:26 UTC | #67

hi everyone, ICP perfect go to moon

-------------------------

C-B-Elite | 2021-09-06 15:24:02 UTC | #68

Hello, I want to know: 
the canister stable memory is used by all canister replicas or just one replica?

-------------------------

C-B-Elite | 2021-09-07 12:29:48 UTC | #69

Hello everyone:
I am confusing that we can only use 2G wasm memory in normal times, but we have 8G stable memory now, how can we use the 8G stable memory ? Can we read or write data in stable memory outside upgrade? @claudio

-------------------------

PaulLiu | 2021-09-07 17:24:30 UTC | #70

canister has both "heap memory" and "stable memory". Max heap memory is 4GB, and max stable memory has been increased to 300GB. If you use Rust, there are APIs accessing stable memory directly.

But if you use Motoko, there is no API to directly access stable memory, so you are limited to 4GB heap memory. Further more, Motoko uses a copying GC (garbage collector), which means only 2GB memory is usable for your motoko program at the moment. This is subject to change I believe. Please correct me if I'm wrong @claudio

-------------------------

C-B-Elite | 2021-09-08 03:18:02 UTC | #71

Thank you , perfect answer !

-------------------------

ulan | 2021-09-08 17:43:44 UTC | #72

[quote="diegop, post:66, topic:6148"]
@ulan will submit NNS proposals with code upgrades that follow the design proposal community agreed on.
[/quote]

Quick update: the implementation of the API will be included in the next version that is expected to roll out to subnets next week (subject to change if there are unexpected blockers).

-------------------------

claudio | 2021-09-09 17:42:31 UTC | #73

Actually, we are about to ship a library that gives you (almost) raw access to 32-bit IC stable memory while letting you also continue to use stable variables when convenient. 

We intend to extend that to allow access to the proposed, larger stable memory.

Motoko acquired a second, compacting GC, a while ago. This lets you use much more of the 4GB heap. You need to select the GC with a compiler flag.

-------------------------

skilesare | 2021-09-10 01:50:50 UTC | #74

What are these flags? Does dfx use the automatically?

-------------------------

claudio | 2021-09-10 12:02:25 UTC | #75

https://sdk.dfinity.org/docs/language-guide/compiler-ref.html

--compacting-gc should enable it.

Dfx supports this via the optional "args" field in the dfx.json record for Motoko projects.

-------------------------

C-B-Elite | 2021-09-10 13:17:44 UTC | #76

How to choose the GC Algorithm？ Is there any advice？

-------------------------

claudio | 2021-09-10 15:26:12 UTC | #77

I don't think we've written up any advice (@osa1 ?), but there's some interesting stats and discussion here.

https://github.com/dfinity/motoko/issues/2033#issuecomment-842379468

I think the basic take home is that the compacting gc costs more in terms of cycles, because of the number of passes over the heap it needs to do, but uses less pages (and provides more user space) than the copying gc, which requires twice the live heap size to do a collection.

-------------------------

C-B-Elite | 2021-09-10 15:41:26 UTC | #78

Wow， thank you for your explanation ：D

-------------------------

C-B-Elite | 2021-09-14 01:45:56 UTC | #79

dfx 0.8.1:
in dfx.json 
```
"build":{
   "args" : "--compacting-gc",
    ······
}
```

-------------------------

ulan | 2021-09-16 12:57:56 UTC | #80

Update: the implementation of the 64-bit stable memory is part of the new replica release (version e86ac9553a8eddbeffaa29267a216c9554d3a0c6) that will roll out to subnets soon.

-------------------------

jzxchiang | 2021-09-27 06:57:06 UTC | #81

I may have missed this, but is this fully rolled out?

Is it supported natively using the `stable` variable qualifier in Motoko? If not, are there stopgap tools we can use to access memory addresses directly in Motoko?

Thanks!

-------------------------

ulan | 2021-09-27 16:30:05 UTC | #82

@jzxchiang: you're right. The new version e86ac9553a8eddbeffaa29267a216c9554d3a0c6 with 64-bit stable memory has been rolled out to all subnets as of today.

I will defer the question about Motoko support for @claudio.

-------------------------

diegop | 2021-09-27 16:35:42 UTC | #83

[quote="ulan, post:82, topic:6148"]
he new version e86ac9553a8eddbeffaa29267a216c9554d3a0c6 with 64-bit stable memory has been rolled out to all subnets as of today.
[/quote]

Correct. **The memory of canister smart contracts has gone from 4 GB to 8 GB memory. No need for developers to do anything.** 

This is the first step of many on the methodical increase :roller_coaster: towards 300 GB.

-------------------------

rossberg | 2021-09-29 10:00:26 UTC | #84

Motoko does not yet make use of the 64 bit API, e.g., the amount of data stored in stable variables is currently still limited to 4 GiB. But of course we intend to upgrade soon.

(We also have recently implemented a (still experimental) API for accessing stable memory directly. This will also support 64 bit at the time we release it.)

-------------------------

diegop | 2021-09-29 18:37:16 UTC | #85

Folks in this thread may be interested in this: https://forum.dfinity.org/t/releasing-the-source-of-the-bigmap-poc-demo/7601

-------------------------

jasonkingss | 2021-10-15 15:34:53 UTC | #86

I was hoping that canisters would simply have access to more memory through orthogonal persistence. Is there going to be some API that will be required? I think to be of the greatest benefit to developers, the heap of the canister needs to be greatly increased. You should be able to just create data structures and fill them with data, scaling up to the capacity of the subnet.

-------------------------

nomeata | 2021-10-15 16:08:25 UTC | #87

That would require the [`wasm64`](https://github.com/WebAssembly/memory64) WebAssembly extension, which, as Akhi says further up, isn’t ready for use yet. And even if it was – Orthogonal Persistence  and keeping all data in the heap, while fine for immutable canisters, doesn’t really work well when you want to upgrade your canister. At least not with the programming languages we have at hand.

-------------------------

lastmjs | 2021-10-15 16:51:29 UTC | #88

We need to figure this out (upgrading canisters with large Wasm heaps). I think the most exciting long-term goal is an unbounded Wasm heap. That's the most ideal solution for developers.

-------------------------

coin_master | 2021-10-15 17:41:10 UTC | #89

I don't want to imply anything but you just copied @lastmjs comment on this thread
https://forum.dfinity.org/t/increased-canister-smart-contract-memory/6148/2?u=coin_master

And you did the same for another 11 posts on this forum.
Are you a bot?

-------------------------

diegop | 2021-10-15 17:51:41 UTC | #90

Great catch @coin_master

-------------------------

flyq | 2021-10-21 07:13:39 UTC | #91

[quote="coin_master, post:89, topic:6148"]
Are you a bot?
[/quote]

Interesting :rofl: lol

-------------------------

diegop | 2021-11-08 14:36:22 UTC | #92

I thought folks here would appreciate this update: https://forum.dfinity.org/t/two-questions-about-canister-storage/7776/18?u=diegop

-------------------------

cryptoschindler | 2021-12-02 18:09:29 UTC | #93

any news on this? can motoko delveopers make use of the increased stable storage yet?

-------------------------

claudio | 2021-12-02 20:03:05 UTC | #94

We actually have had support for 32 bit stable storage silently avialable for a while as library ExperimentalStableMemory.mo. We didn't advertise this to avoid people taking a dependency on it.

I'm currently revamping this to support 64-bit stable memory (about half way there). However, we're not convinced this is a great solution for users since it essentially introduces one big global variable (a growable byte array) and has the potential to be a big footgun if used improperly, as well as getting in the way of future, more abstract uses of stable memory including maintaining stable variables in IC stable memory throughout computation, rather than copying out and in on upgrade.

-------------------------

jzxchiang | 2021-12-02 20:57:01 UTC | #95

Just to clarify, does that mean that Motoko `stable` variables are still currently limited to holding only 4 GB worth of data? (Due to stable memory addresses still being 32-bit, i.e. 2^32 ~ 4 GB?)

-------------------------

claudio | 2021-12-02 22:24:58 UTC | #96

Yes, and that's unlikely to change any time soon. It would have rather big implications for our 32-bit tagged value representation.

-------------------------

jzxchiang | 2021-12-02 23:44:54 UTC | #97

Gotcha. Hopefully we can unify the APIs for <4 GB stable memory via `stable` variables and for >4 GB `ExperimentalStableStorage` at some point...

-------------------------

rossberg | 2021-12-03 07:54:37 UTC | #98

[quote="claudio, post:96, topic:6148"]
It would have rather big implications for our 32-bit tagged value representation.
[/quote]

More importantly, it would require moving our (stable) heap from internal Wasm memory to external IC memory, which would have substantial performance/cycle implications. So, before the IC adopts the memory-64 and multi-memory extensions proposed for Wasm, this isn't really practical.

-------------------------

modclub | 2021-12-11 18:44:25 UTC | #99

Do you have a timeframe when 64bit support will be available? We have been testing the API with 32bit support and are interesting in using this feature.

-------------------------

jzxchiang | 2021-12-12 06:41:09 UTC | #100

Why do stable variables involve the wasm linear memory (which I'm guessing is the heap you're referring to)? Does Motoko load every stable variable from stable memory into wasm linear memory on canister start, and store them back into stable memory on canister termination/upgrade?

-------------------------

rossberg | 2021-12-13 07:15:24 UTC | #101

Yes, Motoko temporarily serialises the heap to stable memory for upgrades (using the pre/post upgrade hooks). Keeping stable vars in stable memory would be vastly more expensive, because every variable access would involve API calls and de/serialising (arbitrarily large) data structures. And having to do GC on the stable memory.

Eventually, we would like to improve this, but that requires Wasm multi-memory support on the IC at a minimum.

-------------------------

nomeata | 2021-12-13 10:21:17 UTC | #102

[quote="rossberg, post:101, topic:6148"]
Eventually, we would like to improve this, but that requires Wasm multi-memory support on the IC at a minimum.
[/quote]

I challenge that assumption (posting mostly for the record, we have discussed it elsewhere already): even a vastly more cycle expensive solution would likely serve some use cases better than what we have right now, and some possible implementations (e.g. a page-sized cache in main memory for stable memory accesses) might be less vast, and would allow us to build the system we envision now, and improve the cycle consumption later.

-------------------------


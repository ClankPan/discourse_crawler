skilesare | 2023-05-12 18:03:35 UTC | #1

This is the fourth bounty in a series of bounties we are releasing this week in the run-up to [Motoko Bootcamp](https://www.dfinitycommunity.com/motoko-bootcamp/). Winners of the Bootcamp’s Intermediate level will get the first crack at selecting one of these bounties to complete.

# Motoko Wallet - #15

## Current Status: Discussion

* Discussion (02/23/2022)
* Ratification 
* Open for application
* Assigned 
* In Review 
* Closed 

[Official Link - Discussion](https://icdevs.org/bounties/2022/02/23/Motoko-Wallet.html)

## Bounty Details

* Bounty Amount: $5,000 USD of ICP at award date - $5000 USD of ICP Match Available
* ICDevs.org DFINITY Foundation Grant Match Available: $5000 USD of ICP at award time - (For every ICP sent to 29a3cf0c087e14a17c44770cb4ed01cc6d70e394f685ada03ea74a30835a70e8, ICDevs.org will add $125 USD of ICP at award date to the bounty, up to the first 40 ICP donated, After 40 ICP, donations to the above address will add .25 ICP to this issue and .75 ICP to fund other ICDevs.org initiatives)
* Project Type: Single Contributor
* Opened: 02/23/2021
* Time Commitment: Weeks
* Project Type: Library
* Experience Type: Intermediate - Motoko
* Issue Type: Motoko Library

## Description

This bounty gives the opportunity to

* learn how candid works
* learn about the security model of the IC
* learn about token standards
* learn about the cycle model
* learn about the agent-js library used to connect the web to the IC

The goal of this bounty is to create an on-chain wallet written in Motoko.

The [call_raw](https://smartcontracts.org/docs/base-libraries/ExperimentalInternetComputer.html) function is being added to motoko in DFX 0.9.2.  This functionality allows the creation of on-chain wallets written in Motoko.  With call_raw your wallet users will be able to call remote canisters from their wallet without the wallet having to upgrade your wallet with the known types of new services.

The wallet the developer will create will be both a ready-to-deploy wallet and a template for others to use to create custom wallets with unique properties and signature schemes.

## Definitions

Wallet - a wallet can hold assets on the Internet Computer. In our case, our wallet is itself a canister.  It can hold tokens, NFTs, and other assets.  It can also make function calls on behalf of the user.

Multi-sig - sometimes you want more than one person to sign for a transaction.  n-of-m means that n number of valid signatures out of m are required to have the wallet call a function on another canister or transfer assets.

Proposal - when a function is "in flight" and waiting for enough signatures it is a proposal.

Allow-List - a wallet needs to put canisters that are valid for the wallet to interact with on a list.  If the canister is not on this list then the wallet will not call the function.

## Wallet API

```
    // request the cycle balance of the canister
    // must be an owner of the canister
    query cycle_balance() -> async Nat;

    // returns the default account for the wallet that can be used with some ledger based tokens
    query default_account() -> async Text;

    // returns a list of tokens that have been added to the wallet
    // the wallet should natively know how to handle EXT, DIP20, and Ledger(ICP) based tokens
    query token_list() -> async [{principal: principal; standard: Text; symbol: Text}];

    // returns a list of NFT canisters that have been added to the wallet
    query nft_list() -> [{principal: Principal; standard: Text, collection: Text}];

    // returns a list of allowed functions for the wallet
    query allow_list() -> [{principal: Principal; function: Text, service: Text}];

    // returns a list of functions that were called by the wallet
    query function_log(page: Nat; skip: Nat, count: Nat);

    //keeps a running list of config changes
    query config_log(page: Nat; skip: Nat, count: Nat);

    //returns proposals in reverse order
    query proposals(page: Nat; skip: Nat, count: Nat) -> [{proposal: Nat; proposalResult: ProposalStatus; principal: Principal; function: Text; data: Blob, timestamp: Nat;}];

    //returns config proposals in reverse order
    query config_proposals(page: Nat; skip: Nat, count: Nat) -> [{proposal: Nat; proposalResult: ProposalStatus; command: ConfigureWalletCommand; timestamp: Nat;}];

    //can be called by an owner or signer to change the way the wallet behaves.  If the wallet is in multi-sig mode a proposal will be created.
    configure_wallet(command: ConfigureWalletCommand) -> Result<ConfigureWalletResponse, Error>;

    //calls the function and either executes the function or creates a proposal to execute the function;
    call(principal: Principal, function: Text, data: Blob) -> async CallResult;

    // signs an open proposal.  Must be called by a signer
    sign_propsal(proposal: Nat, {#sign; #reject}) -> Result<ProposalStatus, Error>;

    // signs config proposals, Must be called by a signer
    sign_config_proposal(proposal: Nat, {#sign; #reject}) -> Result<ProposalStatus, Error>;

    // receives cycles
    // should be logged to the token transaction log
    wallet_receive() : async () 

    type CallResult: {
        #reply: Blob;
        #proposal: Nat; //sha256 of ["wallet_proposal"] + [Principal of self] + ["nonce"] + [stable Nonce]
    };

    type ConfigureWalletCommand = {
        #addToken: {
            principal: principal; 
            standard: Text, 
            symbol: Text};
        #removeToken: Principal;
        #addNNSNeuron: NeuronIdOrSubaccount = variant {
            Subaccount : vec nat8;
            NeuronId : NeuronId;
            };
        #removeNNSNeuron: NeuronIdOrSubaccount = variant {
            Subaccount : vec nat8;
            NeuronId : NeuronId;
        };
         #addSNSNeuron: NeuronIdOrSubaccount = variant {
            Subaccount : vec nat8;
            NeuronId : NeuronId;
            };
        #removeSNSNeuron: NeuronIdOrSubaccount = variant {
            Subaccount : vec nat8;
            NeuronId : NeuronId;
        };
        #addNFT: {
            principal: Principal; 
            standard: Text, 
            collection: Text};
        #removeNFT: Principal;
        #addAllow: { [
            principal: Principal; 
            function: Text, 
            service: Text}; //candid
        ]};
        #removeAllow: {
            [
            principal: Principal;
            function: Text; ]
        }
        #setDebug: Bool;
        #purgeDebug;
        #purgeFunctionLog;
        #purgeConfigLog;
        #sendCycles: {
            principal: Principal;
            amount: Nat;
        }
        #setMultiSig: {
            #owner: [Principal];
            #multisig: {
                owner: ?[Principal]; //null sets the owner to self so that only a proposal can change the participants
                n: Nat; //number of signatures needed
                m: [[Principal];
                private: Bool; //if private is true, do not return who voted for what.
            };
            #remote: {
                owner: ?[Principal]; //null sets the owner to self so that only a proposal can change the participants
                principal: Principal; //calls actor.proposal_status(Nat) -> async Result<{ProposalStatus}> and actor.sign_proposal(caller: Principal, proposal: Nat) -> aync Result<{ProposalStatus} for signatures
            };
            #local: {
                owner: ?[Principal]; //null sets the owner to self so that only a proposal can change the participants
                principal: Principal; //calls self.proposal_status(Nat) -> async Result<{ProposalStatus}> for status and self.sign_proposal(caller: Principal) -> aync Result<{ProposalStatus} for signatures
            };

        }
    };

    type ProposalStatus {
        status: {
            #pass; 
            #open; 
            #reject; 
            #error: Error
        };
        votes: ?{
            accept: [Principal];
            reject: [Principal];
            outstanding: ?[[Principal]]
        }
    }




```

## Wallet UI

The wallet will need to use the http_request function to return a web application that exposes the following information and functions.

We suggest constructing wireframes and submitting them for public content before building the interfaces.  You may consider enlisting the help of a designer as well.  Design is not a priority for this bounty, but an unusable interface will not be accepted.  The interface should use a minimalist responsive template and look and operate on both a desktop and mobile.

* Balance of Cycles in the Canister
    * query cycle_balance();
* Balance of ICP in the Canister
    * query the ICP ledger canister directly for the default sub account of the wallet principal
* Add tokens by supplying a principal and token standard
    * Support DIP20, EXT, Ledger
    * obtain registered tokens using query token_list
    * allow for the sending of tokens
        * this interface should be loadable via querystring so that applications open it in a pop up/tab for payment sending.
        * keep a history of transactions initiated via the wallet interface
* Add NFTs by supplying a principal and NFT standard
    * Support DIP721, EXT
    * obtain registered nfts using query nft_list()
    * allow for the transfer of nfts
    * this interface should be loadable via querystring so that applications open it in a pop up/tab for payment sending.
    * keep a history of transactions initiated via the wallet interface
* Add NNS Neurons to a list to be managed.  The wallet will need to be added as a hotkey for those neurons
    * Interface to issue hotkey enabled neuron functions.
* Add SNS Neurons to a list to be managed.  The wallet will need to be added as a hotkey for those neurons
    * Interface to issue hotkey enabled sns neuron functions.
* Add canisters/function name pairs to a allow list.
    * This interface should be loadable via the query string so that remote applications can open a pop up window/tab requesting to allow the application.
    * keep a history of transactions initiated via the wallet interface -> canister, function, timestamp, parameters and results should only be saved if the wallet is in 'debug' mode.
* ability to purge the params and returns of the function transaction log
* ability to purge the entire token, NFT, or function transaction log.
* a canister in debug mode should only keep 1 GB of debug logs. once the size limit is hit it should run a clean up function and remove the oldest 10% of the log.
* ability to put the canister in debug mode
* UI form manually loading a DID File, pointing at a canister, and running a function as the wallet canister. You may be able to use [candid-ui](https://github.com/dfinity/candid/tree/master/tools/ui)
* List of open proposals
    * ability to sign/reject an open proposal
* Ability to log in with Plug, II, and StoicWallet
* Ability to add a principal to the owner list in owner mode.
* Ability to start a proposal to modify the principal list in multi-sig mode;

## Proposals

* Proposals should auto execute once a pass is found.
* Errors should be captured and reported.
* Changes in signing members should not change the signers for existing proposals

## Agent Js

You will need to find a way to use [agent-js](https://github.com/dfinity/agent-js) to take a candid input and return the binary representation of the input parameters of a call and return it to the web app so that it can pass it to wallet.call(function_name: Text, params: Blob).  Further, when you have the results you will need to use agent-js to decode the binary encoded result.

Bonus:  Use DAB to load in known service names.


## To apply for this bounty you should:

* Include links to previous work writing tutorials and any other open-source contributions(ie. your github).
* Include a brief overview of how you will complete the task. This can include things like which dependencies you will use, how you will make it self-contained, the sacrifices you would have to make to achieve that, or how you will make it simple. Anything that can convince us you are taking a thoughtful and expert approach to this design.
* Give an estimated timeline on completing the task.
* Post your application text to the Bounty Thread

## Selection Process

The ICDevs.org developer's advisors will propose a vote to award the bounty and the Developer Advisors will vote.

## Bounty Completion

Please keep your ongoing code in a public repository(fork or branch is ok). Please provide regular (at least weekly) updates.  Code commits count as updates if you link to your branch/fork from the bounty thread.  We just need to be able to see that you are making progress.

The balance of the bounty will be paid out at completion.

Once you have finished, please alert the dev forum thread that you have completed work and where we can find that work.  We will review and award the bounty reward if the terms have been met.  If there is any coordination work(like a pull request) or additional documentation needed we will inform you of what is needed before we can award the reward.

## Bounty Abandonment and Re-awarding

If you cease work on the bounty for a prolonged(at the Developer Advisory Board's discretion) or if the quality of work degrades to the point that we think someone else should be working on the bounty we may re-award it.  We will be transparent about this and try to work with you to push through and complete the project, but sometimes, it may be necessary to move on or to augment your contribution with another resource which would result in a split bounty.

## Funding

The bounty was generously funded by the DFINITY Foundation. If you would like to turbocharge this bounty you can seed additional donations of ICP to 29a3cf0c087e14a17c44770cb4ed01cc6d70e394f685ada03ea74a30835a70e8.  ICDevs will match the bounty 5:1 for the first 40 ICP out of the DFINITY grant and then 0.25:1 after that.  All donations will be tax deductible for US Citizens and Corporations.  If you send a donation and need a donation receipt, please email the hash of your donation transaction, physical address, and name to donations@icdevs.org.  More information about how you can contribute can be found at our [donations page](https://icdevs.org/donations.html).


## General Bounty Process

### Discussion

The draft bounty is posted to the DFINITY developer's forum for discussion

### Ratification

The developer advisor's board will propose a bounty be ratified and a vote will take place to ratify the bounty.  Until a bounty is ratified by the Dev it hasn't been officially adopted. Please take this into consideration if you are considering starting early.

### Open for application

Developers can submit applications to the Dev Forum post.  The council will consider these as they come in and propose a vote to award the bounty to one of the applicants.  If you would like to apply anonymously you can send an email to austin at icdevs dot org or sending a PM on the dev forum.

### Assigned

A developer is currently working on this bounty, you are free to contribute, but any splitting of the award will need to be discussed with the currently assigned developer.

### In Review

The Dev Council is reviewing the submission

### Awarded

The award has be been given and the bounty is closed.

# Matches

DFINITY Foundation Grant: - $5000 USD of ICP at award date


[Other ICDevs.org Bounties](https://icdevs.org/bounties.html)

-------------------------

skilesare | 2022-03-04 12:27:06 UTC | #2

This one needs a lot of oversight and comments.  Feel free to apply your best software architecture skills and criticize/improve liberally.  We need this to be a robust tool for the community.

-------------------------

Safik | 2022-03-14 11:13:08 UTC | #3

Hi, Skillshare

I have a wallet (https://github.com/fury02/Difiwallet ). It has all the basic functions of crypto wallet. I have plans for further development. I am sure that it will be possible to quickly redefine to a new implementation (currently used from Plug-wallet)
I have a few interesting questions to get my bearings.
1) What does the "cell_row" function give? that is, I want to understand and read the material on the interaction of this in the IC.
2) Where to leave a request? On the forum or  icdevs.org

-------------------------

skilesare | 2022-03-14 15:47:16 UTC | #4

I'm not sure what you mean by cell_row.

This is a bounty for an onchain wallet.  An external wallet like plug would access this wallet by giving the plug principal access rights and then routing requests through the wallet canister.  I'm sure your wallet would be able to access it as well. I'm happy to answer any questions here on the forum as it gives the community access to the process and invites them to participate and contribute.

-------------------------

Safik | 2022-03-14 16:24:44 UTC | #5

I understand that you need a wallet written in motoko. Above, just an explanation that I have a valid user UI (Android, iOS). At the moment I'm wondering how long it will take, I also need to understand if the current version of the IC is ready. I don't have such deep knowledge in this direction at the moment, although I write on motoko but a few other things. In general, I want to "feel the ground" to determine the time and take this project on myself.

-------------------------

0rions | 2022-03-22 13:32:03 UTC | #6

Hey, was wondering is there any multisig wallet that already exist ? Or any ressource on how to set up one ? Thanks

-------------------------

skilesare | 2022-03-22 14:11:45 UTC | #7

Depends on what you want to do. Axon.ooo has some multisig ability but is tied to the NNS.

See: https://forum.dfinity.org/t/icdevs-org-bounty-2-add-generic-dao-functions-and-interface-to-axon/8284

-------------------------

JaMarco | 2022-06-06 05:23:07 UTC | #8

@skilesare What is the purpose of an onchain wallet? I'm not clear on what it's used for and what make it different than other wallets like NNS, Plug, ect... 

Why does it need to be written in Motoko as opposed to Rust? 

Can you elaborate on this statement, I'm not sure what you mean: "With call_raw your wallet users will be able to call remote canisters from their wallet without the wallet having to upgrade your wallet with the known types of new services."

-------------------------

skilesare | 2022-06-06 08:25:05 UTC | #9

An "off chain" wallet requires interaction from a user. An onchain wallet can operate in an automated fashion and allow comopsable services to obtain information as if it were you. 

Take a "friends" list on a social service. If the only  way to get it is via a query from your wallet, then there is no way for another service on the IC to read it. You are at the mercy of the service to add a "manager" pattern to their service. 

With an onchain wallet you could authorize a service to call the service as you any time it needs to.

In addition daos will need wallets and they will need something like this.

The language is not as important as the feature set.

Personal prediction: on chain wallets will end up being the default way to interact with the IC.

-------------------------

JaMarco | 2022-06-06 15:14:54 UTC | #10

Thanks, I think I understand a little more. For the DAO usecase, what would be the difference between this wallet and the NNS wallet (which is onchain as well, right)? Would this wallet just be a generalized version of the NNS wallet?

-------------------------

skilesare | 2022-06-06 21:38:13 UTC | #11

The NNS wallet is not on chain. There is a delegation scheme on chain, but that is different.. This would be a canister deployed to the IC and would need to have a 1:1 ratio between user and canister.

-------------------------

JaMarco | 2022-06-06 22:17:33 UTC | #12

Does http_request have to be implemented manually to return the web app or can dfx asset canister be used to serve it. If the former, why does it need to be manually implemented?

-------------------------

skilesare | 2022-06-08 17:36:59 UTC | #13

It doesn’t have to be, but it would make deployment easier.

-------------------------

JaMarco | 2022-06-08 20:02:39 UTC | #14

Manually implementing http_request would make deployment easier? What do you mean by that? I thought it would be the opposite.

-------------------------

skilesare | 2022-06-08 22:15:14 UTC | #15

Having everything in one canister lets a user select their chosen “installed” ui. I guess this works as a separate canister as well, but with II I think you’d get a more reliable principal to interact with them going through another canister.

Either way it is an implementation detail.

-------------------------

JaMarco | 2022-06-10 05:04:18 UTC | #16

Question about the logs requirement. Are the logs supposed to be just a List data structure? In the logs interfaces given, how are page, skip, and count parameters supposed to be used to construct the return value?

-------------------------

skilesare | 2022-06-10 05:43:02 UTC | #17

A list is fine, although I’d recommend buffet.

Pagination should be supported because returns are limited to 2MB. The exact scheme is up to you. Skip and size or page and size. Either would work.

-------------------------

mparikh | 2022-06-10 06:40:21 UTC | #18

I am drawing a wire-frame for this wallet as i find some of the ideas explored in here quite fascinating.

One of the questions i had was regarding :

[quote="skilesare, post:1, topic:11282"]
```
//calls the function and either executes the function or creates a proposal to execute the function;
    call(principal: Principal, function: Text, data: Blob) -> async CallResult;
```
[/quote]

This function could await for a non-trivial (1 day?) time-frame because in a multi-sig scenario you would need a majority of principals to sign...if all principals need to sign on a manual basis, it could take a while...

It might be better for the function to actually call back the caller in this case. That could then reduce into a pub-sub ("kafka") like thing. 

@skilesare  Thoughts?

EDIT: I am not competing for the bounty( i can't). But this is really a fascinating concept to link it into the SBT (soul based tokens)  by Vitalik et al

EDIT 2: A couple of screenshots (more to come)... The Help is written in unconventional first-person style exposing the philosophy

![YetiWebAppHome|690x388](upload://uGDfgzmpAKi4zb1yij2WtXqo9Yf.jpeg)
![YetiWebAppHelp|690x388](upload://wVAfeZS4inWDMsaqKax3GsXKsbX.jpeg)

-------------------------

skilesare | 2022-06-10 06:49:16 UTC | #19

This is very cool. 😎

-------------------------

skilesare | 2022-06-10 06:49:36 UTC | #20

A pub sub think here would be very interesting!

-------------------------

mparikh | 2022-06-10 07:00:17 UTC | #21

One of the things is the caller-pays model. 

Certain functions (i.e my-contact-list) could be free; but certain other functions (assuming I was a genius ; which I am NOT; my-NFT-holdings-as-percent) could be called by others on paying some cycles. 

I am baking this into the UI

-------------------------

mparikh | 2022-06-10 07:28:57 UTC | #22

While on the topic of pub-sub, the other use-case is:

   In multi-sig scenario, 
     Assuming all principals have their own wallets,  
        how to notify principals of needing 
               accepting a proposal 
                   prior to signing the proposal

    If it just shows up in their list, it could be chaos (unless there is payment associated with putting it in their list). Also accepting a proposal should likely involve payment.

-------------------------

JaMarco | 2022-06-10 08:07:44 UTC | #23

[quote="skilesare, post:4, topic:11282"]
An external wallet like plug would access this wallet by giving the plug principal access rights and then routing requests through the wallet canister.
[/quote]

What would an example usecase of this be?

-------------------------

skilesare | 2022-06-10 08:32:40 UTC | #24

 Multi-sig where 2 of 3 members of a board must approve a transaction of tokens to another account.

-------------------------

mparikh | 2022-06-10 08:35:39 UTC | #25

Scenario Setup:

Two Souls

 A. Needing to calculate USD value of spawned ICP as a result of merging maturity of a neuron.

B. Providing the service of calculating this USD value by tracking value of ICP at relevant time interval.

Soul A knows about Soul B service and asks permission to call SoulB' s service for a price; passing the principal.

SoulB accepts and Service is enabled for Soul A.

SoulA call the requested service and gets a total value of the icp spawned to be reported to tax authority.

-------------------------

JaMarco | 2022-06-10 09:46:10 UTC | #26

So the 3 board members would be owners of the same onchain wallet (by adding their principals to the onchain wallet's owner list), and when they create and sign a multisig transaction the onchain wallet would use call_raw to make a function call to the plug wallet that initiates the token transaction? How does the onchain wallet have access to make that call? Even if you give the onchain wallet the plug wallets principal, dont you still need a password or something?

-------------------------

skilesare | 2022-06-10 15:38:09 UTC | #27

[quote="JaMarco, post:26, topic:11282"]
onchain wallet would use call_raw to make a function call to the plug wallet that initiates the token transaction?
[/quote]

No, they would call the canister directly. The canister would own the tokens. Plug would.onky be used by the users to approve. It wouldn't hold any tokens.

-------------------------

JaMarco | 2022-06-10 21:43:40 UTC | #28

Oh, so the wallet owners would be the plug principals. @mparikh brought this up but how would the plug wallets get notified to sign a multisig proposal?

-------------------------

skilesare | 2022-06-11 04:27:04 UTC | #29

That is a bit of a different problem for an organization to solve. Ideally the person making the proposal would get a link and notify the other signers by email/msg to go and approve/reject. You could script this out to auto notify as well similar to how the NNS telegram bot works.yoi would need an endpoint to list open proposals.

-------------------------

coin_master | 2022-06-11 06:02:45 UTC | #30

Is anyone working on this bounty yet?

-------------------------

mparikh | 2022-06-11 06:31:00 UTC | #31

So this turns out to be quite interesting. The pending proposals is a view from a signing principal.  As noted in the UI, the signing principal may have pending proposals from different requesting principals. The signer can sign multiple proposals at the same time.

Two main questions:
      (a) how does the signer get the proposal to be signed in the first place and how does the signer actually sign
                 i propose a pub-sub mechanism similar to kafka; except that internal storage occurs within the signing canister. This solves the issues of malicious canisters making the calling canister wait forever.  
      (b) how does the signer verify plain text of the proposal against what the proposal actually does
Acttually insert the  proposed  payload into the proposal  

![Proposals-Pending|690x388](upload://huTiP0wiscRtQ2ieOO72Zva1wF.jpeg)

EDIT : This means a pull from the signing canisters (heartbeat) and storing watermarks ala kafka consumer.
EDIT 2: The Voted-On proposals will go through a similar reasoning establishing the need and use-case for pub-sub

-------------------------

mparikh | 2022-06-11 06:22:25 UTC | #32

I don't think anyone is working on this yet. However it is a pretty interesting and ambitious project. If done correctly, this can be very influential. It does require a distributed pub-sub mechanism

-------------------------

coin_master | 2022-06-11 06:35:24 UTC | #33

Yes it looks challenging indeed, but I would like to give it a go, I could also use some help on the way.
I will wait for a confirmation from @skilesare

-------------------------

mparikh | 2022-06-11 06:51:33 UTC | #34

If you don't mind, as suggest in this post by @skilesare , let's iron out the major architectural issues and roadmap ahead of time. 

I am trying to reason it out through the UI and what would we need to build out the backend. That pub-sub is non-trivial; but absolutely critical as many are facing the same issue... what to do about buggy/malicious canisters.

I got a lot out of the questions asked by @JaMarco and answered by @skilesare .

EDIT : For example, we could do away with multi-sig for the first version.

-------------------------

JaMarco | 2022-06-11 07:03:03 UTC | #35

Well I was in the process of understanding the all the requirements with the intent on working on it.

-------------------------

mparikh | 2022-06-11 07:12:32 UTC | #36

cool ! We have a team. Actually this work could use a grant. I know dfinity is matching this; but this is more substantial.  @diegop  @skilesare your opinion?

-------------------------

skilesare | 2022-06-11 07:15:20 UTC | #37

@jorgenbuilder was working on it, but is currently distracted by Supernova.  We should check with him about his status, but I think if others are ready to work on it then we could figure something out.

@mparikh. Can you explain the pub sub a bit?  I think we're fairly safe with doing synchronous calls as one can be responsible for vetting the called canisters themselves.  If it is safe to have sync calls from plug it should be safe to do so from here.  Unless I'm missing something!

Pub Sub would be interesting for sure, but I'm not sure it is required.

-------------------------

mparikh | 2022-06-11 07:17:37 UTC | #38

The voted-on proposal is also the view of the signer. It turns out that this view requires a "roundtrip" back to the calling canister... also accomplished through pub-sub. However here the eventual disposition of the proposal is also recorded...therefore the data structure in pub-sub would need, amongst other things, a witness (in context of a merkel tree). 
![Proposals-Voted|690x388](upload://uFkN86ZwuBh69FEkz0OghUUsSej.jpeg)

-------------------------

mparikh | 2022-06-11 08:06:19 UTC | #39

Here's the background and reasoning about the pub-sub. This is going to be a W(all)OfT(ext). 

But the main reason that we need a pub-sub is because of my reading of this spec:
 
//calls the function and either executes the function or creates a proposal to execute the function;
    call(principal: Principal, function: Text, data: Blob) -> async CallResult;

As I mentioned before, this function could await for a non-trivial (1 day?) time-frame because in a multi-sig scenario you would need a majority of principals to sign…if all principals need to sign on a manual basis, it could take a while. How/When would you return the value?  My reading of this specification could be wrong. 

A secondary point is to automate the notifying of the proposal to be voted on. Essentially we are polling on this from a pub-sub standpoint; except that we are doing in all in context of IC.  

The other stuff is more visionary. Essentially I want to turn the narrative of cycle-wallets on it's head to become a "digital twin" of a soul/person. I want this "wallet" to represent me in the digital world. 

In the condensed version, I want the ability  for this canister to hold my tokens, my nfts. But in addition, I want to publish services under my control that others could find to be useful to call (my rolodex,my pics etc). I want to develop my reputation on-line in a provable fashion; so that others can trust my reputation. I want to participate in group economic activities. 

In this context, I want to be a signer to multiple called canisters; each one of them doing a myriad of different things. In this world, point-to-point connectivity is not scalable, imo. Imagine a world in which signing a proposal to add a principal as a signer to a multi-sig wallet is only one of many other use cases. 

I can expand on anything required.

EDIT: The best way to negate/rebut the need of pub-sub is to go point-wise and see whether these features are actually required or not (as mentioned in the UI/ and this WOT) and if they are required, how is that envisaged to work. For example, @skilesare brings up an good point of communicating out-of-channel on which proposals to vote on (email, bot etc).

-------------------------

coin_master | 2022-06-11 07:51:26 UTC | #40

It's fine, I just didn't see any one expressed their intent to work on it.
I can be your fallback if you decided not to take it, or we can team up, either ways it's fine by me.
@mparikh your UI frames actually helping visualize how this could work and laying the foundation for the architecture, thanks for that.

-------------------------

coin_master | 2022-06-11 07:54:58 UTC | #41

I have worked on a reimplementation of the [Basic Dao](https://github.com/dfinity/examples/tree/master/motoko/basic_dao) in typescript which gave me a good idea of some of similar functionality needed for this wallet.

-------------------------

mparikh | 2022-06-11 07:56:06 UTC | #42

I think that a team will be much better. I am really amazed as to how the questions and answers are enriching my understanding and  I hope, through my UI, I am able to externalize the understanding.

-------------------------

mparikh | 2022-06-11 07:56:40 UTC | #43

nice! adding more characters

-------------------------

JaMarco | 2022-06-11 08:08:32 UTC | #44

I was planning on applying to work on it alone but if the finalized spec requires a ton of work maybe a team up would be a good idea.

-------------------------

mparikh | 2022-06-11 08:18:04 UTC | #45

I have a different perspective on this. I believe that everyone brings something unique into the discussion. When one works as a part of the team to make up the spec as we go along, we are implicitly making the pie bigger. If the team agrees to the vision of the bigger pie, then it is a win-win for everyone. As @skilesare has mentioned wisely in his intro

[quote="skilesare, post:2, topic:11282"]
This one needs a lot of oversight and comments. Feel free to apply your best software architecture skills and criticize/improve liberally. We need this to be a robust tool for the community.
[/quote]

-------------------------

jzxchiang | 2022-06-12 18:10:56 UTC | #46

This is probably a dumb question, but does an on-chain wallet only make sense for multisig, or is there a reason one would want an on-chain wallet owned and operated on by a single principal?

-------------------------

skilesare | 2022-06-12 20:49:02 UTC | #47

My favorite use case is giving services access to request data in your stead.  Imagine a subscription canister that you authorize to pay a content provider a monthly fee. You could give that canister rights to call a transfer function as you. If it is a secure co tract you can trust it won't cheat.

-------------------------

jorgenbuilder | 2022-06-13 17:11:47 UTC | #48

Don't let me hold this up. Currently focused elsewhere for the next couple weeks.

-------------------------

coin_master | 2022-06-14 09:27:55 UTC | #49

How would you like to go about the implementation of this?
@skilesare Since more than one person would be involved is there a chance to get a grant from dfinity?

-------------------------

skilesare | 2022-06-14 13:00:34 UTC | #50

I will be back from vacation on Monday and adresses it more directly.I say we get the basics down for an mvp to satisfy the bounty and then make an appli a for a more formal grant for the bells and whistles.

-------------------------

coin_master | 2022-06-15 04:36:17 UTC | #51

@JaMarco do you want to take a stab at this one?

-------------------------

JaMarco | 2022-06-15 17:15:47 UTC | #52

Let's do it

20 characters

-------------------------

coin_master | 2022-06-15 18:09:53 UTC | #53

Let's do it then!
I will DM you to arrange.

-------------------------

mparikh | 2022-06-15 18:28:21 UTC | #54

@JaMarco @coin_master Great to see team work! [EDIT] please go over what is feasible for this bounty (MVP) and what should be left for a grant. Write down a alternate proposal for the Bounty to see what it would look like; paying particular attention to methods/functions that  are feasible vs what is not.

-------------------------

coin_master | 2022-06-16 03:35:02 UTC | #55

Myself and @JaMarco will be working together on this bounty and will consult @mparikh on the way.

You can track the progress here
https://github.com/tarek-eg/motoko_wallet

-------------------------

mparikh | 2022-06-16 04:37:40 UTC | #56

You are, of course, free to work on this anyway you see fit. 

However there is a process to follow (as mentioned in the first top post in this topic) to be assigned the bounty and then eventually awarded the bounty. The process is setup to help not hinder.

-------------------------

coin_master | 2022-06-16 04:55:12 UTC | #57

Yes thanks for reminding me.
I will address them after discussion with @JaMarco

-------------------------

coin_master | 2022-06-16 06:06:01 UTC | #58

@skilesare I would prefer to serve assets through the http_request function rather than using the asset cansier, but I don't know how to use it with dfx deploy pipeline.
Basically how to build and upload the assets everytime I run dfx deploy.
Is there an example somewhere?

Edit:
I found this, but I could use a better example 
https://github.com/ocluf/embedded-frontend-canister

-------------------------

skilesare | 2022-06-16 07:00:49 UTC | #59

Yes…I have a good bit of this code around. Next week I’ll get it organized for you.

-------------------------

coin_master | 2022-06-24 17:26:42 UTC | #60

Unfortunately I got occupied and won't be able to work on this bounty for a while.
I could get back to it later if it's still available.

-------------------------

erikblues | 2022-07-28 09:22:28 UTC | #61

Improvement suggestions:
* This API-list should include an endpoint to query the wallet's balance history.

Why:
* The ability to verify balances and verify balance-history has been a core part of crypto and any form of banking. It is how users verify that no funds were lost, see what happened, and therefore it generates trust in the technology.
* It is a mandatory feature for any form of portfolio tracking, not only for the purpose of basic accounting but also for tax-purposes. 
* Personally, I would never put large amounts in places that don't offer easy way to track the history of the portfolio, most people feel the same way.

Format:
- This should be a single endpoint, which when queried returns all balance-altering transactions that happened so far (all dates, all currencies).
- Optional: include options to sort by currency-symbol and timestamp start/end.
- Output format in JSON is mandatory, additional CSV format is optional but highly recommended for the average user.
- Required data in output:
- - Sequence# (number identifying the transaction sequence/order: important for when multiple transactions happen at the same timestamp (second/millisecond).
- - Timestamp: in UTC format.
- - Symbol (ICP, BTC, etc)
- - Amount (amount of balance change of that transaction, positive or negative).
- - Fee (how much was paid in fees for that transaction)
- - Balance (resulting balance in that symbol after the transaction)

Example:
| Oder# | Timestamp | Symbol | Amount | Fee | Balance |
|---|---|---|---|---|---|
| 1 | 2022-06-01 13:24 | ICP    | 100    | 1      | 100     |
| 2 | 2022-06-01 13:24 | BTC    | 1 | 0.0001 | 1  |
| 3 | 2022-...         | ICP    | 10  | 0.01   | 110     |
| 4 | 2022-...         | BTC    | 10     | 0.001  | 11      |
| 5 | 2022-...         | ICP    | -5  | 0.01   | 105  |

Note: I am not sure if the fee should be "included" in the amount or not. In the example I used the approach of having the amount be only the account affecting balance, so the total balance can be checked easier by simply adding all values in the "amount".

-------------------------

skilesare | 2022-07-19 14:19:24 UTC | #62

Great suggestion! Thanks for the contribution.

-------------------------

Iceypee | 2022-12-03 20:09:29 UTC | #63

Hey @skilesare Is this bounty still open? I actually found a bug?/flaw? in the way ICP was transferred on many dapps such that if you refresh the page on any of the dapps on IC that recieve ICP, the ICP goes into the block abyss and the transaction is never recorded since the page was refreshed and you have to rescan every block to find the money transaction.

i.e. in psuedo code on a frontend interface
block = plug.sendICP()
//-->lets say you refresh here while it is waiting
dapp.check_Block_And_Mint_if_ICP_block_states_transfer_was_enough(block)

Then if you refresh in the middle, you dont get your nft or you dont trade your tokens, etc. 

So I wrote a wallet canister that essentially would allow people to approve send their icp. That way, we can send icp and check states at the same time from a dapp canister. And also, it bypasses using wrapped icp in some cases where you might want an approve function. This bounty seems to expand nicely on my initial work seamlessly so I'd like to try a hand at it.

Here's the code I've written so far. Its also got some of the stuff like default account(), cycle_balance(), and call() already. 
Here's the code https://github.com/professionalGithub99/relay_wallet/blob/main/src/relay_wallet_backend/Wallet.mo 
I've written some test for the approval and transfer with some tests here. 
https://github.com/professionalGithub99/relay_wallet/blob/main/test/testing.test.ts
I'll update documentation/README later so anyone can test it. For now I you'll have to trust im not writing chicken scratch lol. 



Also, I'd like to propose removing some of the multisig stuff native to the wallet and have something called a keymanager in another canister to decide what to sign.

Something similar to ERC725 https://docs.lukso.tech/standards/lsp-background/erc725/. Regardless, that way you can have many forms of governance and all the wallet sees is the final signature

-------------------------

skilesare | 2022-12-03 20:51:05 UTC | #64

Yes it is open! I think separating out the key manager is a good idea. We are actually close to finishing the axon bounty that would let anyone set up a multisig that could call the wallet through that scheme and ask it to use call raw to call another contract.  In fact the axon canister could be merged with this functionality to make it a multisig wallet....but having it work as a separate entity makes sense as well.

-------------------------

Iceypee | 2022-12-03 21:13:04 UTC | #65

Ooh okay sounds good then, I will take it on this bounty with your approval. I'll work on a custom multisig canister as well just for the sake of this bounty but I like the sound of integrating/merging the axon canister.

-------------------------

skilesare | 2022-12-03 21:51:14 UTC | #66

It is yours! If you can make it a configurable library(as much as possible with motoko) it will make integration easier. Ideally there are lots of services that might eat to issue personal canisters that need wallet like functions.

-------------------------

pramitgaha | 2023-04-06 03:51:30 UTC | #67

Is this bounty only for motoko program?

-------------------------

skilesare | 2023-04-06 21:57:03 UTC | #68

This one is just for motoko at the moment.

-------------------------

skilesare | 2023-05-12 18:04:01 UTC | #69

This bounty has been retired as Axon does most of this and/or could with a few UI updates.

-------------------------


Roman | 2022-05-23 09:52:21 UTC | #314

[quote="dieter.sommer, post:312, topic:6147"]
We can, following legal practice, only use public communication channels like press releases, forum posts, Twitter, blogs etc. to announce features.
[/quote]

Very interesting ! Thank you for having let me know !

-------------------------

Yue | 2022-05-23 09:42:05 UTC | #315

It's an honor to let you parti cipate in the reply. Thank you. As you know, the software here is not allowed. :sweat_smile:

-------------------------

Yue | 2022-05-23 09:46:16 UTC | #316

In fact, he has told you the correct answer. The rocket is ready to take off.

-------------------------

CatPirate | 2022-05-23 21:12:29 UTC | #317



If a subnet hosts BTC mainnet, does it become a BTC node?

-------------------------

jzxchiang | 2022-05-24 00:56:28 UTC | #318

Is an IC subnet more like a Bitcoin full node or a lightweight node? Storing the 350+ GB of blockchain data as a full node seems quite costly.

-------------------------

Maxfinity | 2022-05-24 03:21:59 UTC | #319

I think it's dine compared to the data that the IC already storing, each canister has a 300gb limit and ic nodes are data centres.

-------------------------

ielashi | 2022-05-24 14:51:38 UTC | #320

[quote="jzxchiang, post:318, topic:6147, full:true"]
Is an IC subnet more like a Bitcoin full node or a lightweight node? Storing the 350+ GB of blockchain data as a full node seems quite costly.
[/quote]

It's somewhere in between. The IC, at least for now, will not be storing all 350+ GB of Bitcoin state. Instead, it uses these blocks to compute the UTXO set, and then discards them to save space. The UTXO set takes a relatively small amount of space (~15GiB).

We do store some of the recent blocks though to allow us to:
1. Detect forks.
2. Compute the UTXO set at different confirmations.

-------------------------

dieter.sommer | 2022-05-25 07:47:06 UTC | #321

[quote="CatPirate, post:317, topic:6147, full:true"]
If a subnet hosts BTC mainnet, does it become a BTC node?
[/quote]

Short answer: No.

Long answer: It acts like a BTC node in many ways (and looks like one to the other BTC nodes) in that it connects to other BTC nodes, synchronizes with their view of the Bitcoin blockchain, sends transactions out to Bitcoin nodes, and validates blocks and transactions. However, it does not serve blocks to other nodes because we don't keep the blocks, but only the extracted UTXOs for reasons of not storing 100s of GBs. Acting completely like a full node would not be the purpose it needs to serve.

-------------------------

CatPirate | 2022-05-25 12:15:52 UTC | #323

Thank you for clarifying this.

-------------------------

ktoanlba | 2022-05-26 03:30:50 UTC | #324

@dieter.sommer I tried `bitcoin-developer-preview` but it's Regtest network.
Could i get example to sync Bitcoin testnet from my local ? I don't know how to use latest updates from `github.com/dfinity/ic/tree/master/rs/bitcoin`

Thank you so much !

-------------------------

Benjamin_Loison | 2022-05-27 08:21:57 UTC | #325

First of all, @ktoanlba, welcome to the Developer Forum!

I don't recommend you to try to sync Bitcoin testnet locally because it might take days but if you are really interested, here is how:

If you use the [Manual Setup](https://github.com/dfinity/bitcoin-developer-preview#manual-setup):

1. use `testnet=1` instead of `regtest=1` in `bitcoin.conf` as in [Setting up a local Bitcoin network](https://github.com/dfinity/bitcoin-developer-preview#setting-up-a-local-bitcoin-network)
2. use `bitcoin/adapter/tests/sample/testnet.config.json` instead of `bitcoin/adapter/tests/sample/regtest.config.json` as in [Running the IC-Bitcoin Adapter](https://github.com/dfinity/bitcoin-developer-preview#running-the-ic-bitcoin-adapter)

If you use the [Docker Setup](https://github.com/dfinity/bitcoin-developer-preview#docker-setup):

1. use `testnet=1` instead of `regtest=1` in [docker/bitcoind/conf/bitcoin.conf](https://github.com/dfinity/bitcoin-developer-preview/blob/8ba02e33a5c36ca7b279ba047ac07af3871ae2ce/docker/bitcoind/conf/bitcoin.conf#L2)
2. use `testnet` instead of `regtest` in [docker/adapter/regtest.json](https://github.com/dfinity/bitcoin-developer-preview/blob/8ba02e33a5c36ca7b279ba047ac07af3871ae2ce/docker/adapter/regtest.json#L3)

If you use testnet instead of regtest, make sure to change `Regtest` to `Testnet` in:

* [main.rs:195](https://github.com/dfinity/bitcoin-developer-preview/blob/8ba02e33a5c36ca7b279ba047ac07af3871ae2ce/examples/rust/src/main.rs#L195) if you use Rust example
* [Main.mo:35](https://github.com/dfinity/bitcoin-developer-preview/blob/8ba02e33a5c36ca7b279ba047ac07af3871ae2ce/examples/motoko/src/Main.mo#L35) if you use Motoko example

We are working on making the [bitcoin-developer-preview](https://github.com/dfinity/bitcoin-developer-preview) working with the latest updates from [github.com/dfinity/ic/tree/master/rs/bitcoin](http://github.com/dfinity/ic/tree/master/rs/bitcoin).

-------------------------

dieter.sommer | 2022-05-30 07:26:27 UTC | #326

**Update:**
One subnet on IC mainnet started syncing Bitcoin mainnet on Friday!

-------------------------

romulusp | 2022-05-30 10:45:30 UTC | #328

All the team deserve a drink or two! Dfinity Prof of Work 😉. I will drink a beer for this! Eva and the team must start working on promoting now, i hope will do a great job.

-------------------------

daijianlin | 2022-05-30 11:45:46 UTC | #329

Is there a link to see the syncing progress? :sweat_smile::sweat_smile::sweat_smile:

-------------------------

dieter.sommer | 2022-05-30 12:29:06 UTC | #330

[quote="romulusp, post:328, topic:6147, full:true"]
All the team deserve a drink or two! Dfinity Prof of Work :wink:. I will drink a beer for this! Eva and the team must start working on promoting now, i hope will do a great job.
[/quote]

First the work, then the party! ;-)

What we have seen so far from our experiments with Bitcoin testnet on IC mainnet is that we still need to improve performance, both for syncing blocks as well as for querying UTXOs. Some of those potential improvements have been clear upfront already, e.g., an efficient processing of the UTXOs in the not-yet-finalized blocks. It takes quite some time to traverse those blocks (currently 6) for every UTXO query.
Once we have a better understanding of the performance of query calls, we can decide whether to open up the API for Bitcoin testnet soon or whether we want to deploy some performance fixes before opening it up.

[quote="daijianlin, post:329, topic:6147, full:true"]
Is there a link to see the syncing progress? :sweat_smile::sweat_smile::sweat_smile:
[/quote]

The link to the graphs showing the synchronized Bitcoin block height does not work publicly AFAIK. You can have a look at the subnet that syncs Bitcoin mainnet in the Dashboard here: https://dashboard.internetcomputer.org/subnet/fuqsr-in2lc-zbcjj-ydmcw-pzq7h-4xm2z-pto4i-dcyee-5z4rz-x63ji-nae
It shows that finalization rate is going down due to ingesting blocks, via this you can see that syncing has started on Friday afternoon CEST.

As you can see, there has been lots of progress with this feature recently, but also there are still some things to address, e.g., performance.

-------------------------

mparikh | 2022-05-30 23:45:17 UTC | #331

[quote="dieter.sommer, post:330, topic:6147"]
Once we have a better understanding of the performance of query calls, we can decide whether to open up the API for Bitcoin testnet soon or
[/quote]

Typically i am a big fan of opening up APIs for testing; so that we can also learn from real life use of these APIs. This is especially true when the API's emphasized concern is performance (& not correctness or coverage). This is, of course, assuming that "with all hands on deck" you have had a few weeks of internal testing and fixing.

The  main reason to NOT open up API for testing assuming the overall correctness and coverage would be that the performance is so attrocious that it is unusable.

Curious to know if this is the overall thinking or anything else that comes to bear on this.

-------------------------

dieter.sommer | 2022-05-31 08:08:04 UTC | #332

We also want to make the API available to the public as soon as reasonably possible. This may happen shortly depending on our assessment.

-------------------------

tonynguyen | 2022-06-07 04:10:26 UTC | #334

any update? syncing finished?

-------------------------

dieter.sommer | 2022-06-09 21:11:03 UTC | #335

Progress update

We are nearing completion of the feature for a Beta launch. I would assess that we are currently between 90% and 95% complete for the Chromium / Beta launch.

The plan for the release of the Bitcoin integration feature (incl. threshold ECDSA) is as follows:
* Chromium (Beta) release in some weeks, target is late June: functionally complete implementation
  * API for Bitcoin testnet Integration available on IC mainnet for public consumption
  * Threshold ECDSA deployment with a test key that will be deleted after a Beta phase available on IC mainnet for public consumption
  * Documentation, videos, and a sample dApp on how to use the feature
* GA (general availability) release targeted at ~1-2+ months after Chromium: production-ready implementation
  * API for Bitcoin mainnet Integration available on IC mainnet for public consumption
  * Threshold ECDSA deployment with the production key that will be hosted on two large subnets on IC mainnet for public consumption (NNS as key backup subnet, another large subnet as signing subnet)
  * ckBTC canister

The Chromium (Beta) release will allow the community to build canisters based on the Bitcoin and threshold ECDSA APIs, i.e., create fully-functional integrations with Bitcoin. The GA release provides fixes towards production readiness, e.g., in the areas of performance, and enables Bitcoin mainnet and the final production threshold ECDSA key.

We are now very close to the Chromium / Beta release. Next, you find the items that are still missing for the Bitcoin part (threshold ECDSA not considered here). Many of those are small items and/or already progressed quite a bit in their implementation.
* Finalizing the API for sending transactions
* Implementing the API for transaction fees (get_current_fee_percentiles)
* Finalizing pagination support in get_utxos
* Parameterizing the cycles accounting for the feature
* Improving checkpointing performance (optional for Beta)
* Hard cap Bitcoin payloads to 4MB
* Improving finalization rate behaviour under heavy load of Bitcoin requests
* Make DoSing the Bitcoin subnet more difficult
* Updating the replica version to be shipped for the SDK release
* Writing a documentation Web page
* Recording tutorial videos

Towards the GA release, these are the major items to be fixed:
* Benchmarking
* Further performance improvements
* Security enhancement: Allowing the detection of very long forks
* Security enhancement: Move to larger subnet (potential performance implications to be assessed)
* All required integration tests completed
* Code cleanup

Hope this gives you an impression of where we stand and what we still need to work on.

-------------------------

jzxchiang | 2022-06-09 21:35:58 UTC | #336

Will the stable data structures that were developed for the BTC integration also be released as part of Beta or GA? I suspect they may come in very handy for canister developers.

-------------------------

dieter.sommer | 2022-06-10 05:29:47 UTC | #337

The StableBtreeMap is already now part of the open sourced code for BTC, there may still be some updates made to its code until the releases.

-------------------------

domwoe | 2022-06-10 13:36:52 UTC | #339

The code is here: https://github.com/dfinity/ic/tree/master/rs/stable-structures

Although I think I remember there were some open points on usage in canisters, but I might be wrong.

-------------------------

jzxchiang | 2022-06-12 18:04:42 UTC | #340

Could you clarify what you mean by "open points"? Do you mean this library is not "open" and usable by third-party canister developers?

-------------------------

domwoe | 2022-06-13 07:54:45 UTC | #341

In the Bitcoin integration, the StableBTreeMap is not used in a regular canister and I remember that there might be some gotchas if used in a regular canister. Maybe @ielashi can clarify.

-------------------------

ovictor | 2022-06-13 16:55:41 UTC | #342

Sorry for the dumb question about this code here: https://github.com/dfinity/ic/tree/master/rs/stable-structures/src

Is seems not not implemented to work it the IC_CDK stable api, it is just a trait Memory. I'm I rigth? Have anyone already used with IC stable api? This will help a lot managing the stable memory. I will check it out tonigth. 

If someone from dfinity is reading this, would be very usefull for developers have a lib and more documentation about stable memory as we have a lot of limititions today using pre and post upgrade hooks.

-------------------------

dieter.sommer | 2022-06-15 09:13:07 UTC | #343

[quote="domwoe, post:341, topic:6147, full:true"]
In the Bitcoin integration, the StableBTreeMap is not used in a regular canister and I remember that there might be some gotchas if used in a regular canister. Maybe @ielashi can clarify.
[/quote]

Indeed, the StableBTreeMap is currently designed to work with replica implementations, but can be repurposed to be used for canisters.

-------------------------

jzxchiang | 2022-06-16 01:08:41 UTC | #344

How difficult would that repurposing be?

-------------------------

dieter.sommer | 2022-06-16 06:51:03 UTC | #345

From what I know this would be rather easy, @ielashi can clarify when he is back.

-------------------------

Maxfinity | 2022-06-16 21:03:20 UTC | #346

We are working on this. Will let you know how we get on.

-------------------------

ovictor | 2022-06-17 06:54:28 UTC | #347

I did a small change and got BtreeMap to work with canister stable storage: https://github.com/victorcastro89/Ic-stable-storage

As soon as I have time I want to segment the stable storage so I can create multiple instances of btreeMap with different Max key and Value sizes so I can optimize the storage.
Do you guys thik is a good Idea to stoge images with it?  500Kbytes node size will allow 2Mb image be searched by four Keys in the Btreemap.

-------------------------

Maxfinity | 2022-06-17 15:59:01 UTC | #348

[quote="ovictor, post:347, topic:6147"]
As soon as I have time I want to segment the stable storage so I can create multiple instances of btreeMap with different Max key and Value sizes so I can optimize the storage.
[/quote]

Sounds like a good idea, the only limitation I can see is that once you allocate the stable storage memory it seems you can't deallocate and so you may want to use the write conservatively.

-------------------------

ielashi | 2022-07-07 21:35:18 UTC | #349

Hey folks, I am the author of `StableBTreeMap`. I was out the past two weeks so my apologies for being a bit late to the party.

Yes, it is absolutely possible to use `StableBTreeMap` within a canister as has already been demonstrated by @ovictor, and it was initially designed with that intent in mind.

Currently, we are prioritizing getting the bitcoin integration working over making the `StableBTreeMap` usable for canisters, but given the interest, I can create a small demo repo of how to use the `StableBTreeMap` within a canister for those who are interested.

There are some caveats here that are worth noting with using `StableBTreeMap` within a canister:

1. We didn't do any in-canister profiling to measure how many instructions are required to access an element in `StableBTreeMap` vs a standard `BTreeMap`. `StableBTreeMap` is expected to consume more instructions, but we haven't yet looked into how much more compared a standard `BTreeMap`. Depending on your use-case, this may be a factor to consider.

2. With one single stable memory, the only way to have multiple instance of `StableBTreeMap` is to allocate, say, `X` memory pages to the first `StableBTreeMap`, `Y` memory pages to the second `StableBTreeMap`, etc. This leads to developers having to allocate potentially memory than they really need, and it does put some constraints in terms of how big your `StableBTreeMap` can grow. This caveat will be addressed once the IC supports multiple memories.

There are also some changes to the API that I plan to do (e.g. support for generics), that will make the data structure easier to work with and closer to a standard `BTreeMap` in terms of its API semantics.

I'll aim to have a demo repo to share with you folks by end of next week.

Update: I created some examples that you can find [in this thread](https://forum.dfinity.org/t/stablebtreemap-in-canisters/14210).

-------------------------

ueyamamasashi | 2022-06-23 08:34:44 UTC | #350

Please excuse the rudimentary questions in advance. But can the ecdsa threshold signature of a BTC product key be performed on two subnets at the same time? Or is the BTC subnet the main one and the NNS the sub one, so that if the BTC subnet fails for some reason, the NNS can take over?

> Threshold ECDSA deployment with the production key that will be hosted on two large subnets on IC mainnet for public consumption (NNS as key backup subnet, another large subnet as signing subnet)

-------------------------

dieter.sommer | 2022-06-23 09:16:03 UTC | #351

[quote="ueyamamasashi, post:350, topic:6147"]
Please excuse the rudimentary questions in advance.
[/quote]

No need to apologize for your questions, it's a legit one. :slight_smile: 

If I understand your question correctly, you are asking whether two ECDSA signing subnets can produce ECDSA signatures at the same time, correct?

In the current setup, we envision that we have a single active ECDSA signing subnet, which will be a 34-node subnet (for the production release) that is still to be created. Let's call it A for "active" subnet. The NNS will act as a key backup subnet. Let's call it B for "backup" subnet. Under normal operation, all signing requests will be routed to the signing subnet A. B just passively holds the ECDSA private key for reasons of backup (key availability).

Let's assume that one or a few nodes in subnet A fail, which is the likely failure scenario. Then A can still continue producing threshold ECDSA signatures as our protocol can handle failed nodes. Assume the case of A failing completely. Then we would currently likely not switch signing to B (the NNS) as threshold ECDSA is very heavy on CPU and this could negatively affect the NNS. We would either repair A or deploy a new signing subnet A' and recover the threshold ECDSA private key from B (NNS) to A or A'.

The approach we have is largely compatible with having multiple active signing subnets, if this is required in the future for scaling out. In order to deploy this functionality, we would mainly need to implement deterministic load balancing on the message routing layer to load balance the signing requests to multiple signing subnets.

Hope that answers your question about multiple signing subnets.

-------------------------

ueyamamasashi | 2022-06-23 11:07:57 UTC | #352

Thank you for your very clear explanation.
One more question.

> The NNS will act as a key backup subnet.

Backup means that you have the private key in its complete, undistributed form even if it is encrypted. If that is correct, is there any danger of it being lost or rewritten? If the best security for this INTEGRATION is to not have it read as a private key with secret dispersion by chain key technology, wouldn't it be dangerous to have the private key somewhere in its complete form, whether it is a backup or in NNS? I am sure you have prepared considerable security, but what is the basis for being okay with that?

-------------------------

dieter.sommer | 2022-06-23 11:31:53 UTC | #353

[quote="ueyamamasashi, post:352, topic:6147"]
Backup means that you have the private key in its complete, undistributed form even if it is encrypted. If that is correct, is there any danger of it being lost or rewritten?
[/quote]

No, any threshold ECDSA key is always available in secret-shared form across all replicas of the respective subnet. Threshold ECDSA keys are never available in reconstructed form, not during generation, signing, or moving to another subnet.

When a threshold ECDSA key is available in secret-shared form on one subnet, it can be re-shared to another subnet. That is done by computing ECDSA dealings encrypted for the target replicas, providing those to the target replicas, and computing the secret shares from those.

For our production deployment, we will first generate the t-ECDSA key on the NNS subnet and then re-share it to a 34-node subnet that is generated from 34 newly-provisioned nodes as part of this. Then the signing capability is enabled only on the new subnet. That gives us the desired target situation of one active signing subnet and one "backup" subnet. On each of the subnets, they same key will be available using a different secret-shared representation.

Hope that clarifies the backup question you clears up your doubts w.r.t. security of the envisioned scheme for key management.

-------------------------

ueyamamasashi | 2022-06-23 11:45:03 UTC | #354

Great!

I understood very well. Amazing.

-------------------------

LightningLad91 | 2022-06-23 13:48:52 UTC | #355

[quote="dieter.sommer, post:353, topic:6147"]
Threshold ECDSA keys are never available in reconstructed form, not during generation, signing, or moving to another subnet.
[/quote]

Sorry for the random comment. I just wanted to say that I think NIDKG and threshold cryptography is the coolest thing about the Internet Computer. So powerful. Probably under-appreciated by most in the broader community.

-------------------------

JaMarco | 2022-06-24 02:06:54 UTC | #356

Speaking of which I saw an old video the other day with founders of other L1s speaking on why they "stayed away" from the core cryptography  that powers DKG/TS, saying that it is unproven/requires weaker security assumptions. I would like to know what their updated opinion on that topic is. https://www.youtube.com/watch?v=h2pONw0eTTk&t=1413s

-------------------------

Maxfinity | 2022-06-23 18:05:05 UTC | #357

Zcash uses a trusted setup for its cryptography. 
Ethereum is using BLS for their Beacon Chain afaik. Seems they have come round to the idea of using BLS.

-------------------------

CatPirate | 2022-06-24 07:59:00 UTC | #358

So there is a risk of losing keys forever no matter how small the chances of it happening are


[quote="dieter.sommer, post:351, topic:6147"]
Assume the case of A failing completely. Then we would currently likely not switch signing to B (the NNS) as threshold ECDSA is very heavy on CPU and this could negatively affect the NNS. We would either repair A or deploy a new signing subnet A’ and recover the threshold ECDSA private key from B (NNS) to A or A’.
[/quote]

-------------------------

Manu | 2022-06-24 08:16:16 UTC | #359

They are not really talking about DKG / threshold signatures, but rather about BLS signatures and the bilinear pairings with gap Diffie–Hellman assumptions underlying it. As Dom pointed out in the video, BLS and pairings stem from 2001 (https://www.iacr.org/archive/asiacrypt2001/22480516.pdf), and already in 2016 bilinear pairings were widely used in cryptography. Today (as @Maxfinity also points) out Ethereum's beacon chain will use BLS signatures and many other blockchain projects do too.

-------------------------

LightningLad91 | 2022-06-24 11:10:04 UTC | #360

I think we'd have major issues across the board if the system subnet (NNS) had a catastrophic failure like that.

-------------------------

CatPirate | 2022-06-24 11:32:52 UTC | #361

Of course NNS is the single point of failure for the whole computer. My question was if it was possible or not.

Also can someone please tell me how many nodes of the subnets have to be malicious to do any harm in this context. And, when is DFINITY planning to finish developing the Periodic node shuffling feature

-------------------------

Severin | 2022-06-24 11:48:50 UTC | #362

[quote="CatPirate, post:361, topic:6147"]
Also can someone please tell me how many nodes of the subnets have to be malicious to do any harm in this context.
[/quote]

The IC is generally built on the assumption of 2/3 of the nodes being legitimate. From what I gathered in discussions a malicious amount of >1/3 but <2/3 can only stall the subnet, to be actively destructive there would have to be >2/3 malicious nodes. For comparison: in BTC, the threshold for both (stalling and destructive action) is at 1/2.

-------------------------

LightningLad91 | 2022-06-24 12:07:20 UTC | #363

[quote="CatPirate, post:361, topic:6147"]
My question was if it was possible or not.
[/quote]

Understood. I can't think of a single system that has managed to 100% eliminate the risk of losing a key. From a key management perspective I'm pretty impressed with what they're doing. It seems pretty resilient and will only get better with time.

-------------------------

LightningLad91 | 2022-06-24 12:17:27 UTC | #364

[quote="Severin, post:362, topic:6147"]
From what I gathered in discussions a malicious amount of >1/3 but <2/3 can only stall the subnet, to be actively destructive there would have to be >2/3 malicious nodes.
[/quote]

Is this the same for the ECDSA subnet? IIRC there was a community conversation last year where one of the cryptographers at Dfinity explained that only 1/3 malicious nodes were needed, and that is why the subnet was going to have a node count equal to that of the system subnet.

Edit: It was Victor Shoup; here is a link to his presentation. There may be more explanation during the Q&A at the end but I couldn't find it. https://youtu.be/MulbKPwv6_s?list=PLuhDt1vhGcrez-f3I0_hvbwGZHZzkZ7Ng&t=1237

Edit 2: I just realized there is an updated ECDSA Threshold video from last month. In this one it sounds like the threshold is higher than was originally planned. I would definitely appreciate any clarification you can provide @dieter.sommer  https://youtu.be/stHaou90XiM?t=958

Also, thank you for uploading the latest video. I think these are wonderful resources for those of us who are more visual learners.

-------------------------

yvonneanne | 2022-06-24 12:01:21 UTC | #365

DFINITY is focussing on delivering SNS and BTC integration at the moment. Afaik, no design or implementation plan for automatic periodic reshuffling of nodes exists yet.

-------------------------

Severin | 2022-06-24 12:02:13 UTC | #366

[quote="LightningLad91, post:364, topic:6147"]
Is this the same for the ECDSA subnet?
[/quote]

Good point, I'm not actually sure about that. I'll let @dieter.sommer answer that as I'm now too far in uncertain territory :smile:

-------------------------

dieter.sommer | 2022-06-27 11:55:53 UTC | #367

[quote="yvonneanne, post:365, topic:6147"]
Afaik, no design or implementation plan for automatic periodic reshuffling of nodes exists yet.
[/quote]

This also reflects my knowledge about this. There have been discussions on node rotation, but no concrete design for it yet.

[quote="CatPirate, post:358, topic:6147"]
So there is a risk of losing keys forever no matter how small the chances of it happening are
[/quote]

In every system you have a residual risk of a secret key getting lost. One can only reduce it to an as-low level as reasonably possible. With our approach of having the key secret shared on two large subnets, I think we have pretty good resilience against disasters.

-------------------------

dieter.sommer | 2022-07-01 06:50:36 UTC | #368

**Update**

The Bitcoin feature is code complete from a replica perspective for the upcoming Beta / Chromium release. We are currently working on finishing an example dApp to showcase the feature and the feature documentation.

Threshold ECSDA, a crucial dependency for the Bitcoin integration, is about to be completed for the Beta / Chromium release as well.

Things are nearing completion, we will keep you posted on progress!

Stay tuned! :slight_smile:

Edit: Just to clarify things, with "Bitcoin feature" above I meant the technical integration of the IC stack with the Bitcoin network, i.e., ingesting Bitcoin blocks, validating them, processing the UTXOs contained therein, and serving UTXOs to canisters as well as submitting Bitcoin transactions to the Bitcoin network. Threshold ECDSAhas been considered as a separate feature in that post that is also very close to being completed.
Sometimes, when we speak of "Bitcoin integration" or the Bitcoin feature" in public, we refer to the union of this technical integration of the IC stack with Bitcoin and threshold ECDSA. Just to clarify so that everyone understands the same thing here.

-------------------------

ielashi | 2022-06-30 12:11:43 UTC | #369

And to add to @dieter.sommer's announcement, here's an [updated demo](https://github.com/ielashi/bitcoin-integration-demo) that showcases the various Bitcoin APIs.

The upgraded demo supports the following endpoints:

* `get_balance` to get the balance of a Bitcoin address.
* `get_utxos` to get the UTXOs of a Bitcoin address, including pagination support for addresses that have a very large number of UTXOs.
* `get_current_fee_percentiles` to get the 100 fee percentiles over the last 10k transactions for fee estimates.
* `send_transaction` for sending signed transactions to the bitcoin network.

This demo is a very bare-bones demo to demonstrate the raw API. A more fledged demo that showcases how canisters can generate bitcoin addresses and sign transactions will, as @dieter.sommer  already mentioned, be released imminently,

-------------------------

Fatalerror | 2022-07-04 08:37:37 UTC | #370

Any news about the date ?

-------------------------

spnrapp | 2022-07-12 19:04:34 UTC | #371

Is it possible to get the status of transactions given their txid? We find it quite limiting that only "unspent" transaction outputs can be queried. It is equally important to know if some previous outgoing transactions from a canister are indeed included in the blockchain (whether they are spent or unspent is irrelevant, but if they are later spent by the receiver, they can no longer be queried through get_utxos).

-------------------------

Benjamin_Loison | 2022-07-12 23:07:07 UTC | #372

[quote="spnrapp, post:371, topic:6147, full:true"]
Is it possible to get the status of transactions given their txid? We find it quite limiting that only "unspent" transaction outputs can be queried. It is equally important to know if some previous outgoing transactions from a canister are indeed included in the blockchain (whether they are spent or unspent is irrelevant, but if they are later spent by the receiver, they can no longer be queried through get_utxos).
[/quote]

The [current management canister endpoints related to Bitcoin](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin-api) don't make it possible to get for sure the status of any arbitrary transaction given their transaction ids (more precisely those that your canister haven't sent). However when using the [bitcoin_send_transaction](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_send_transaction) endpoint, it means that you know the transaction (UTXOs used etc... and thus the transaction id). **So you are able**
> **to know [for sure] if some previous outgoing transactions from [your] canister are indeed included in the blockchain**

Indeed by using [bitcoin_get_utxos](https://internetcomputer.org/docs/current/references/ic-interface-spec/#ic-bitcoin_get_utxos) you can retrieve the UTXOs that you still own according to the provided number of confirmations, after having sent your transaction that will consume some of them once it got included in the blockchain.
As UTXOs are uniquely identified by their transaction id and index of the transaction output, because your canister is the only entity being able to sign transactions using the UTXOs held by your canister and because Bitcoin transactions are atomic, if none of the inputs were used in another broadcasted transaction by using `bitcoin_send_transaction` and if you haven't updated your transaction by using [BIP-125 Replace-by-fee](https://github.com/bitcoin/bips/blob/master/bip-0125.mediawiki), then if you still hold any UTXOs spent, according to a given number of confirmations, by the just sent transaction, it means that the transaction isn't yet included in the blockchain, according to this number of confirmations.

So there isn't any need to retrieve the UTXOs of any recipient address.

**Example:**

I. Your canister holds two UTXOs on the Bitcoin address `maaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa` (you can call `bitcoin_get_utxos` to retrieve this information):

- Transaction id: `0000000000000000000000000000000000000000000000000000000000000000`
Index of the to-be-used transaction output: `0`
Value: `1` BTC
- Transaction id: `1111111111111111111111111111111111111111111111111111111111111111`
Index of the to-be-used transaction output: `0`
Value: `2` BTC

II. Your canister builds the following transaction (of id `3333333333333333333333333333333333333333333333333333333333333333`), which sends 2.5 BTC to `mbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb` and sends this transaction to the Bitcoin network by using the `bitcoin_send_transaction` endpoint:

Inputs:

- Transaction id: `0000000000000000000000000000000000000000000000000000000000000000`
Index of the transaction output: `0`
Value: `1` BTC
- Transaction id: `1111111111111111111111111111111111111111111111111111111111111111`
Index of the transaction output: `0`
Value: `2` BTC

Outputs:

1. Address: `mbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb`
Value: `2.5` BTC
2. Address: `maaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa`
Value: [`0.49` BTC](https://en.bitcoin.it/wiki/Miner_fees)

III. If afterwards you call `bitcoin_get_utxos`, the result can either be:

- Transaction id: `0000000000000000000000000000000000000000000000000000000000000000`
Index of the transaction output: `0`
Value: `1` BTC
- Transaction id: `1111111111111111111111111111111111111111111111111111111111111111`
Index of the transaction output: `0`
Value: `2` BTC

or:

- Transaction id: `3333333333333333333333333333333333333333333333333333333333333333`
Index of the to-be-used transaction output: `1`
Value: `0.49` BTC

According to the passed number of confirmations to `bitcoin_get_utxos`:
- In the first case, it means that your transaction isn't confirmed yet.
- In the second case, it means that your transaction got confirmed.

-------------------------

spnrapp | 2022-07-12 21:44:52 UTC | #373

Great explanation! However, when the sender itself isn't one of the receivers, it is out of luck. It could mean that we just always have to keep some dust in an address even if it is supposed to be of one time use. Not the end of world of course.

-------------------------

Benjamin_Loison | 2022-07-12 23:06:52 UTC | #374

> However, when the sender itself isn’t one of the receivers, it is out of luck.

As far as I know, **the case when the sender itself isn’t one of the receivers isn't a problem.**
In the previous example we haven't used the last `bitcoin_get_utxos` call to look for the generated UTXO our canister received. We were looking for any input of transaction spending:

Just checking whether or not any of these two UTXOs:

- Transaction id: `0000000000000000000000000000000000000000000000000000000000000000`
Index of the transaction output: `0`
Value: `1` BTC
or
- Transaction id: `1111111111111111111111111111111111111111111111111111111111111111`
Index of the transaction output: `0`
Value: `2` BTC

were spent and thus not part of your canister's UTXO set.

This sample pseudo-Motoko code may make it clearer:

```
type TransactionId = Text;

/// An unspent transaction output representation.
type Utxo = {
    transaction_id : TransactionId;
    transaction_output_number : Nat32;
};

/// A Bitcoin transaction representation.
class Transaction(...) {
    // These UTXOs will be used as the inputs.
    public let utxos : [Utxo] = // ...

    /// Returns the transaction as a byte array.
    public func toBytes() : [Nat8] {
        // ...
    };

    /// Returns the transaction id.
    public func id() : TransactionId {
        // ...
    };
};

/// Cache of pending transactions that get cleaned automatically by using `is_transaction_pending`.
let pending_transactions : HashMap.HashMap<TransactionId, Utxo> = HashMap.HashMap(0, Text.equal, Text.hash);

/// Sends a Bitcoin transaction to the Bitcoin network and adds it to the pending transactions cache.
func send_transaction() : async TransactionId {
    // ...
    // Assumes having built a new `transaction`.
    // "new" means that none of the inputs were used in another broadcasted transaction.
    let transaction_bytes : [Nat8] = transaction.toBytes();
    // Sends the Bitcoin transaction to the Bitcoin network.
    await management_canister_actor.bitcoin_send_transaction(transaction_bytes);
    // ...
    // Gets the id of the transaction.
    let transaction_id : TransactionId = transaction.id();
    // We only need to check later on if the first input got spent in order to know whether or not the whole transaction was confirmed.
    let first_input = transaction.utxos[0];
    // Adds "the sent Bitcoin transaction" to the pending transactions cache.
    pending_transactions.put(transaction_id, first_input);
    transaction_id
};

/// Returns true if the sent transaction is already included in the blockchain according to the provided `minimum_of_confirmations`, otherwise false.
/// This function assumes you passed a `transaction_id` that got obtained by using `send_transaction`.
func is_transaction_confirmed(transaction_id : TransactionId, minimum_of_confirmations : Nat32) : async Bool {
    let utxo_option : Option<Utxo> = pending_transactions.get(transaction_id);
    switch (utxo_option) {
        case (?utxo) {
            // We don't use the possibly generated UTXO back to the Bitcoin canister address.
            // We are only looking for spending of pending spending UTXOs.
            let is_utxo_spent = await is_still_owning_utxo(utxo, minimum_of_confirmations);
            if(is_utxo_spent) {
                pending_transactions.delete(transaction_id);
            };
            is_utxo_spent
        };
        case null {
            true
        };
    }
};

/// Returns true if the canister is still holding the provided `utxo` at a depth of `minimum_of_confirmations`.
func is_still_owning_utxo(utxo : Utxo, minimum_of_confirmations : Nat32) : async Bool {
    let utxos = await management_canister_actor.bitcoin_get_utxos(bitcoin_canister_address, minimum_of_confirmations);
    Option.isSome(Array.find(utxos, func(haystack_utxo) = { haystack_utxo == utxo })))
};
```

Otherwise here is another example.

**Example:**

I. Your canister holds two UTXOs on the Bitcoin address `maaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa` (you can call `bitcoin_get_utxos` to retrieve this information):

- Transaction id: `0000000000000000000000000000000000000000000000000000000000000000`
Index of the to-be-used transaction output: `0`
Value: `1` BTC
- Transaction id: `1111111111111111111111111111111111111111111111111111111111111111`
Index of the to-be-used transaction output: `0`
Value: `2` BTC

II. Your canister builds the following transaction (of id `3333333333333333333333333333333333333333333333333333333333333333`), which sends 2.9 BTC to `mbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb` and sends this transaction to the Bitcoin network by using the `bitcoin_send_transaction` endpoint:

Inputs:

- Transaction id: `0000000000000000000000000000000000000000000000000000000000000000`
Index of the transaction output: `0`
Value: `1` BTC
- Transaction id: `1111111111111111111111111111111111111111111111111111111111111111`
Index of the transaction output: `0`
Value: `2` BTC

Outputs:

1. Address: `mbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb`
Value: `2.9` BTC

   [`0.1` BTC](https://en.bitcoin.it/wiki/Miner_fees) goes to the miner.

III. If afterwards you call `bitcoin_get_utxos`, the result can either be:

- Transaction id: `0000000000000000000000000000000000000000000000000000000000000000`
Index of the transaction output: `0`
Value: `1` BTC
- Transaction id: `1111111111111111111111111111111111111111111111111111111111111111`
Index of the transaction output: `0`
Value: `2` BTC

or:

(nothing)

According to the passed number of confirmations to `bitcoin_get_utxos`:
- In the first case, it means that your transaction isn't confirmed yet.
- In the second case, it means that your transaction got confirmed.

-------------------------

spnrapp | 2022-07-12 23:48:27 UTC | #375

[quote="Benjamin_Loison, post:374, topic:6147"]
Just checking whether or not any of these two UTXOs:

* Transaction id: `0000000000000000000000000000000000000000000000000000000000000000`
Index of the transaction output: `0`
Value: `1` BTC
or
* Transaction id: `1111111111111111111111111111111111111111111111111111111111111111`
Index of the transaction output: `0`
Value: `2` BTC

were spent and thus not part of your canister’s UTXO set.
[/quote]

That is not always the case. They may disappear from your canister's UTXO set because the blockchain has re-organized.

-------------------------

ielashi | 2022-07-13 08:46:07 UTC | #376

By the blockchain re-organizing, you mean a fork overtaking the current tip? As long as you're spending UTXOs that have a sufficiently high number of confirmations, the probability of them being removed from the chain due to a fork falls to practically zero, no?

-------------------------

spnrapp | 2022-07-13 17:56:28 UTC | #377

That of course works, but is perhaps not the most efficient way of building on bitcoin chain. You should be able to continue building transactions/blocks on top of the "current longest", and when that changes, you build on the "new longest", without having to wait for for high number of confirmations. It could mean that a number of previous transactions you sent were not included in the "new longest",  but you should always deal with that anyway, they do not pose security risk in general (since double spending is not possible by construction).

-------------------------

spnrapp | 2022-07-13 15:45:56 UTC | #378

In any case, we are happy to accept that "make yourself one of the receivers if you want to know whether a transfer-out is included in the chain" as an answer for now.

But it would be good if a more general API that can query status of arbitrary txid can be provided in the future. Thanks!

-------------------------

ielashi | 2022-07-14 12:59:01 UTC | #379

Noted, thanks for your feedback.

Having an API to query any bitcoin transaction (spent and unspent) was ruled out initially because of the storage requirements. We'd need to store 100s of GiBs of additional state.

One idea would be to support this API for only "recent" transactions (e.g. transactions from the 24 hours). Another idea would be for the canister to use the [HTTP API](https://forum.dfinity.org/t/enable-canisters-to-make-http-s-requests) to fetch this information from some external API.

We can iterate on this and figure out the best step forward as we collect more feedback.

-------------------------

Tony89 | 2022-07-14 18:55:30 UTC | #380

hi, when will we have BTC integration beta?  Where can I track it?

-------------------------

gatsby_esp | 2022-07-14 19:04:44 UTC | #381

Hi can you give us any update?

-------------------------

dieter.sommer | 2022-07-16 16:40:05 UTC | #382

**Update**

Here's an update on where we stand with the Bitcoin feature (apologies for the few responses recently, it's been too busy ;-) ):

The Bitcoin feature is code complete and we are currently finishing the documentation. On the threshold ECDSA front, we are very close to get something out to mainnet (actually, we have been out already briefly, but needed to address two issues and turn the feature off again, one in the implementation of message routing that routes the calls to the ECDSA functionality to the ECDSA-enabled signing subnet, and another one that is related to a technical issue that lead to a problem when upgrading the threshold ECDSA subnet). Hotfixes for both are out or on their way, so t-ECDSA should be on IC mainnet soon.

The release of Bitcoin integration and threshold ECDSA beta / Chromium with Bitcoin testnet integration and a test threshold ECDSA key is imminent. A release in the coming week or the one thereafter is a probable scenario if we don't hit any further unexpected issues.

-------------------------

Tony89 | 2022-07-16 16:57:52 UTC | #383

Thanks a lot for the update, have a nice weekend @dieter.sommer 🏖🙏🏻

-------------------------

Ideaseed | 2022-07-17 04:51:48 UTC | #384

Dieter, 
My gut is telling me these snags are much larger. If you pull this off the company will get its wings.

-------------------------

Sal_Paradise | 2022-07-18 15:04:08 UTC | #385

Sorry, im not sure what you mean by this?

-------------------------

Ideaseed | 2022-07-18 21:53:17 UTC | #386

What I mean : many of us are hoping the current integrity of the ICP team is beyond reproach. 

We are routing for you.

Peter

-------------------------

Fatalerror | 2022-07-22 15:36:32 UTC | #387

Any news ? There is a lot of manipulation.

-------------------------

Roman | 2022-07-24 03:40:59 UTC | #389

Here is what said Dieter 7 days ago : 

[quote="dieter.sommer, post:382, topic:6147"]
The release of Bitcoin integration and threshold ECDSA beta / Chromium with Bitcoin testnet integration and a test threshold ECDSA key is imminent. A release in the coming week or the one thereafter is a probable scenario if we don’t hit any further unexpected issues.
[/quote]

We are still "in the coming week or the one thereafter", so let us the man work. And about any potential delay, here is what said Dieter :

[quote="dieter.sommer, post:266, topic:6147"]
Features of the size and complexity as the Bitcoin integration and threshold ECDSA are of exploratory nature and many difficulties have needed to be overcome during our implementation efforts. For this reason, they are just not as plannable as regular “commodity” software development, that’s why we cannot give a definite deadline.
[/quote]

This is how works the Research, and we are talking about an unprecedented breakthrough, so, again, let us the man work. Any question of that kind deprives him and the team of a precious time to dedicate to make the integration come out faster, especially those he already answered.

-------------------------

LeeT | 2022-07-26 06:42:08 UTC | #390

The Bitcoin integration seems really promising and technically fascinating, thank you for designing/implementing!

It would be useful to be able to access the Bitcoin block height in a smart contract I'd like to write, are there any plans for this in the API? (e.g. `get_blockHeight`)

If this were event driven (e.g `onNewBlock`) it would be helpful as my intention is to create a procedure that runs every 1008 blocks (~week);  I'd prefer to do this with direct reference to the Bitcoin chain if possible.

-------------------------

THLO | 2022-07-26 17:19:30 UTC | #391

[quote="LeeT, post:390, topic:6147"]
It would be useful to be able to access the Bitcoin block height in a smart contract I’d like to write, are there any plans for this in the API? (e.g. `get_blockHeight`)
[/quote]

We internally discussed adding an endpoint that provides information about the current state of the Bitcoin blockchain, such as the current block height.
Since we want to keep the API small for the initial release, we didn't add it so far. But thanks for your comment! If the community feels that such an endpoint would be useful, we will look into extending the Bitcoin integration API.

Regarding event-driven actions, we also discussed options for notifications but we don't have anything concrete yet. In the absence of notifications, you can use the heartbeat functionality to issue requests periodically.

-------------------------

LeeT | 2022-07-28 14:56:22 UTC | #392

Thanks @THLO, will keep and eye out for it...

Another primitive/library that might be useful would be a mapping of BTC addresses to ICP addresses and vice versa. To add to the mapping (and activate their smart contract BTC), a user would have to give a signed ICP address (signed with the keys underlying the BTC address).

This would allow a contract to transfer BTC between ICP accounts and allow easier deposit and withdrawal of BTC.

How do people see ICP smart contracts managing a ledger of BTC amounts?

-------------------------

Fatalerror | 2022-07-29 15:48:28 UTC | #393

Been 2 weeks, any update?

-------------------------

Manu | 2022-07-29 16:16:54 UTC | #394

Hey everybody! Quick update: things are progressing well: the BTC feature to give access to bitcoin testnet has already been available for a while, and an experimental ECDSA test key is now also available (proposal 70114). This means that technically now canisters have all the tools to work with BTC testnet, but as said, all of this is experimental. This was demonstrated in our first public global R&D meeting ([recording](https://youtu.be/UXj26hJrmms?t=1554)).

Next week we plan to release public documentation and example code so people can really start building!

-------------------------

spnrapp | 2022-08-01 06:19:46 UTC | #395

Happy to share with everyone the first *integration* of btc testnet with a real app: https://spnr.app

Usage:
1. Send btc testnet coins to the public deposit address
2. After 3 confirmations, the app should detect the balance and prompt you to "deposit".
3. After "deposit", you will now have some shielded BTC testnet coins to spend.
4. You can either send them to a private spinner address of another person, which happens instantly.
5. Or you can send to a legacy (P2PKH) bitcoin testnet address, which will take some time for the balance to appear & be confirmed on the receiver's address.

Will appreciate your feedback and bug reports! Many thanks to the DFINITY team for implementing & enabling this awesome feature (and threshold ECDSA too)!

-------------------------

daijianlin | 2022-08-01 08:26:20 UTC | #396

I just tested, it is working really great. I received the btc almost real time using the private spinner address, see below:

![image|690x484](upload://xs7WxrFqptQiuT01TUwiBP9X4lj.jpeg)

@spnrapp Thanks for providing such a good demo for us to test. Really great and appreciate!

The Internet Computer is going to change Blockchain world which means that it will bring BTC to real app.😁

-------------------------

spnrapp | 2022-08-01 16:00:06 UTC | #397

We ran into a problem:
```
The Replica returned an error: code 5, message: "Canister kmpi4-4aaaa-aaaal-aaqba-cai trapped explicitly: Panicked at 'Transaction too large.'
```
with a signed transaction of 1246 bytes.

Isn't this too limiting? Bitcoin allows up to 100k bytes per transaction (according to [this article](https://developer.bitcoin.org/devguide/transactions.html)).

-------------------------

diegop | 2022-08-01 18:42:24 UTC | #398

[quote="spnrapp, post:397, topic:6147"]
with a signed transaction of 1246 bytes.
[/quote]

Fwiw, I have pinged folks on the BTC project to take a look.

-------------------------

PaulLiu | 2022-08-01 19:19:48 UTC | #399

That error appears to come from https://github.com/ielashi/bitcoin-integration-demo/tree/master/src/bitcoin_integration_demo. So maybe calling the actual `bitcoin_send_transaction` of the management canister would be okay.

I'm actually not sure if there is a limit implementation wise. Maybe @ielashi can better speak of this topic.

-------------------------

ielashi | 2022-08-01 19:26:13 UTC | #400

Awesome work @spnrapp! As @PaulLiu mentioned, the error you're seeing here is an error from the demo canister that I had published, which was meant to be for demo purposes only and not production use.

Instead of using that, you should instead use the management canister API directly, just like I'm doing in the source code of that example, and that API doesn't have the 1,000-byte limit.

-------------------------

spnrapp | 2022-08-01 19:37:16 UTC | #401

Thanks, @PaulLiu and @ielashi. That explains it. We misread your example code.

Does the actual API impose a limit at all? Or is it just relying on cycle fee per byte?

-------------------------

ielashi | 2022-08-01 19:39:19 UTC | #402

The API itself poses no limit. However, there is a practical limit of 2MiB, since that is the maximum size of an inter-canister request on the IC currently.

-------------------------

diegop | 2022-08-01 20:42:01 UTC | #404

Hi there,

I am removing your comment because it is off-topic

-------------------------

AkshayBuddiga | 2022-08-01 20:43:16 UTC | #405

Ok, I will paraphrase 

ICP/BTC transactions are too large and signed transactions necessary for defi don't work?

-------------------------

diegop | 2022-08-01 20:46:15 UTC | #406

[quote="AkshayBuddiga, post:405, topic:6147"]
signed transactions necessary for defi don’t work?
[/quote]

Not sure I follow. Are you referring to the thread above about signed transactions? Maybe I’m misreading something, but you can see the issue was resolved (3rd party developer accidentally misread something… something we have all done) and then dev fixed it.

-------------------------

dieter.sommer | 2022-08-02 08:00:10 UTC | #408

[quote="spnrapp, post:395, topic:6147"]
Happy to share with everyone the first *integration* of btc testnet with a real app: [https://spnr.app ](https://spnr.app)
[/quote]

This is awesome!

I recall your Supernova presentation when you showed the developer preview integration -- I was looking forward to the "real" integration already then. :-)

Great work!

-------------------------

dfisher | 2022-08-03 01:33:38 UTC | #409

Can someone familiar with Stacks (https://stacks.org/) explain how it is different (not technically, but rather practically) from the IC native integration? It seems eerily similar...

-------------------------

JaMarco | 2022-08-03 02:18:26 UTC | #410

https://forum.dfinity.org/t/direct-integration-with-bitcoin/6147/161?u=jamarco

-------------------------

JaMarco | 2022-08-03 18:34:06 UTC | #411

[quote="tonynguyen, post:233, topic:6147"]
what is the difference this integration with bitcoin on avalanche ?[Avalanche Bridge to Add Native Support for Bitcoin, Expanding Opportunities for BTC in Avalanche DeFi | by Avalanche | Avalanche | Mar, 2022 | Medium](https://medium.com/avalancheavax/avalanche-bridge-to-add-native-support-for-bitcoin-expanding-opportunities-for-btc-in-avalanche-38b2314d6e7d)
[/quote]

[quote="JaMarco, post:246, topic:6147, full:true"]
Anyone have any insight on how ICs BTC/ETH integrations are different/better/worse than these cross-chain solutions:

ThorChain: [https://docs.thorchain.org/ ](https://docs.thorchain.org/)
Algorand State Proofs: [Algorand State Proofs. Powering Blockchain Interoperability… | by Noah Grossman | Algorand | Mar, 2022 | Medium ](https://medium.com/algorand/algorand-state-proofs-707d64038e35)
Chainlink CCIP: [Cross-Chain Interoperability Protocol (CCIP) | Chainlink ](https://chain.link/cross-chain)
Cosmos IBC: [IBC Protocol | Tendermint](https://tendermint.com/ibc/)
LayerZero: [LayerZero Labs Raises $135 Million to Create Omnichain Crypto Networks | Business Wire](https://www.businesswire.com/news/home/20220330005301/en/LayerZero-Labs-Raises-135-Million-to-Create-Omnichain-Crypto-Networks)
Axelar Network: https://axelar.network/
[/quote]

This is a very solid article that answers these questions [IC&BTC Integration 02: Differences From Other Cross-chain Integrated BTC Solutions](https://qbw7d-giaaa-aaaaj-aalta-cai.ic0.app/blog/IC-BTC-Integration-02-Differences-From-Other-Cross-chain-Integrated-BTC-Solutions)

-------------------------

diegop | 2022-08-03 18:38:32 UTC | #412

FYI folks: 

Docs and sample dapps are live for the testnet:

https://forum.dfinity.org/t/btc-testnet-icp-integration-the-testnet-is-live/14675

-------------------------

Maxfinity | 2022-08-03 20:07:12 UTC | #413

Stacks, as far as I can recall, uses over-collateralisation bring BTC on chain. So every BTC on the network should be backed by an equal amount of STX. 

Practically also, I am not sure if the smart contracts can send real BTC. STX can read the BTC blockchain but it doesn't have anything like the threshold ECDSA needed to send BTC transactions, so the applications using BTC seem to be more limited to things like atomic swaps.

-------------------------

flyq | 2022-08-04 08:09:32 UTC | #414

When I test the interface **locally**, it failed:

I started the bitcoind, and:
```sh
dfx --version
dfx 0.11.1

dfx replica --enable-bitcoin --bitcoin-node 127.0.0.1:18444

~/.cache/dfinity/versions/0.11.1/icx-proxy \
    --fetch-root-key \
    --address 127.0.0.1:8000 \
    --replica http://localhost:8080

dfx canister call basic_bitcoin get_balance '("mijgLqRdTmiRVUW4aYHG5myWBmnPvXPQuU")'
Error: Failed update call.
Caused by: Failed update call.
  The Replica returned an error: code 5, message: "Canister rwlgt-iiaaa-aaaaa-aaaaa-cai trapped explicitly: Panicked at 'called `Result::unwrap()` on an `Err` value: (CanisterReject, "The bitcoin API is not enabled on this subnet.")', src/basic_bitcoin/src/bitcoin_api.rs:31:17"
```
https://internetcomputer.org/docs/current/developer-docs/updates/release-notes/#new-feature-add-additional-logging-from-bitcoin-canister-in-replica

According to `The bitcoin API is not enabled on this subnet.`, what is wrong with my startup command of dfx replica?

-------------------------

dieter.sommer | 2022-08-04 08:07:47 UTC | #415

From what I know, ThorChain is closest of all chains out there to what the IC is doing in terms of integration with other chains. It uses also a native integration where they run a full node of the target blockchain per node to do the protocol level integration which we did with an adapter and a lightweight node. They also use threshold ECDSA, but they use a scheme that has the following drawbacks in contrast to ours:
* Their protocol relies on a synchronous network assumption, which does not reflect reality of communication networks
* A dishonest node can make the signing protocol fail, while the IC protocol degrades gracefully in such a case

-------------------------

Severin | 2022-08-04 08:28:32 UTC | #416

[quote="flyq, post:414, topic:6147"]
According to `The bitcoin API is not enabled on this subnet.`, what is wrong with my startup command of dfx replica?
[/quote]

Looks like a dfx bug to me. @ericswanson is best equipped to figure this out.

@flyq, can you try two things for me, please?
1. try the same with `dfx start` instead of `dfx replica`
2. try configuring the same information through dfx.json. The syntax should be like this:
```
"defaults": {
  "bitcoin": {
    "enabled": true,
    "nodes": ["127.0.0.1:18444"]
  }
}

-------------------------

ielashi | 2022-08-04 08:40:34 UTC | #417

In addition to what @Severin mentioned, you need dfx 0.11.1-beta.2 or later. I'd suggest you look at the [sample code](https://github.com/dfinity/examples/tree/master/rust/basic_bitcoin/) to see how to set up your project.

-------------------------

flyq | 2022-08-04 08:54:27 UTC | #418

After changed from `dfx replica` to `dfx start` and added `bitcoin` to `dfx.json` config, it works. the dfx version is `0.11.1`

-------------------------

dieter.sommer | 2022-08-04 09:01:17 UTC | #419

@dfisher 
I briefly looked into Stacks to provide a response to your question, and the result is pretty underwhelming considering the current situation of Stacks.

https://docs.stacks.co/docs/understand-stacks/accounts

> Stacks accounts cannot hold bitcoins. The best way to obtain corresponding BTC balances is to derive the BTC address from the Stacks address (using [`c32check`](https://github.com/stacks-network/c32check#c32tob58-b58toc32)) and query the Bitcoin network.

https://www.hiro.so/blog/building-on-bitcoin-project-comparison
See below image:
![Stacks_comparison|489x500](upload://dHGWnsWHAa8JoATwEjUAlxproGl.png)
> Decidable language - Clarity contracts have direct visibility into Bitcoin state.(1)
> (1) *More work needed to realize the future vision. In particular, Clarity contract can't write back to Bitcoin (yet)*

If this 3rd-party information is correct, this would mean that Stacks does not have true Bitcoin smart contracts, at least not yet. And there is no information to be found on how they would do it. The main point where Bitcoin comes in is that Stacks uses Bitcoin as a base layer for securing its own chain, which means they suffer from the same finality times as Bitcoin, but at least have much greater throughout thanks to microblocks in between the anchor blocks that correspond to Bitcoin blocks. But this means major implications on how to write smart contracts as you don't have the 1s finality as on the IC, but that of Bitcoin. Their mechanism of using Bitcoin as a base layer to secure their chain gives their smart contracts visibility into the Bitcoin state, but without write access, so they can trigger actions based on what happens on Bitcoin, but that's it.

To me, this is pretty underwhelming in terms of Bitcoin DeFi, essentially, there's no true Bitcoin smart contracts at this time in Stacks, but they can only use Bitcoin information to trigger actions in the smart contracts on Stacks.

Hope that helps.

-------------------------

dfisher | 2022-08-04 17:12:16 UTC | #420

Thank you for the response. Really appreciate it. Can sigh a breath of relief!

-------------------------


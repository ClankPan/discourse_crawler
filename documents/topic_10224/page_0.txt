lara | 2022-01-11 20:27:16 UTC | #1

Hi all,

I propose to use this new thread to discuss a new proposed design for the open governance canister that can be used for implementation of the service nervous systems (SNSs).


## Objective

Similarly to how the [Network Nervous System (NNS)](https://medium.com/dfinity/the-network-nervous-system-governing-the-internet-computer-1d176605d66a) is the open tokenized governance system that controls the Internet Computer blockchain (IC), service nervous systems (SNSs) are algorithmic DAOs that will allow developers to create decentralized, token-based governance systems for their dapps.

Decentralized control and tokenization enables the introduction of new incentive systems and use cases that have the potential to set dapps apart from traditional applications. We refer to [this article](https://medium.com/dfinity/how-dapp-developers-placing-their-faith-in-total-decentralization-will-inherit-the-world-79419a3e36c9) for more background on how SNSs will empower Dapps to leverage the full potential of the IC.

**The goal of this project is to provide a first implementation of an open governance canister that will then be used to realise the service nervous systems (SNSs).**

More concretely, this release’s goal is to provide an “out of the box” governance canister implementation that

1. Can be used to realize the SNS (see next section)
2. Can be used by anyone looking to implement another kind of DAO for their dapp, either by using the governance canister and integrating it with other canisters or by just taking the governance canister code as a basis and evolving it to another kind of governance

## Background & Context with other projects

#### Relation to the original SNS design & overall approach

We presented a [first proposed SNS design](https://www.youtube.com/watch?v=L4443aaAP5A&list=PLuhDt1vhGcrez-f3I0_hvbwGZHZzkZ7Ng&index=22) in October 2021. The community’s feedback was that that SNS design was rather complex and does not leave a lot of freedom to developers to configure a DAO to their needs. Moreover, some developers mentioned that they have a particular DAO or use case in mind and are only interested in an implementation of a ledger or governance canister, which they plan to integrate with existing canisters.

The goal of SNSs is also to eventually provide open governance solutions “on the press of a button” for those who are not experienced developers themselves. This motivates that a concrete implementation and usable interfaces to deploy and upgrade SNSs are provided to the community.

To address all of these concerns, we propose the following new approach:

1. Release the different building blocks in multiple stages, such that the community can make use of intermediate deliverables (e.g., single canisters) as soon as they are ready
2. Evolve these single building blocks to arrive at a concrete implementation that can be used without engineering efforts
3. Make the concrete implementation modular and the single components configurable so that each SNS can be configured as suitable for the dapp that it governs

#### Context with other SNS projects

More concretely, we propose the following initial stages:

1. Improve the NNS ledger canister so that it can also be used for other tokens
2. **Implement a governance canister (the design presented and discussed here)**
3. Tooling and support for the deployment and upgrade of SNSs that consist of multiple canisters, including the ledger and governance canister from above (design will be presented in a separate forum thread in the coming weeks)
4. More steps towards allowing SNSs “on the press of a button”, including frontend support, support for initial token distribution etc. (less concrete, this depends on the previous steps and the feedback there)

## Proposed design for the open governance canister

#### Summary design

On a high level, the idea is to reuse only those concepts of the NNS that are relevant.
This would allow us to reuse some code from the NNS governance canister but simplify the design by omitting concepts that are only relevant in the context of the NNS.

More concretely, we propose to reuse the concepts of

* *neurons*, which facilitate stake-based voting that guarantees that voters are invested in the respective governance token and therefore incentivized to vote in the best interest of the system.
* *proposals* as the SNS should allow users to make suggestions, e.g., how to evolve the associated dapp, and for others to vote on these decisions.

As with the NNS governance, it is expected that the governance canister is deployed with an associated ledger canister, where it is determined how much stake each neuron has.

Moreover, compared to the NNS where some configurations can only be changed by canister upgrades, in this open governance canister most configurations should be defined as parameters that can easily be configured at deployment and changed by proposals. This will allow each developer and community to tweak the governance rules to their needs.

#### More design details

We next introduce some more details of the design, with a special focus on things that are different compared to the NNS governance canister.

Note that some details have a remark “if feasible in a timely manner”. We propose that we implement these features in the first implementation if the effort is not too large. Otherwise, we propose to favor an earlier release and add those features in a next iteration.

##### Proposals

In the NNS governance, proposals have both a type, determining what they will do exactly, and a topic, based on which neurons can follow other neurons in the decision making (liquid democracy).
As each SNS will have very different use cases, we propose to omit the concept of proposal topics and facilitate following based on the proposal types.

Moreover, we propose that an open governance canister supports at least the following proposals by default:

* A proposal to change the governance parameters
* A proposal to upgrade one canister, that can e.g., be used to upgrade a dapp canister
* Motion proposals that facilitate discussions in the community but do not have any immediate, automatic effect

##### Neurons

Regarding neurons, we propose:

* omitting the neuron attributes and methods that are specific to NNS use cases.
* having the following neuron attributes (with motivation):
  * (If this is feasible due to storage restrictions) omit the neurons’ ID and use the neurons’ account on the ledger canister as the identifier instead
  * (If this is feasible in a timely manner) provide an access control list for neurons that specifies which principals can perform which neuron actions. For the first version, start with a simple logic that describes two keys similarly to the controller and hot keys in the NNS governance canister. Later, provide methods that allow defining valid access control lists by governance canisters and that allow neuron holders to change the access control of their individual neurons within these valid options.
  * (As in the NNS) The amount of staked governance tokens.
  * (As in the NNS) The time when the neuron was created.
  * (As in the NNS) The neuron’s dissolve state specifying whether a neuron is dissolving, i.e., the timer when the staked tokens can be retrieved is decreasing, or non-dissolving, i.e., the time how much into the future the staked tokens can be retrieved is stopped and the neuron’s age specifying how long the neuron has been in non-dissolving state.These concepts allow incentive systems where neuron holders that commit to the system for a longer time have more say or get more rewards.
  * (As in the NNS) A neuron's followees. This allows for voting with a liquid democracy, where neurons can choose to delegate their vote to other neurons.
  * (As in the NNS) A neuron's maturity which keeps track of the rewards that a neuron has collected. This allows governance participation to be rewarded.
* the following commands for managing neurons (similar to the NNS governance, except for omitting disburse_to_neuron which has an NNS specific use case):
  * *Claiming* and *refreshing* of a neuron. This is needed to stake a neuron and then top up a neuron’s stake.
  * *Configuring* a neuron, including increasing the dissolve delay, start dissolving, and stop dissolving a neuron. This allows a neuron holder to choose the dissolve state and age of their neuron, which are explained above.
  * *Making a proposal*, *registering a vote*, and *configuring followers*, which allow a neuron to participate in governance decisions.
  * *Spawning* and *Merging Maturity*, which allows a neuron to mint the governance tokens corresponding to the rewards that it has accumulated. The former allows the neuron holder to retrieve the rewards as tokens in a new neuron with a small dissolve delay and the latter allows a neuron holder to reinvest the rewards by adding them to the neuron’s stake.
  * *Disburse* which allows a neuron holder to liquidate again the staked tokens.
  * (If this is feasible in a timely manner) *Splitting* and *merging* neurons which are convenient methods for neuron holders to organize their neurons.
* in contrast to the NNS neurons, making all neuron attributes public, including the neurons’ controllers. This simplifies the APIs and allows for more auditability.
* omitting the proposals of topic “manageNeuron” that allow multiple principals to control a neuron and the associated use cases for the neurons (e.g., in access control and voting). Instead, allow canisters to control neurons.
* making some implementation improvements along the way.

## Security

We consider this to be a security critical feature, as the upgrades of dapps and the value of associated governance tokens are at risk if there are vulnerabilities. We thus plan that both the design and implementation will be reviewed by DFINITY’s security team.

## Alternatives considered

Some different approaches that we could have taken and why we decided against them:

* We could have waited with releasing until we have the full SNS implemented. As argued above, we decided against this as it seemed to be a wish from the community to be able to use the single components as soon as possible.
* We could have decided to just reuse the NNS governance code.
We decided against this as there are some NNS specific things in the NNS governance canister that we do not need in the SNS. It also seemed to be a wish from the community to keep things as simple as possible, which supports this.
* We could have generalized the NNS governance code and then reuse it for both the NNS and the SNS.
We decided against this as NNS upgrades are security critical and have to be considered carefully. Moreover, it would take more time to generalize the NNS code, taking into account all of the NNS specific components. Therefore, we favored using a new code base for SNS as this will allow for faster feature delivery.

## Risks and mitigations

As already discussed, there are security risks involved in this project. Therefore, this project requires thorough testing and security reviews and reasoning. We mitigate the risk of unforeseen findings by involving the testing and security experts early in the process.

## Community conversation & Timeline

The NNS team is ready to work on this feature!
To get the design approved by the community, we propose the following schedule:

1. Jan 11-18th: Design discussion on this forum thread
2. Jan 18th: Community conversation about the topic
3. Jan 20th: Developer discussion on Discord
4. (a few days later): motion proposal submission proposing the above design, potentially adjusted with the feedback from Steps 1 - 3.

Looking forward to hearing your inputs on this!

-------------------------

jzxchiang | 2022-01-11 21:49:10 UTC | #2

Thanks for sharing! I have a few questions:

* Can you list out the "governance parameters" that you envision SNS proposals being allowed to change? For example, I personally think the 8 year max staking period for NNS neurons is too long for SNS; most smaller projects won't even last 2 years.

> Moreover, compared to the NNS where some configurations can only be changed by canister upgrades, in this open governance canister most configurations should be defined as parameters that can easily be configured at deployment and changed by proposals.

* Can you clarify this? In both cases, governance canisters can only be changed via proposals. Are you saying that the NNS canister can only be changed via "new replica binary" proposals that involve code changes, but here you are proposing that SNS canisters can be changed via proposals that involve no code?

* Will this SNS open governance canister be created and managed by the NNS (as a controller), as you indicated in your [talk](https://www.youtube.com/watch?v=L4443aaAP5A&list=PLuhDt1vhGcrez-f3I0_hvbwGZHZzkZ7Ng&index=23)? Or will developers need to deploy the SNS governance canister and "blackhole" it themselves?

-------------------------

lara | 2022-01-12 10:05:38 UTC | #3

Thanks for your questions @jzxchiang!

> Can you list out the “governance parameters” that you envision SNS proposals being allowed to change? For example, I personally think the 8 year max staking period for NNS neurons is too long for SNS;

I would put pretty much anything that is currently a constant as a parameter. I think if I listed them all right now, I would probably miss some of them. Would it be OK I shared them later, when we have a selection in the code? I think adding or removing them at this point will still be possible, independently of the rest of the design.
That being said, I would definitively see the max staking period as one of these parameter that should be configurable for each SNS. Also, things such as the minimum dissolve delay, the fees etc.  

 > Can you clarify this? In both cases, governance canisters can only be changed via proposals. Are you saying that the NNS canister can only be changed via “new replica binary” proposals that involve code changes, but here you are proposing that SNS canisters can be changed via proposals that involve no code?

Right, it is for sure the case that both things can only be changed by proposal. In neither of the proposals the replica binary is involved. The difference is that if we change constants, this requires a full upgrade of the governance canister, meaning that we have to stop the governance canister, upgrade the wasm, and restart the canister. So basically we do the same as when we change the actual implementation of the governance canister. 
However, the special parameters (called `NetworkEconomics` in the governance canister) are changed, then the effect of an adopted proposal is that a special method is called that just updates these parameters to the new values given in the proposal. This is in some sense less invasive and less risky. Moreover, it means that the actual wasm is not changed. 
The latter is important for SNSs as this means that different SNSs can run the same wasm (so users can e.g., verify that this is the wasm that has been "blessed by the NNS community") but still have different configurations. 

Does this clarify things? Do you have a suggestion to how I can express this better in the design proposal? 

>  Will this SNS open governance canister be created and managed by the NNS (as a controller), as you indicated in your [talk](https://www.youtube.com/watch?v=L4443aaAP5A&list=PLuhDt1vhGcrez-f3I0_hvbwGZHZzkZ7Ng&index=23)? Or will developers need to deploy the SNS governance canister and “blackhole” it themselves?

The aim of this project is just to provide an implementation of the governance canister that can be downloaded and used by interested developers. As such it does not have any fixed controller.
The questions of how an SNS can be deployed and who would then be the controller etc will be tackled in a next project (we are actively working on the design and should be able to share it in the coming weeks).

-------------------------

jzxchiang | 2022-01-12 23:46:22 UTC | #4

> Does this clarify things? Do you have a suggestion to how I can express this better in the design proposal?

Yes, this helps a lot. I totally forgot that SNS (and NNS) proposals simply describe a method that is called (along with their arguments) if a proposal passes. In the case of changing constants, I'm guessing the called method is an `install_module` or `install_wasm` type of method. In the case of changing governance parameters like you describe, the called method would be some custom `change_gov_param` method that is relatively more lightweight.

The point about running the same wasm (for verification purposes) also makes sense.

> The questions of how an SNS can be deployed and who would then be the controller etc will be tackled in a next project (we are actively working on the design and should be able to share it in the coming weeks).

Thanks, that makes sense.

-----

On a higher level, I am thinking about what types of projects can benefit immediately from SNS. I'm not convinced that the ambitious, larger-scale projects (think decentralized YouTube, decentralized Twitter, etc) will be comfortable handing over control of their project to a SNS governance canister, at least not right now.

Why? I think partially it is due to how new and untested SNS is, but another is due to the impact on development velocity. Shipping changes will take longer, as they now need to go through motion proposals, upgrade proposals, etc. Yet another is due to the fact that SNS-governed dapps must be open source (or at least should be). Otherwise, nobody would be able to propose or review dapp canister upgrades.

There are other open questions about the tooling needed to perform good governance. Where do voters communicate? Is it a forum like this or a Discord server? Where do voters vote? Will there be an SNS equivalent of nns.ic0.app or do developers need to build their own?

I think a project that meets these criteria would be a great POC to test SNS on:

* low risk (so probably not DeFi)
* quick to implement (a month or so, probably just a couple of web pages and a single backend canister)
* useful

Need to brainstorm what that would be...

-------------------------

lastmjs | 2022-01-19 15:50:10 UTC | #5

I think ICDevs and other DAOs that are trying to make decisions that aren't executed directly on chain would be good first projects. What do you think @skilesare? We could use the SNS motion proposals to come to decisions on bounties. Especially once the SNS has a default frontend, it should be incredibly simple to spin up an SNS for ICDevs, submit motion proposals, give out "tokens" to board members, and then vote.

@Arthur CycleDAO might be interested in doing something similar, @wpb same with ICPMN.

-------------------------

lastmjs | 2022-01-19 15:54:24 UTC | #6

One of my main concerns with the new design (which I think is fantastic BTW) is that it is still somewhat forcing us into a staking model with lockups and rewards. What if we just want a simple token voting SNS? No staking, no lockup periods, no voting rewards...just simple coin voting. For ICDevs I imagine that's all we'd want at least to start. Not all projects will want the "token" to accrue value and become a tradeable asset, or at least I don't think we should force everyone into that model. Forcing lockups and rewards seems to do that.

-------------------------

skilesare | 2022-01-19 15:54:33 UTC | #7

I'd love that.  We were going for that with https://icdevs.org/bounties/2021/11/01/generic-dao-fork-axon-copy.html. We don't have a token so staking doesn't really make sense.  We need a system where we can hand out votes to known-real people and we don't really want those votes to be transferable...so the token model works but doesn't quite fit.

-------------------------

jzxchiang | 2022-01-20 07:11:05 UTC | #8

My understanding from @lara's talk is that you can emulate that by setting dissolve delay to 0 for everyone and removing any age or other bonuses. These should be governance parameters that can be tweaked, I think.

-------------------------

alexa.smith | 2022-01-20 15:29:57 UTC | #9

Hey everyone, just a friendly reminder that @lara will be leading a developer discussion today on Discord at 8:00am PST. Hope you can make it!

-------------------------

lara | 2022-01-21 19:38:01 UTC | #10

Thanks for the feedback.
Yes, as @jzxchiang pointed out, some of this should be achievable by setting the parameters correctly.
For example, setting the dissolve delay required to be eligible to zero.
Also, at least long term, rewards will be optional so each SNS can decide when to burn and mint new tokens. I am not sure if it has been decided whether this feature is realised in the first version, but thinking about it, it shouldn't actually be that hard to make rewards optional.

After this feedback, I would like to at least consider including this in the first version.

-------------------------

lara | 2022-01-28 10:54:02 UTC | #11

Hi all, just an update from my side:
as promised in the first post, we plan to submit a motion proposal with the above design, now that we had the different conversations.
@diegop kindly agreed to help with this. 
In order to give the proposal enough visibility, we plan to send it early next week rather than so shortly before the weekend.

Have a great weekend and look out for the proposal next week!

-------------------------

diegop | 2022-02-01 19:32:23 UTC | #12

Update:

Proposal is live!

https://dashboard.internetcomputer.org/proposal/42626

-------------------------

lastmjs | 2022-02-01 23:41:18 UTC | #13

Big concern! How will people use this thing without a front-end supplied? Are we supposed to all create our own front-ends to even start experimenting with this? Even a simple front-end would be nice to have

-------------------------

lara | 2022-02-04 20:56:29 UTC | #14

Thanks for bringing up the concern.
Note that this particular project is just about the governance canister. 
A frontend is planned but will be done separately.
I am currently following up internally regarding when we think we can have that.

-------------------------

lastmjs | 2022-02-04 21:01:28 UTC | #15

I'm just worried no one (really it will just be much harder) will use this and try it out without a front-end. And the point of pushing things out in pieces is to get community feedback.

-------------------------

lara | 2022-02-04 21:06:57 UTC | #16

That is certainly one goal.
Another goal is also to already make the code available to developers who might want to reuse parts of this to build their own governance / DAO etc. 

But it is valuable feedback that I happily take back.

-------------------------

Trunkzz | 2022-02-10 21:56:06 UTC | #17

Is there any implementation started for this beyond the proposal and this thread that I can take a look at?

-------------------------

lara | 2022-02-10 22:38:44 UTC | #18

Hi all, please find the design proposal for the next stage of the SNS project [here](https://forum.dfinity.org/t/sns-deployment-and-upgrades-design-proposal/10816).
Looking forward to your questions and feedback!

-------------------------

lara | 2022-02-10 22:52:35 UTC | #19

Yes, the implementation is started. It is still very much work in progress, but you can follow along here https://github.com/dfinity/ic/tree/master/rs/sns

-------------------------

skilesare | 2022-02-24 04:38:12 UTC | #20

https://github.com/dfinity/ic/blob/833c2db9a3b652e8306cf6e38a728317dc2627e5/rs/sns/governance/src/governance.rs#L1414

I see a pathway to set the SNS canister to call a remote canister to call a function. I'd like something like:

type RemoteCall {
   principal: Principal;
   function: Text;
   data: Blob; };

In motoko this could use the call_raw functionality coming in 0.9.1.  This would allow services canisters to mark the SNS canister as the "Admin" and then the sns could vote on functions to call on various canisters(not just the SNS canister which I think is the current set up).

I'm working on the spec for a service right now that is trying to be governance service agnostic and just assign a governance canister.  As long as that canister knows how to call the issue_command function you can use the SNS or something simpler.  It would be great if the SNS supported this.  I know there are issues with getting stuck on a bad behaving canister, but maybe you can not wait for the await?  Or maybe it is a parameter to the type?

-------------------------

lara | 2022-03-01 13:26:58 UTC | #21

Hi @skilesare ,
it is definitively the plan that the SNS governance can call another method on a canister and that the SNS can then be used to execute arbitrary proposals. 
For the very first version, we prioritised that a SNS should be able to upgrade another canister, e.g., the dapp (which is also a call to another canister), upgrade SNS canisters, change the SNS parameters, and have motion proposals. Next we would tackle the generic proposal execution (which I think is what you are asking for), but this might not be ready in the very first version in Q1. 

Could you elaborate on what you mean by "the issue_command function"? 
If I understand you correctly you would like to have the following functionality: a canister that just has a method and specifies that the SNS governance is allowed to call that method. The SNS governance can then call this method as a result of a proposal. Is this right? If so, I think this is what should be possible with the "generic proposal execution" that we envision.

-------------------------

skilesare | 2022-03-01 14:21:37 UTC | #22

[quote="lara, post:21, topic:10224"]
If so, I think this is what should be possible with the “generic proposal execution” that we envision.
[/quote]

Sounds right! It will be a good feature to have.

-------------------------

JaMarco | 2022-03-23 02:37:55 UTC | #23

@lara Which token standard will SNS governance tokens use?

-------------------------

lara | 2022-03-25 16:31:58 UTC | #24

It will user the same ledger as the NNS.

-------------------------

singularity | 2022-04-04 13:33:37 UTC | #25

I think he wanted to know what coin standard will be used for coins that make use of SNS, such as you have ERC20 or BEP20 token standard.

-------------------------

lara | 2022-04-05 12:48:57 UTC | #26

Right. What I meant is that we will use the "standard" that is defined by the current ledger implementation. I don't think this standard has a name in the sense of ERC20, but it does implicitly define how a token is defined and what APIs are available for a token that uses this ledger implementation. In that sense it defines a standard and we intent to use this one. 

Does that make sense?

-------------------------

jzxchiang | 2022-04-06 00:36:59 UTC | #27

Unfortunately, most of the DEXs I've seen (namely InfinitySwap or Sonic) are using [DIP20](https://github.com/Psychedelic/DIP20) or some variation of DIP20.

I worry this will present compatibility problems and grievances down the road...

-------------------------

lara | 2022-04-06 14:45:54 UTC | #28

Excited to share the SNS timelines (that build on the design discussed in this post) [here](https://forum.dfinity.org/t/sns-service-nervous-system-timeline/11963).

-------------------------

singularity | 2022-04-08 14:55:55 UTC | #29

This make sense, thank you!

-------------------------

skilesare | 2022-04-08 20:27:48 UTC | #30

Infinityswap has informed us that they will support  the native ledger from the beginning.(this may have changed, but I don’t think it has cc: @Maxfinity )

This standard thing has become a real pain in the ass and I wish everyone(including dfinity) would lean into interface namespacing(https://forum.dfinity.org/t/proposal-to-adopt-the-namespaced-interfaces-pattern-as-a-best-practice-for-ic-developers/9262) before the problem gets even bigger and we have a real problem on our hands. The groups who have defined the standards and who haven’t properly Namespaced their functions are really holding back the ability for DiFi and service composability to move forward. It isn’t their fault as this is an entirely new space where everyone shares the same function naming universe. It’s a whole new problem and we really need to solve it.

DIP20, EXT, and the NNS ledger all need to have namespace functions added to them so that we can all move forward and retro fit as we move forward.  There is nothing keeping anyone from implementing both transfer and transfer_dip20 to their existing canisters.  The one case where this becomes an issue is when we have blackholed canisters with no upgrade path.  As far as I know, that number is currently small. Once it gets big we won't be able to go backward.

Origyn will be releasing some stuff in the future and the one thing that has kept it moving is that DIP721 was namespace. As a result, Origyn will support both EXT(which needs namespacing added) and DIP721 as well as the enhancements that are added to the standards stoup. Every single one of the proposed functions will be namespaced.

-------------------------

Maxfinity | 2022-04-09 11:07:46 UTC | #31

[quote="skilesare, post:30, topic:10224"]
Origyn will be releasing some stuff in the future and the one thing that has kept it moving is that DIP721 was namespace. As a result, Origyn will support both EXT(which needs namespacing added) and DIP721 as well as the enhancements that are added to the standards stoup. Every single one of the proposed functions will be namespaced.
[/quote]

We will definitely be supporting the ledger, and namespacing is a great idea!

-------------------------

lastmjs | 2022-04-09 12:24:19 UTC | #32

So is this did file up-to-date with the SNS ledger standard? Are they one and the same? https://github.com/dfinity/ic/blob/master/rs/rosetta-api/ledger_canister/ledger.did

-------------------------

mariop | 2022-04-11 12:08:46 UTC | #33

[quote="lastmjs, post:32, topic:10224, full:true"]
So is this did file up-to-date with the SNS ledger standard? Are they one and the same? [ic/ledger.did at master · dfinity/ic · GitHub ](https://github.com/dfinity/ic/blob/master/rs/rosetta-api/ledger_canister/ledger.did)
[/quote]

Yes. The NNS and SNS both use the ICP Ledger and that file is the public API of the ICP Ledger.

-------------------------

lastmjs | 2022-04-11 12:23:09 UTC | #34

Perfect, thank you (need some more characters)

-------------------------

lara | 2022-04-22 11:17:32 UTC | #35

Hi all, 
a brief end-of-the week update & introduction: 
As described in [this forum post](https://forum.dfinity.org/t/sns-service-nervous-system-timeline-pilot-projects/11963?u=lara), we plan to work on a first simple version of a reward scheme for the SNSs. 
The design efforts are lead by @bjoernek, who is currently finalising a concrete design proposal that he will share on this thread next week. We also plan a community conversation about this in the coming weeks and will share the date of it as soon as it is confirmed.

Wishing everyone a great weekend!

-------------------------

bjoernek | 2022-04-25 11:44:50 UTC | #36

Hi all,

I recently joined the Dfinity research team with a particular focus on governance & tokenomics and I am very much looking forward to working with the community! To start the collaboration, please find below a design proposal for a **simple SNS reward scheme**.

**Summary of the proposal**

* Following the overall strategy to deliver SNS functionality in stages, we plan to introduce a first simple scheme for SNS rewards. The proposal covers voting rewards and usage rewards.
* To facilitate a timely delivery, we suggest leveraging the concepts and code base of the NNS reward scheme.
* A SNS will have the flexibility to configure the reward scheme to a broad set of use cases.

**Community conversation & Timeline**

To get the design approved by the community, we propose the following schedule:

* April 25th - May 3rd: Design discussion on this forum thread
* May 3rd: Community conversation about the topic
* Afterwards initiate the implementation of the design, including potential feedback from the community.
* We consider this design as a concrete, detailed suggestion on how to realize parts of the larger design adopted in December 2021. Therefore, we propose not to submit a separate motion proposal and rather discuss it in the forum here and in the community conversation.

Looking forward to hearing your inputs on this!

Björn

# Details of the proposal

## Objective

* We provide a draft design for a Service nervous system (SNS) reward scheme.
* We consider two categories of rewards
  * Voting rewards to incentivize users to take part in SNS governance.
  * Usage rewards to incentivize users to become early adopters and active users of the SNS.
* In this design we focus mainly on voting rewards, which enables a SNS to run a truly decentralized set-up. For usage rewards we provide a generic design only, assuming that the precise mechanism of usage rewards will have to be tailored to the individual SNS.

## Background & context with other projects

### Linkage to overall strategy

* As outlined in the motion [Long Term R&D: 3-year Plan Dapp Governance](https://dashboard.internetcomputer.org/proposal/35642), the overall strategy is to release SNS features in phases, allowing for a step-by-step adoption by the community.
* Following this strategy, we plan to introduce a first simple scheme for SNS rewards. Based on the collected experience from developers and the community, this can be enhanced in future phases.
* We suggest using a reward scheme that is based on the voting rewards used in the Network nervous system (NNS) of the Internet Computer, which however can be flexibly configured by each SNS. This approach has the following advantages
  * The community is already familiar with key concepts of the NNS.
  * We can leverage the existing code base of the NNS facilitating the initial release.
* We are conscious of the fact that a SNS might require only a subset of the NNS voting features. Therefore, we suggest that the SNSs will have the flexibility to configure the reward scheme to a broad set of use cases, including the ability to disable certain elements.
* In general, rewards can be paid out by newly minted tokens or by tokens from the initial supply, which has implications for the tokenomics of the system, in particular the inflation. In the proposed design for SNS voting rewards we focus on the former approach, while also explaining how the according inflation can be limited. Alternatives are considered at the end of the proposal.

### Recap on NNS voting rewards

**Overall idea:** Within the NNS, voting rewards are paid out daily, based on an overall reward pool. Each neuron receives a pro-rata amount of that pool according to the voting power with which the neuron voted and in how many proposals the neuron participated.

**Detailed description:**

* Determination of the total reward pool
  * For a time t between G (genesis time) and G + 8y the annualized reward as a percentage of total supply is R(t) = 5% + 5% [ (G + 8y – t) / 8y ]²
  * For a time t after G+8y, we have R(t) = 5%.
  * The total pool of voting rewards for a given day is calculated as ICP supply (total supply of ICP tokens on that day) * R(t) / 365.25.
* Voting power of neurons
  * Only neurons with a dissolve delay of more than 6 months are eligible for voting. The maximum dissolve delay is 8 years.
  * The voting power of a neuron is computed as neuron_stake * dissolve_delay_bonus * age_bonus
  * In particular the dissolve delay bonus and the age bonus are cumulative.
  * The dissolve delay bonus is a value between 1 and 2 and a linear function of the dissolve delay (capped at eight years).
  * The age bonus is a value between 1 and 2 and a linear function of the age of the neuron (capped at four years). A neuron starts aging when it enters a locked state.

* Allocation of reward pool to neurons
  * The reward pool is allocated in proportion to the voting power of proposals that are settled on this day, i.e.
    * Determine the set of proposals that are included in this reward period (a day): these are the proposals that are not yet settled with respect to voting rewards, and no longer open for voting.
    * The total voting power of neurons contributing to these proposals is added up.
    * Each neuron is rewarded in proportion to the voting power it contributed to these proposals.
  * When a neuron is rewarded for voting, these rewards are recorded in an attribute of the neuron that is called maturity. Maturity expresses that a neuron has a claim on a given amount of governance tokens, which are however not yet minted.
* Neuron management with respect to rewards
  * In the current NNS set-up the following neuron management operations exist: merge maturity, spawn maturity and exchange maturity.
  * Please note: The NNS neuron management will be enhanced as described in the following [Motion proposal on compounding maturity](https://dashboard.internetcomputer.org/proposal/48623).
  * To keep the SNS scheme simple at start, this enhancement is currently not planned for the first phase of the SNS. Depending on community feedback this can be added later.

## Proposed design for SNS rewards

### Voting rewards

**Overall idea:** As highlighted in the background section, we intend to leverage the NNS voting reward scheme and allow for flexibility to configure the scheme. In particular, we suggest that a SNS has the ability

* to influence the shape of the reward function.
* to configure the various parameters driving the voting power of neurons.

**Detailed description:**

* Determination of the total reward pool
  * A SNS can influence the shape of the reward function, by configuring the start point r<sub>max</sub>, the end point r<sub>min</sub> and the transition length t<sub>delta</sub>.
  * In particular, for a time t between t<sub>start</sub> and t<sub>start</sub>+t<sub>delta</sub> the annualized reward as a percentage of total supply is R(t) = r<sub>min</sub>+ (r<sub>max</sub>-r<sub>min</sub>) [ (t<sub>start</sub>+ t<sub>delta</sub> – t) / t<sub>delta</sub> ]²
  * For a time t after t<sub>start</sub>+t<sub>delta</sub>, we have R(t) = r<sub>min</sub>
  * For the special case r<sub>max</sub> = r<sub>min</sub> the reward function is constant, namely R(t)=r<sub>min</sub>
  * The total pool of voting rewards for a given day is calculated as SNS supply (total supply of SNS tokens) * R(t) / 365.25.
  * Rewards will also be calculated and distributed for days where no voting took place. Enhancing the mechanism  (e.g. accrue the rewards on days without voting) are considered too complex for a short-term delivery. This could be adjusted & fine-tuned in a later stage.
  * Voting rewards are minted, i.e. generating new supply. In case that the SNS would like to stop a token supply increase after t<sub>start</sub>+t<sub>delta</sub> the SNS should set r<sub>min</sub>=0.
* Voting power of neurons
  * Dissolve delay
    * The SNS has the ability to configure the minimum & maximum dissolve delay and minimum & maximum dissolve delay bonus.
    * The special maximum dissolve delay bonus = 1 results in no dissolve delay bonus.
  * Age
    * The SNS has the ability to configure minimum & maximum age and minimum & maximum age bonus.
    * The special case maximum age bonus = 1 results in no age bonus.
* Allocation of reward pool
  * The reward pool is allocated in proportion to the voting power of proposals that are settled on this day (same as for the NNS).
* Neuron management with respect to rewards
  * To keep the set-up simple in the first phase only the following functionality will be available
    * Disburse maturity which directly mints & disburses the maturity-equivalent of tokens into an account.
    * Merge maturity which adds the maturity accrual directly to the staked token amount.
  * In a later phase, additional functionality can be added.
* There should be a flag which activates the calculation and distribution of voting rewards, as a SNS might choose to go through a ramp-up period without voting rewards, or with no voting rewards at all.

### Usage rewards

* The purpose of usage rewards is to foster early adoption and active usage of the SNS. Given that the meaning of usage and the according usage rewards can vary greatly across individual SNSs we suggest a very simple set-up at start.
* In particular, we suggest that some tokens (reserved for usage rewards) can be held in an account that is controlled by a canister. This canister can then codify when the rewards are paid out and to whom.
* This solution allows paying out existing (non-minted) tokens. If it is required that usage rewards trigger minting, this could be added in a later phase.
* Also, in case that common characteristics/metrics for usage rewards are established over time, this can be integrated into the SNS reward scheme, depending on the feedback of the community.

## Security

The reward function influences the token supply and minting and thus is security relevant. Therefore, we plan that both the design and implementation will be reviewed by DFINITY’s security team.

## Alternatives considered

* Alternative 1: Very simple set-up
  * Voting power is allocated according to the quantity of SNS tokens. No staking and minimum looking period, no voting rewards.
  * Advantage: This set-up is easy to understand and easy to implement.
  * Disadvantage: This set-up might be desirable for some SNS teams, however might not be flexible enough for others. Also the [Long Term R&D: 3-year Plan Dapp Governance](https://dashboard.internetcomputer.org/proposal/35642) clearly articulates the visions to allow staking and rewards for SNSs.
  * The proposed approach described above can be configured to Alternative 1 by choosing an appropriate configuration, while allowing at the same time a solution which is aligned with the long term plan.
* Alternative 2: Even more flexible
  * Allow for further flexibility in the determination of voting power and allocation. For example, allow other kinds of reward functions R(t).
  * Advantage: Further flexibility for SNS teams to come up with their own solutions.
  * Disadvantages: Additional implementation complexity. Difficult to judge at this stage what additional flexibility is really required for a first version.
  * Given that the need for further flexibility is currently unclear, it is suggested to use the current proposal for the first phase. If the need for further flexibility arises, this can be included in a second phase.
* Limiting inflation
  * As described above, a SNS can limit or eliminate token supply inflation by choosing an appropriate configuration of the reward function R(t).
  * As an alternative, instead of newly minting voting rewards (which are determined as a percentage of total supply), one could also define a dedicated pool for voting rewards whose size decreases over time.
  * Given that it is possible to eliminate token inflation in the proposed set-up, this alternative is not considered to be required for the first phase.

-------------------------

bjoernek | 2022-04-29 09:30:00 UTC | #37

Hi all, as a short update to the above post on SNS rewards: To align better with the timing of the several Supernova hackathons, we are currently looking into finding an alternative slot in May for the community conversation on SNS rewards. I will confirm once this is clear.

-------------------------

jzxchiang | 2022-05-02 05:13:54 UTC | #38

I wonder if it even makes sense to have a reward pool.

For example, what if inflation is dynamic? In other words, the number of tokens minted as rewards is proportional to the number of proposals created. Tokens can be minted at proposal decision time (instead of upfront), and voters can be rewarded with these newly minted tokens.

That way, no tokens need to be minted on days where no voting took place.

It can be refined, so that there is a cap on the number of tokens minted in a day, a minimum threshold of votes on a proposal for there to be rewards, etc...

-------------------------

jzxchiang | 2022-05-02 05:15:26 UTC | #39

I believe this model doesn't work for NNS, given that node providers are rewarded based on their uptime, which is continuous and not discrete. For discrete events like voting on a proposal, I think a dynamic inflation scheme may make more sense to prevent superfluous inflation.

-------------------------

bjoernek | 2022-05-03 09:53:04 UTC | #40

Thank you for the feedback @jzxchiang ! 
I have two comments: 
1. If we make the rewards dependent on whether a proposal is submitted or not then you create an incentive to submit spam proposals. 
2. The proposed design could definitely be enhanced further. The current proposal was based on the goal of delivering something practical quickly (and thus leveraging as much as possible from the NNS).

-------------------------

jzxchiang | 2022-05-04 06:52:04 UTC | #41

> 1. If we make the rewards dependent on whether a proposal is submitted or not then you create an incentive to submit spam proposals.

Right, I think this could be addressed in a similar way that spam proposals are addressed now, e.g. with a proposer stake that gets forfeited if the proposal gets rejected, a minimum threshold for proposals to pass, etc. The rewards would be minted at the very end of voting, not when the proposal is submitted.

> 1. The proposed design could definitely be enhanced further. The current proposal was based on the goal of delivering something practical quickly (and thus leveraging as much as possible from the NNS).

Makes total sense, looking forward to seeing how it turns out!

-------------------------

bjoernek | 2022-05-05 12:54:32 UTC | #42

Short update

* The community discussion is now scheduled for May 11th, see [here](https://dfinity.org/conversations/)
* Based on received feedback, we plan to submit a motion proposal.

-------------------------

lucajj | 2022-05-10 05:15:21 UTC | #43

Any news about community fund on nns ??

-------------------------

bjoernek | 2022-05-10 08:39:36 UTC | #44

Thank you for the follow-up @lucajj. We are working on the topic of the community fund and intend to give a status update soon.

-------------------------

bjoernek | 2022-06-20 15:27:32 UTC | #45

Hi all, FYI the discussed [motion proposal](https://dashboard.internetcomputer.org/proposal/66006) for an SNS reward scheme is now ready for voting!

-------------------------


mariop | 2022-07-01 11:17:33 UTC | #1

Hi everyone,

The DFINITY Foundation has been working on a Ledger that implements the ICRC-1 Token Standard. This Ledger will be used as SNS and ckBTC Ledger and will be available for everybody for their own tokens.
We would like to share the [API](https://github.com/dfinity/ic/blob/master/rs/rosetta-api/icrc1/ledger/icrc1.did) to facilitate integration with services.
Please keep in mind that this Ledger is still under active development and that the API may change slightly because we are still discussing the standard itself.

Best

-------------------------

levi | 2022-07-02 01:47:35 UTC | #2

Hi @mariop , what bout the possibility of moving the approveTransfer, allowance, revokeApproval and commitTransfer methods to a separate standard that can work alongside the base icrc1_balance_of and icrc1_transfer methods? Something like icrc1a_approveTransfer, icrc1a_allowance, icrc1a_revokeApproval, and icrc1a_commitTransfer. With the approve-methods being a separate functionality that most token holders will not use, with additional overhead for a ledger and additional cycles-cost to run and maintain, some SNSs might want to leave that overhead to a separate canister/service or leave it out.

-------------------------

jzxchiang | 2022-07-02 03:58:48 UTC | #3

Do you mind sharing the reasoning behind adding the two-stage transfer API (e.g. approve)? That seems to be a large (and recent) addition.

-------------------------

Pwoseidon | 2022-07-02 12:20:41 UTC | #4

Probably for asynchrony

-------------------------

skilesare | 2022-07-02 14:02:36 UTC | #5

Basically it is necessary if you want to build any kind of service/dex. We are struggling through all kinds of user deposit issues trying to use the transfer/deposit pattern at the moment. This pattern makes things much easier for users and service providers.

-------------------------

iBardak | 2022-07-02 20:18:47 UTC | #6

We are currently working on a standard for a multifunctional token. The bottom line is that we want to make it possible to give tokens any characteristics. You can read more here https://h5aet-waaaa-aaaab-qaamq-cai.raw.ic0.app/post/3295652/new-token-standart-mft--mfts . 
We came to the conclusion that it would be more convenient to create a canister of characteristics, to give them a certain order. And a canister of token registries will address them. That is, when creating such a token, you will only need to register the values. 
For example: 

‚Äúparametr1 = none
..
parametr23 = 2
parametr24 = ‚Äúdescription‚Äù
and so on

This will standardize the creation and, accordingly, requests to the canister. It will allow you to create explorers and other products on top of this architecture. I suggest you think about this method

-------------------------

Pwoseidon | 2022-07-03 15:52:19 UTC | #7

So it‚Äôs like DAB for fungible tokens. (?)
It sounds like it‚Äôll provide a ledger/centralized registry that‚Äôll allow token tracking.

Would this also act as the settlement layer for fungible tokens? 
Like, would it provide an environment for synchrony among the tokens in this registry? üëÄ

-------------------------

mariop | 2022-07-04 08:21:43 UTC | #8

[quote="jzxchiang, post:3, topic:14109, full:true"]
Do you mind sharing the reasoning behind adding the two-stage transfer API (e.g. approve)? That seems to be a large (and recent) addition.
[/quote]

One of the main reasons why we wanted to discuss a common standard is to decide a common payment flow that could be implemented *right now* on the IC. We sit down with the community in the Ledger&Tokenization working group and decided that a ERC-20 like approach, with some changes to make it more robust, was the best flow. The rationale is that out of the three main payment flows, the only one widely supported by both the platform and the community is the 2-steps transfer. Let me summarise here the payment flows and the why we decided for/against each one of them.

1. **ICP Payment Flow (account_balance/transfer)**: this is a combination of the methods `account_balance` and `transfer` plus the idea of reserving subaccounts for payments. This was rejected by the community. There is no DEX supporting it at the moment nor interest in support it as far as I can tell. Note that this is still in the final standard because it uses only the base building blocks of the standard.
2. **DIP-20 Payment Flow (approve/transfer)**: the most common payment flow as far as I can tell with support from at least half of the community based on a recent vote. We evaluated it at DFINITY and had [some security concerns](https://forum.dfinity.org/t/erc-20s-approve-transferfrom-security-concerns-for-the-icrc-1-token-standard/13610) which lead to the creation of the *2-steps transfer*. 2-steps transfer is basically a variant of the `approve`/`transferFrom` flow that increases its robustness by adding some bounds around them. We asked if the variation was fine and most people agreed with it. Moreover, most DEXs said that they will support this payment flow.
3. **IS-20 Payment Flow (transfer/notify)**: a different payment flow that removes the need for the service to check that a payment is valid or not. In other payments flow, the user needs to notify the service that a payment happen and then the service needs to check the Ledger to verify the payment. With notify, the user asks the Ledger to notify the service and that means the service is notified only when the payment effectively happened. This is a great idea but the TL;DR is that it requires changes at the replica level to either support *named-callbacks* or *one-shot calls* in order to be properly supported by existing Ledgers. We want the payment flow to be implementable *right now* and that's what ultimately made us decide to not support this payment flow but maybe revise it in future. I can elaborate more if needed, maybe during a working group session.

ICRC-1 is the combination of the basic building blocks of a Ledger, e.g. `balanceOf` and `transfer`, and the 2-steps payment flow.

I understand that the standard is not as simple as it could be but look at the bright side: **we finally have a payment flow on the IC that everybody can and want to support**. This is the first standard that is supported by both DFINITY - SNS, ckBTC and later ICP will all support ICRC-1 - and the community and it doesn't preclude extensions or new standards.

It's a win for everybody.

-------------------------

mariop | 2022-07-04 08:28:15 UTC | #9

[quote="levi, post:2, topic:14109, full:true"]
Hi @mariop , what bout the possibility of moving the approveTransfer, allowance, revokeApproval and commitTransfer methods to a separate standard that can work alongside the base icrc1_balance_of and icrc1_transfer methods? Something like icrc1a_approveTransfer, icrc1a_allowance, icrc1a_revokeApproval, and icrc1a_commitTransfer. With the approve-methods being a separate functionality that most token holders will not use, with additional overhead for a ledger and additional cycles-cost to run and maintain, some SNSs might want to leave that overhead to a separate canister/service or leave it out.
[/quote]

Hey @levi, I'd prefer to keep a single standard for now. Having two standards, a core one and a 2-steps transfer extension, would work but would go against our effort to reduce fragmentation and it would increase the complexity of both the SNS, which would have to give the option to configure the Ledger, and the Ledgers themselves.

I'm curious about what you said here though because as far as I know no DEX will support the ICP payment flow. That means that you won't be able to exchange SNS Tokens on DEXs if you disable 2-steps transfer. This seems counterproductive to me as you want the SNS Ledger to be supported by as many services as possible. In which case it would be fine to not have 2-steps transfer?

-------------------------

jzxchiang | 2022-07-04 17:58:23 UTC | #10

Thanks for this great summary.

A couple of questions:

* Will there be a special minting account for `mint` or `burn` operations?
* Why are approvals not added to a block, while transfer revokes and commits are?
* It seems like the approver has to pay the fee instead of the committer. Is that intentional? Will there be flexibility for other parties to pay the fee in the future?
* What is the primary use case for subaccounts if they are no longer reserved for payments?

On a high level, this new `approveTransfer` / `commitTransfer` seems much safer than ERC-20. However, does it really enable 3rd-party transfers? A cheque is still a transaction between two parties. What if you want to approve a 3rd party to transfer your funds to someone else?

Additionally, is it a problem that the ICP ledger canister doesn't implement ICRC-1, or will someone just need to wrap it for it to work on DEXs?

-------------------------

levi | 2022-07-04 21:34:34 UTC | #11

[quote="mariop, post:9, topic:14109"]
I‚Äôm curious about what you said here though because as far as I know no DEX will support the ICP payment flow.
[/quote]
@mariop 
The DEXs and CEXs support ICP trades now. They can support SNS-token trades in the same way.

-------------------------

mariop | 2022-07-04 22:11:00 UTC | #12

[quote="levi, post:11, topic:14109"]
The DEXs and CEXs support ICP trades now. They can support SNS-token trades in the same way.
[/quote]

Most DEXs have minimal to no support for ICP and have alternative wrapped versions of ICP. Even the ones that still have to launch changed their mind about supporting ICP. This brings fragmentation to the IC and the community was not happy. Add the SNS tokens to the picture and you end up with an unwelcoming ecosystem.

What we did then was to sit down with everybody and ask what was wrong with ICP. All DEXs and many DeFi devs pointed out the complexity of the AccountIdentifier and the issues with payment flows. We took the feedback and designed ICRC-1 with the help of the community.

-------------------------

mariop | 2022-07-04 22:16:37 UTC | #13

[quote="jzxchiang, post:10, topic:14109, full:true"]
* Will there be a special minting account for `mint` or `burn` operations?
[/quote]

Yes

[quote="jzxchiang, post:10, topic:14109, full:true"]
* Why are approvals not added to a block, while transfer revokes and commits are?
[/quote]

The implementation is still WIP, that's only the interface. In future approvals will be recorded as blocks

[quote="jzxchiang, post:10, topic:14109, full:true"]
* It seems like the approver has to pay the fee instead of the committer. Is that intentional? Will there be flexibility for other parties to pay the fee in the future?
[/quote]

Each operation that uses resources on the Ledger needs to pay a fee. Note that the fee can be temporary: the service can remove the fee from the service cost and effectively pay the fee for the approver.

[quote="jzxchiang, post:10, topic:14109, full:true"]
* What is the primary use case for subaccounts if they are no longer reserved for payments?
[/quote]

It can still be used for payments but the main reason is to have multiple accounts per principal. This simplified many flows such as the SNS one.

[quote="jzxchiang, post:10, topic:14109, full:true"]
On a high level, this new `approveTransfer` / `commitTransfer` seems much safer than ERC-20. However, does it really enable 3rd-party transfers? A cheque is still a transaction between two parties. What if you want to approve a 3rd party to transfer your funds to someone else?
[/quote]

You can do it right now. The spender is not the receiver of the funds. A can approve B but it's up to B to decide the destination of the tokens (see to_principal and to_subaccount).

[quote="jzxchiang, post:10, topic:14109, full:true"]
Additionally, is it a problem that the ICP ledger canister doesn‚Äôt implement ICRC-1, or will someone just need to wrap it for it to work on DEXs?
[/quote]

ICP will implement ICRC-1 eventually. We first need to finish the SNS. ICP is next.

-------------------------

levi | 2022-07-04 23:24:11 UTC | #14

[quote="mariop, post:12, topic:14109"]
All DEXs and many DeFi devs pointed out the complexity of the AccountIdentifier and the issues with payment flows. We took the feedback and designed ICRC-1 with the help of the community.
[/quote]

What are the issues they were having with the payment flows? and How do the approve methods fix those issues?

-------------------------

mariop | 2022-07-05 07:56:43 UTC | #15

[quote="levi, post:14, topic:14109"]
What are the issues they were having with the payment flows? and How do the approve methods fix those issues?
[/quote]

The issue was that the service could not issue a transfer and had instead to ask users to do transfers when ready. The new methods solve this.

-------------------------

Pwoseidon | 2022-07-05 12:38:16 UTC | #16

Once the fungible token standard is decided on, could that be modified into an non-fungible token standard?

I assume yes(?)

Thank you

-------------------------

mariop | 2022-07-05 12:43:21 UTC | #17

[quote="Pwoseidon, post:16, topic:14109"]
Once the fungible token standard is decided on, could that be modified into an non-fungible token standard?
[/quote]

We are considering adding a second standard (ICRC2?) for NFTs following the work done for ICRC1. It's not clear yet when we are going to do it but it would be nice to do it soon :slight_smile: .

-------------------------

Pwoseidon | 2022-07-05 13:00:41 UTC | #18

Having ICRC-1 will definitely help :slight_smile: 

Hopefully the community draws inspiration from ERC-1155 for batch transfer and other improved functions.

Thank you for taking charge on this important matter!

-------------------------

iBardak | 2022-07-05 13:04:12 UTC | #19

[quote="Pwoseidon, post:7, topic:14109"]
So it‚Äôs like DAB for fungible tokens. (?)
It sounds like it‚Äôll provide a ledger/centralized registry that‚Äôll allow token tracking.

Would this also act as the settlement layer for fungible tokens?
Like, would it provide an environment for synchrony among the tokens in this registry?
[/quote]

Yes, of course.. we already have a set of regular tokens. This is easily applicable if you build a single token structure. Then the algorithm will make requests correctly. The essence of MFT is that it is a regular token that can have a description in the form of text or another type of file (like NFT), this token can have characteristics and this token can have an issue like a regular token. And therefore to trade on the exchange.

-------------------------

Pwoseidon | 2022-07-05 14:02:15 UTC | #20

Ah very interesting! Endless possibilities here ü§Ø

-------------------------

levi | 2022-07-05 17:26:50 UTC | #21

[quote="mariop, post:15, topic:14109"]
The issue was that the service could not issue a transfer and had instead to ask users to do transfers when ready. The new methods solve this.
[/quote]

A service can hold the funds of both parties or one party (in escrow), and then give out the funds by the rules of the trade, like in the sns-auction-canister. 
Is there a practical benefit for a service to hold an approval (in escrow) instead of the funds?

-------------------------

mariop | 2022-07-06 11:16:16 UTC | #22

[quote="levi, post:21, topic:14109"]
A service can hold the funds of both parties or one party (in escrow), and then give out the funds by the rules of the trade, like in the sns-auction-canister.
Is there a practical benefit for a service to hold an approval (in escrow) instead of the funds?
[/quote]

There are differences in holding funds vs holding approvals. The main one is where the tokens live. In the first case, the funds are in a service account while in the second case they are in the user account. I can see how the latter option may be useful, e.g. approving multiple services to access the same funds, but  the benefits for DEXs are not very clear.

My view is that a DEX could use subaccounts and work with locked funds (as you seem to suggest in your message). Subaccounts remove most of the issues related to lack of funds during a transferFrom and, by consequence, remove a lot of pain in writing exchanges and reduce the cycles usage. A minor downside of subaccounts (besides having funds locked) is that the fees needs to be paid twice: once from the user when transferring funds to the DEX and a second time from the DEX when completing the transaction.

DFINITY position from the very beginning was that one could do most things with just `subaccount`s, `transfer` and `balance_of`. The remaining set of things could be done as separate services. Perhaps we failed to explain and support the community for implementing protocols based on this API, but the result was that DEXs did not support ICP and considered wrapping ICP in new standards.

-------------------------

Maxfinity | 2022-07-06 11:03:58 UTC | #23

[quote="mariop, post:22, topic:14109"]
There are differences in holding funds vs holding approvals. The main one is where the tokens live. In the first case, the funds are in a service account while in the second case they are in the user account. I can see how the latter option may be useful, e.g. approving multiple services to access the same funds, but the benefits for DEXs are not very clear.
[/quote]

Let's be honest here, some DEXs chose to do this for political reasons to create a different standard, not because Dfinity failed to explain how to use subaccounts.

-------------------------

Zane | 2022-07-06 11:46:47 UTC | #24

Why would that be the case? A different standard forces users to wrap tokens which isn't ideal for the Dex

-------------------------

infu | 2022-07-06 14:41:58 UTC | #25

[quote="mariop, post:12, topic:14109"]
All DEXs and many DeFi devs pointed out the complexity of the AccountIdentifier
[/quote]

How did they find that complex. It's literally done with 5 lines of code in a function you can tuck somewhere. Then you just need to pass an extra subaccount parameter.

[quote="mariop, post:12, topic:14109"]
**DIP-20 Payment Flow** the most common payment flow as far as I can tell with support from at least half of the community based on a recent vote.
[/quote]

I want to emphasize **half of the community**   

Let's call it for what it is?
Since the beginning of personal computers, there is a war. It's a war for the interface (the frontend). 

**Windows vs Mac**
These two were perhaps the first to realize it. Whoever owns the interface is the dominant power. The battle is fought subtly so attacks can't be proven. One way you fight is to make custom interfaces, patent them, and get people used to them (hooked). If possible throw your interfaces for free in kinder gardens so future generations are secured.

Law 1 - The one who owns the interface has the power to change the backend as long as users aren't bothered.

Law 2 - The majority of users will never leave their "favorite" interface even if they are offered a superior one. 

The harvest - At some point, the dominant power will monetize, and in Windows example, that's Microsoft Office apps and the browser - installing apps by default and killing the competition.
"y2k - MICROSOFT IS RULED AN ILLEGAL MONOPOLY"

**Netscape vs Firefox vs Safari vs Chrome vs Internet Explorer**

Internet Explorer was installed by default on Windows. It made early web devs (like me ~ 1998) life miserable. Microsoft made sure a dozen of critical W3C (internationally agreed-upon specification) html+javascript standards weren't working the way they should. Microsoft were economically incentivized to slow down standardization in IE as much as they can. A web developer had to basically write the whole app two times. It didn't make sense to write it two times if only 5% of your users use other browsers using the W3C standards. So you just ignored them unless you were in Fortune 500 or you made your web apps dead simple. It took the world painful ~16 years of polyfills & ugly javascript & billions of human hours wasted to get rid of IE.

![image|690x468](upload://6U3oyEfUrJv7DMjV58sdY2ojYk0.jpeg)

**Web and iOS**
The same battle again. One of the reasons Dominic Williams was annoyed at iOS while trying to make video work for the Proof of Personhood app. There are a lot of features from the web browser intentionally removed by Apple or just made bad. If the browser on iOS is too good, it will make the marketplace obsolete. Apple enforces ~40% commission from apps in the marketplace and they can't take anything from web. It will probably take another two decades and a lot of angry people for things to get fixed. 

**Conclusion so far**
Letting someone control the interface is a trap. Maybe a lot of developers on the Internet Computer don't realize it and are tricked by the offered convenience. Do they know what they are getting into? Isn't it the job of experts to warn them? Will Dfinity warn these developers? After all, Web3 is solving that huge problem and for once a DAO can control the interface, and browser extensions can't be DAO owned. Instead of using what IC is great at - avoid another decade-long interface battle that will cause a ton of pain to all developers, Dfinity is promoting the Plug wallet on the front page. Junior developers 
 and hackers are sent straight to it. Users always prefer the convenience and if experts don't pick a side, they will always get tricked. So we created our own monster and now we referring to it as the "popular community choice" when it comes to modifying core standards? The community's popular opinion is that everyone should use Plug wallet, meanwhile, the big dapps in our eco DSCVR, DISTRIKT, NNS, realize what's happening and are using only the proper thing - Internet Identity.

**Why change the standard used by the current ledger?**
My guess is the DIP-20 standard folk wanted to move to Principals and delete subaccounts and AccountIdentifiers fully. They probably met resistance because this means canisters can't have multiple addresses and also it's not backward compatible. So all came to the conclusion, that they have to add multiple flows in one standard, so everyone is happy. ~not good.

**How do the flows supposedly work?**
Legend: ledger - canister holding the token. dex - a canister trying to work with ledger

1) The old perfectly working flow using reserved subaccounts and the current very simple standard
1.1 (UI: makes one call to ledger)
1.2 transfer to reserved subaccount (no cost for dex) 
1.3 (UI: makes a second call to dex)
1.4 dex sends a query call to ledger checking balance (cheap)
1.5 if it's full it sends an update call moving reserved funds to its main subaccount (expensive, but not a problem since a fee can be charged)
== speed: 2 update calls and 1 query
== note: dex makes 1 query call, but query calls are really cheap. If someone wants to DoS your canister, this won't contribute, because just receiving update call costs a lot more.


2) The new way (correct me if I am wrong, just guessing here)
2.1 (UI: makes one update call towards ledger)
2.2 calling icrc1_approveTransfer which supposedly will let dex call ledger later to move tokens. 
To implement this, a ledger has to add stuff to its memory. This means it has to take a fee right at this moment or it exposes itself to a critical vulnerability.
2.3 (UI: makes one update call to dex)
2.4 dex query calls ledger.allowance with approvalId to check if it's all good
2.4 dex update calls ledger.icrc1_commitTransfer to finalize transaction
== speed: 2 update calls 1 query

So, we are basically not gaining anything technically, except transitioning to a supposedly easier system for DIP-20 developers and Plug wallet enthusiasts. They will just pass a null subaccount and won't have to use these terrifying ~10 lines of code to handle AccountIdentifiers. 
![image|690x327](upload://drTZzHPATtZfTvvJDkUnhzod6KK.png)
Maybe I am wrong and we did gain something? I have yet to hear what it is.

In reality, we are losing, because we abandon a simple system with AccountIdentifiers flow and implement the approveTransfer flow which requires us to add 4 more functions and we keep more things in memory. So we will end up having few ways to do the same thing, more possible errors, more code for token canister developers to write. What will happen is, not all devs will get on board and will keep using the old simple way.

Current standard which looks like this:
![image|690x119](upload://b011kiBULi3r2LOJg5btqeTfFQb.png)
...and used for at least 8 months now will be changed to something pointless. I will definitely NNS vote with Reject.

Literally, everything Psychodelic has done so far is an attempt to take over power from the Internet Computer ecosystem. I hate to break it to you, but this is a hostile takeover at daylight.

Plug - control of the interface and users. (Only that should be bad enough)
Cap - control transaction history. 
DAB - control token registry. 
XTC - control the wrapped cycles
Terabethia - control the bridge to Ethereum
Cover - control canister code verification
ICNS - control .icp domains

Unless we want this to be called Psychodelic Chain and not the Internet Computer, we should all steer clear of their "kind" convenient offers. And absolutely not allow any attempt to alter core token standards for no beneficial reason. 

I would advise Dfinity to reduce its Plug & Psychodelic advertising on its pages It is all made to sound like the abovementioned systems are the official way of doing things. It would be more clear if users/devs are guided and things are more clear. Make it look like what it is - We have NNS ecosystem, then we have Psychodelic ecosystem, and so on... 

Psychodelic can demonstrate I am wrong by discontinuing Plug and moving their services to Internet Identity and using AccountIdentifiers.

What will happen if the takeover is complete - We will all have to pay for another coin to keep things secure and decentralized. My guess is, at least 50% of ICP market cap. 

Let's get back to Law 1 - The one who owns the interface has the power to change the backend as long as users aren't bothered.

This means the Psychodelic ecosystem & interface can feed on the Internet Computer, grow big, then move to its own network and abandon the NNS without users feeling a thing. 

Then ICP will lose all of its value.

You can do everything and all the DeFi you want with what we have right now. The reason devs don't do it and I don't do it is because it's risky or they wait for SNS. 
We need to improve frontend security, dfx security, figure DoS & multi canister scaling, certified canisters, distribution of tokens, proof of personhood, DAO controlled canisters and figure upgrading types. It's not because we need these 4 new functions.
These are all connected and will result in a proper DeFi when done. Whoever is rushing into DeFi now is taking a lot of risks just to be first.

Ofc I will be happy if someone persuades me otherwise. That's how it looks to me looking from above without any internal information. I will publically apologize if I am proven wrong and even join Psychodelic. (Never met them, maybe they are wonderful people and I am just paranoid).

-------------------------

Zane | 2022-07-06 16:11:48 UTC | #26

In my opinion there are 2 reasons why the official standard wasn't widely adopted by the community:
1) I noticed many devs are so used to the EVM style of doing things they want to force that approach into the IC too.
2) The official standard works well when sending tokens to other users but not so much when you want to pay for a service.

Over the past week I've been trying to figure out the best way to do it and it seems like you either use Plug, which makes it easier but can't be run on testnet, or with II but from what I understood you have to move the funds from the NNS wallet to the principal generated by the dApp, which makes it quite tedious and less secure when compared to a Metamask style wallet where you can keep all funds in the same place and ideally protected by an HW.

Token standard discussions should have been started way sooner and the features needed for a better payment flow should have been prioritized, the community should have realized where we were heading but Dfinity is also at fault here, I know they have lots on their plate but they should have known there is no point in having an SNS or BTC integration if you don't even have basic DeFi figured out. 
Now I fear the "get something out as soon as possible" approach will cause issues in the future when better standards will be discussed, at that point Dfinity will either have to keep the new standards bloated to make them backwards compatible or break retrocompatibility, either way tokens created with ICRC-1 won't be able to benefit from the new features unless they migrate to a new canister, which isn't ideal for the ecosystem.

That being said I don't have anything against Psychedelic but they should stop creating new projects and try to become the standard for everything, I haven't heard anything about Terabethia for months, Plug can't be run locally or paired with an hardware wallet, ICNS is shady and I'm sure the other have issues too.

-------------------------

Maxfinity | 2022-07-06 15:20:09 UTC | #27

[quote="Zane, post:26, topic:14109"]
Over the past week I‚Äôve been trying to figure out the best way to do it and it seems like you either use Plug, which makes it easier but can‚Äôt be run on testnet, or with II but from what I understood you have to move the funds from the NNS wallet to the principal generated by the dApp, which makes it quite tedious and less secure when compared to a Metamask style wallet where you can keep all funds in the same place and ideally protected by an HW.
[/quote]

The IC is far too different from Ethereum for the EVM style argument to hold water.  You program in Rust and Motoko, accountidentifiers are nothing in comparison. You can also use the InfinityWallet, which let's you mint tokens from a test-ledger to get started. Much more convenient for devs.

-------------------------

Maxfinity | 2022-07-06 15:21:39 UTC | #28

[quote="Zane, post:26, topic:14109"]
Now I fear the ‚Äúget something out as soon as possible‚Äù approach will cause issues in the future when better standards will be discussed, at that point Dfinity will either have to keep the new standards bloated to make them backwards compatible or break retrocompatibility, either way tokens created with ICRC-1 won‚Äôt be able to benefit from the new features unless they migrate to a new canister, which isn‚Äôt ideal for the ecosystem.
[/quote]

The IC did have a payment flow that worked fine.. it should have been advertised as the defacto standard rather than to allow members of the community to try and take market-share by force, effectively splintering the IC.

-------------------------

Zane | 2022-07-06 16:02:31 UTC | #29

>The IC is far too different from Ethereum for the EVM style argument to hold water

That's my opininon too, but based on what I heard and saw many devs want to replicate what they used to do on other chains here, otherwise why would there be so many alternate standards following the approve/transferFrom flow?

>The IC did have a payment flow that worked fine

Fine was not enough for many I guess.

>rather than to allow members of the community to try and take market-share by force, effectively splintering the IC

How do you tell the difference between healthy innovation and market share take over? Infinity Swap came up with its own standard and wallet too, why is it bad if Psychedelic does it but okay when it's another team?  Dfinity is building a decentralized chain so I don't see how they could have prevented fragmentation other than by intervening sooner, instead of letting everyone do his thing when it was clear there wasn't much of a discussion going on.

[quote="Maxfinity, post:27, topic:14109"]
You can also use the InfinityWallet, which let‚Äôs you mint tokens from a test-ledger to get started. Much more convenient for devs.
[/quote]

I have to try it, but still this is far from ideal, if I don't have any particular need like doing batch transactions or interacting with a custom token, there shouldn't even be the need of a 3rd party wallet.
My use case is pretty simple, send ICPs to a canister and have the canister update the balance of the sender in a hashmap, as simple as it gets, in a perfect world the canister would get a notification from the ledger canister that a transfer has happened with all the relevant infos (amount,sender, memo, etc..). Sending the tokens from the NNS wallet should be all that is required for such cases.

-------------------------

Maxfinity | 2022-07-06 17:08:35 UTC | #30

[quote="Zane, post:29, topic:14109"]
I have to try it, but still this is far from ideal, if I don‚Äôt have any particular need like doing batch transactions or interacting with a custom token, there shouldn‚Äôt even be the need of a 3rd party wallet.
[/quote]

Infinitywallet exposes the same interface as agent-js.

-------------------------

Zane | 2022-07-07 04:55:23 UTC | #31

I don't see how that has to do with my previous statement, but I'm new to IC development so perhaps I'm missing something. 
The way I see it there are 2 payment flows worth having in a token standard, everything else is a stop gap that will only cause issues in the future:

1) transfer/notify, this could have implemented in 2 ways: one that requires new tech and another one based on a notifier canister, which iirc was proposed by you.
The cons of the latter were it made the standard more complex and in case the notifier canister was replaced, all services would have required an update, the former's cons were it would have delayed the standard by a lot. 

After giving it some thought I have come to the conclusion, both would have been better than the current interface. Why is that you might ask. We are rushing a token standard in a period when there is no need to rush anything. 1 year ago having a working DeFi, SNS and BTC integration may have done wonders for price action, but now I doubt any of those will affect price in the slightest.
If I were building a dApp I'd rather release a testnet with a temporary standard and wait for a more scalable and easy to use one than go live with a ledger that has been rushed, especially considering there is barely any hype going on and even big projects like Orygin have troubles selling their NFTs.
What we should focus on is providing dev teams rock solid foundations they can use to build their product and be ready for the next bull market, not give them a bandaid that will only cause headaches in the future when they'll have to figure out how to upgrade their ledger.

If Dfinity and dev teams value time to market more than a proper ledger implemenation, the notification canister approach would have been preferable over "DIP20++" cause:
1) It would have got dApp devs used to use the notify pattern, so once we get named callbacks the switch would have required less effort.
2) Risks caused by greater complexity could have been mitigated by security audits and services will have to update regardless in the future if new standards come out and ledger migrate to a V2 canister.

2) approve/transferFrom with customizable expirations for approvals, this one was proposed by @lastmjs and would allow some interesting use cases, the main issue was storing all those approvals isn't possible on a single canister at the moment.

There is also something else that hasn't been considered in the WGs: ledger scalability. If Enoki devs are to be believed: https://docs.enoki.ooo/fundamentals/why-do-we-need-sharding, the proposed standard won't be much scalable and if nothing is done to improve the situations pretty soon all ICRC-1 based tokens will have a terrible UX. I still have some doubts about their findings cause the ICP ledger also runs on a single canister and it doesn't seem to have any issues. Scalability should have been a topic of the WGs though, figuring out the limit of single canister ledgers is important and we should have considered multiple canister approach for the same reason stated above: upgrading ledgers will be messy. We have the opportunity to gather years of experience from the EVM world and use cutting edge tech in the blockchain space, let's not make the same mistakes ETH did and and up with a bloated that gets bloated over the years.

-------------------------

Zane | 2022-07-06 19:15:15 UTC | #32

[quote="infu, post:25, topic:14109"]
The community‚Äôs popular opinion is that everyone should use Plug wallet, meanwhile, the big dapps in our eco DSCVR, DISTRIKT, NNS, realize what‚Äôs happening and are using only the proper thing - Internet Identity
[/quote]

>Psychedelic can demonstrate I am wrong by discontinuing Plug and moving their services to Internet Identity and using AccountIdentifiers.

I agree with you but there are a few issues: 

* II is not as accessible as it should, so as much as I dislike it, the Metamask like approach is needed at the moment if we want wide spread adoption.
* From my understanding there is no way to achieve a wallet like experience, with all your funds and NFTs easily accessible in one place using II at the moment, the closest thing might be Stoic, which has II login but isn't secure apparently. dApps with II login generate a new principal, so say you have ICP on the NNS wallet, you'd have to move them to the newly generated principal and then you can spend them, it's tedious, less secure and I'm not sure what would happen if the dApp shuts down.

That being said I hope we get to a point where we can leave behind the outdated Metamask like wallets and embrace II/NFID fully, all the wallets available at the moment are all quite similar: metamask clones that do the same thing slighly different with no hardware wallet support, in my opinion they contribute almost nothing to the ecosystem and just cause further fragmentation.

-------------------------

Maxfinity | 2022-07-06 22:39:12 UTC | #33

[quote="Zane, post:31, topic:14109"]
* Risks cause by greater complexity could have been mitigated by security audits and services will have to update regardless in the future if new standards come out and ledger migrate to a V2 canister.
[/quote]

Well, not only that but canisters using the notify flow  with a separate notifier canister would not have needed to be updated. There would be no reason to deprecate the old notify method when the new notify flow with named callbacks comes into play. Both could have been used. It's not even a disadvantage.

if it absolutely had to be replaced, the IC could have employed another deployment pattern, by proxy calling a notifier canister. If the notifier canister needed to be replaced it could just be swapped out for another canister. So in effect upgrades would have also been possible.

-------------------------

MotoshiNakasato | 2022-07-06 23:52:12 UTC | #34

[quote="infu, post:25, topic:14109"]
Literally, everything Psychodelic has done so far is an attempt to take over power from the Internet Computer ecosystem. I hate to break it to you, but this is a hostile takeover at daylight.

Plug - control of the interface and users. (Only that should be bad enough)
Cap - control transaction history.
DAB - control token registry.
XTC - control the wrapped cycles
Terabethia - control the bridge to Ethereum
Cover - control canister code verification
ICNS - control .icp domains
[/quote]

Do you realize that you're saying building (very much needed) infrastructure equals a perverse takeover?

[quote="infu, post:25, topic:14109"]
The community‚Äôs popular opinion is that everyone should use Plug wallet, meanwhile, the big dapps in our eco DSCVR, DISTRIKT, NNS, realize what‚Äôs happening and are using only the proper thing - Internet Identity.
[/quote]

As a member of the community that advocates for Plug as opposed to the II every time I have a chance to I'll tell you why I do:
* it's a familiar interface (metamask)
* I don't have to buy an extra piece of hardware to use it across devices. (Massive point, especially for third worlders (me), one of crypto's target demographics)

The NNS up until recently was an absolutely horrible experience to use, and I'm glad that's changing (and love the sns), but naturally people gravitated towards the services with not so terrible interfaces, and especially not so alienating ones. And the alienating point is relevant too because it makes plug not really a competitor of II or the SNS, but an alternative for people that prefer to stick with what they know, and this is how I felt when I started navigating the ecosystem myself, if the only means of authentication on ICP was the II i probably wouldn't have stayed in the ecosystem, especially given the horrid marketing we've had, so I think you're making the situation a lot more adversarial than it should be.
I think psychedelic should be appreciated as a group of people that decided to build high end infra and other awesome products in an ecosystem in such a tough spot as ICP was and still is today.

In simple words, instead of crying to daddy to force people to lick this or that popsicle try to make a popsicle people want to lick, you have an absolutely anti-crypto mentality imo

Pd: I am however in favor of incentivizing psychedelic devs to engage in the forums if they're not doing so sufficiently, since they're such an important actor in the ecosystem

-------------------------

therealtruth | 2022-07-06 23:04:03 UTC | #35

 All I can see that Psychedelic has done is bought out a bunch of projects/devs that serve their purpose of becoming the front-end for the IC. Haven't seen much innovation from them.

We don't need Plug Wallet, when there are so many wallets on the IC - NFID, Earth Wallet etc... We don't need Cap. Dab kinda borderline useful, but only because Dfinity failed to set a token standard for NFTs. Terabethia is like pouring money down the drain given the IC's native integrations. ICNS was bought out and there's already IC Naming.

Yeah, not much innovation, just VCs at it again. I heard Psychedelic has a multimillion fund to invest? Which explains all the corporate acquisitions. It would be nice if there were an even playing field for projects. Does one entity really need to be doing NFTs, Tokens, wallets, exchange, bridges, aggregators, code verification. Might be better if they just chose to do one thing well lol.

-------------------------

MotoshiNakasato | 2022-07-06 23:26:45 UTC | #36

[quote="therealtruth, post:35, topic:14109"]
We don‚Äôt need Plug Wallet, when there are so many wallets on the IC - NFID, Earth Wallet etc‚Ä¶ We don‚Äôt need Cap.
[/quote]

Let me begin by attacking your premise, what do you mean by "we don't need..."? I don't understand the thought process here, the service is there and people choose to use it, period. NFID wasn't a thing until a month ago, and I love NFID btw, it solves the problem I mentioned above about authentication across devices. And Earth Wallet is just there, i don't understand your expectation in mentioning competing services, I don't think Psychedelic invented the internet or cured cancer, I think they were very proactive and built services I personally appreciate (Plug, Jelly, Crowns (the nft, not CAP the service)). And if we don't need CAP why is it being used?
IC naming had an horrid execution, and I'm telling you this owning a bunch of amazing IC naming domain names.
I'm not aware of their resources, I honestly thought they were a bit amateur because their UIs aren't very appealing, I don't really like the Jelly logo, etc. But they do seem very quick, and somewhat aggressive in how they operate, which I don't have a problem with but understand that other actors in the ecosystem may perceive it as negative, case in point is IC Naming. I hope no one stops building on the IC and that communication between all parts happens in order to avoid unnecessarily adversarial behavior

-------------------------

therealtruth | 2022-07-06 23:34:37 UTC | #37

I heard they were a $200 million fund. But I don't get why they don't do more  to promote the IC from an even playing field and invest like normal investors. Don't get why they buy out projects and force them to use alternatives to the IC, undermining the IC. Terabethia vs native integrations, plug vs II/NFID and this new dip20/ 721 token standard lol... they could do a lot more to support and empower the IC rather than compete with literally everyone with their money.

-------------------------

MotoshiNakasato | 2022-07-06 23:45:01 UTC | #38

The only point I could agree with you about is terabethia, I don't understand why they'd pursue a traditional bridge over a native integration, I know they're developing a game on ETH and are planning to use the IC as part of the back-end of the game so that may have to do with it. I really don't see Plug as a threat or even a direct competitor to II/NFID for the reasons I listed above and I think it absolutely is positive to have Plug as an option and if anything have a slow transition to II that is on par with people's  learning curve. I personally use both and can see II becoming the standard but we are not there yet. When it comes to their funding I don't immediately see reasons to care, I want the ecosystem to grow at the pace they've been proposing, the IC *needs* to outgrow other chains. We can't afford not to.

-------------------------

Zane | 2022-07-07 08:44:53 UTC | #39

[quote="MotoshiNakasato, post:34, topic:14109"]
Do you realize that you‚Äôre saying building (very much needed) infrastructure equals a perverse takeover?
[/quote]

More than building infrastructure to me it seems they start a bunch of projects to have first mover advantage and get dApps locked with their services, would have been better if they stuck with 2/3 projects but actually developed them with a steady pace. Plug, their most used product, still doesn't support hardware wallets and can't be used for local development, it's ridicolous.

>The only point I could agree with you about is terabethia, I don‚Äôt understand why they‚Äôd pursue a traditional bridge over a native integration

I disagree, Terabethia is the only project which in my opinion they should have focused on, native integrations take time to implement and we will never have all chains natively integrated so bridges will always be needed. Now it makes sense to have an ETH bridge cause the native integration is at the very least 6 months away but for DeFi to start we need liquidity and tokens, which ETH has plenty of.

-------------------------

Zane | 2022-07-07 05:06:09 UTC | #40

What do you think about Enoki's implementation? It seems to follow a similar concept but with sharding on top

-------------------------

Sal_Paradise | 2022-07-07 07:18:30 UTC | #41

https://twitter.com/psychedelicDAO/status/1544835615904174081?s=20&t=4rmz5ozZJcMAdK1IG0qGoQ

-------------------------

therealtruth | 2022-07-07 07:23:34 UTC | #42

[quote="Sal_Paradise, post:41, topic:14109"]
https://twitter.com/psychedelicDAO/status/1544835615904174081?s=20&t=4rmz5ozZJcMAdK1IG0qGoQ
[/quote]

hahah, literally compete with Dfinity on everything. it's actually comical (or should i say tragicomical).

-------------------------

Zane | 2022-07-07 07:26:21 UTC | #43

Stuff like this makes @infu claims much more believable, If they don't like the SNS design why haven't they communicated their doubts in the forums? They say the SNS has "significant issues that won‚Äôt meet the needs of most projects", so what are they? Why release an alternative framework instead of forking the SNS and modify it?

-------------------------

Sal_Paradise | 2022-07-07 07:57:16 UTC | #44

Not sure it's a particularly good idea considering Dfinity is the biggest Crypto R&D team in the world and has 270+ employees, lol

They should start focussing on one product and perfecting that. As the old saying goes "jack of all trades, master of none"

-------------------------

infu | 2022-07-07 13:01:34 UTC | #45

[quote="MotoshiNakasato, post:34, topic:14109"]
In simple words, instead of crying to daddy to force people to lick this or that popsicle try to make a popsicle people want to lick, you have an absolutely anti-crypto mentality imo
[/quote]

Thanks for the allegory, let me build on it.

If NNS & Dfinity are a country - Is it ethical to let a popsicle brand advertise itself as healthy food while having a little bit of heroin in it? Children will be happy (for a while) they will love it. Parents will be happy having calm kids around. Investors in the popsicle brand will be happy, short term their stock will be skyrocketing.

Do we poll the drug-induced children & the popsicle brand on what to do next and how to run the country?

-------------------------

roman-kashitsyn | 2022-07-07 18:03:44 UTC | #46

Could you please give a few examples of issues you face? That'll be useful to understand how necessary the 2-step transfer is. I implemented this flow as an exercise; it adds a lot of complexity to the ledger. We need to be 100% that we can't do without it before making it obligatory for all implementations.

-------------------------

justmythoughts | 2022-07-07 14:44:28 UTC | #47

100% against this forced and rushed consolidation of a ‚Äúmake everyone happy‚Äù standard, especially since it seems to add a fair amount of overhead, code complexity, and required future maintenance. 

Instead of consolidating, DFINITY should focus on tooling that allow developers to more easily tag & inspect other canister interfaces in order to interact with those payment flow signatures.

3-5 main token standards will develop, and will have financial incentives to organically collaborate in order to provide interoperability  with one another and to reduce friction. 

This decision doesn‚Äôt need to and shouldn‚Äôt be mediated through DFINITY, and I‚Äôm surprised this standard will be solidified by the current plans for it to be integrated into the SNS and BTC ledgers.

-------------------------

mariop | 2022-07-08 07:42:57 UTC | #48

[quote="justmythoughts, post:47, topic:14109, full:true"]
100% against this forced and rushed consolidation of a ‚Äúmake everyone happy‚Äù standard, especially since it seems to add a fair amount of overhead, code complexity, and required future maintenance.
[/quote]

The standard is not forced nor rushed. We had several iterations around it and we are naturally reaching a good state for the standard. That's why we started coding it.

Parts that feel rushed can be factored out of ICRC-1. We can always discuss about them in future sessions and add them to a standard that extends ICRC-1.

I strongly encourage everybody to participate and push back against complexity. The complexity of the standard can be decided by the working group.

[quote="justmythoughts, post:47, topic:14109, full:true"]
3-5 main token standards will develop, and will have financial incentives to organically collaborate in order to provide interoperability with one another and to reduce friction.
[/quote]

Having 3-5 token standards for fungible tokens seems counterproductive. We should provide a nice experience for users and I'm pretty sure you can't do that with so many standards. Incidentally this is the reason why a part of the community was interested in this effort.

Note that it may end up that the standard is compatible with existing ones. It's not necessarily a replacement. That would be great actually.

[quote="justmythoughts, post:47, topic:14109, full:true"]
I‚Äôm surprised this standard will be solidified by the current plans for it to be integrated into the SNS and BTC ledgers.
[/quote]

It actually makes a lot of sense in order to avoid a second ICP Ledger that is not supported. Wrappers are not really an option here unless you want a wrapped token per standard per DAO token.

-------------------------

Zane | 2022-07-07 16:28:41 UTC | #49

[quote="Sal_Paradise, post:44, topic:14109"]
Not sure it‚Äôs a particularly good idea
[/quote]

It seems they're succeding though, considering both their standard and wallet is more used than Dfinity's.

I just had a brief chat with one of Psychedelic's dev: https://twitter.com/psychedelicDAO/status/1545013761144229888

Looks like they are quite adamant in going forward with their own standard, at this point I think Dfinity should contact directly all major Defi devs and ask what they're planning to do with ICRC1, if they aren't convinced and want to go forward with their own solution then we might have to reconsider the work done and go back to the drawing board. I'd also be curious why Psychedelic's objections have fallen on deaf ears, they seemed quite frustrated with Dfinity's practices.

>Parts that feel rushed can be factored out ICRC-1. We can always discuss about them in future sessions and add them to a standard that extends ICRC-1.

I'm not sure how convenient this is, with my limited experience I've come to the realization a token standard isn't something that should be iterated on, especially not the way we are planning to do. If we want to extend it with new features that makes the old ones outdated we'd end up with a bloated standard, services will have to support many payment flows and even worse projects will either have to miss out on new features or migrate to a V2/3/N canister.

I think we should stop for a second and ask ourselves: Why release an official standard as soon as possible?
1) ckBTC
2) SNS
3) Kickstart DeFi
DeFi won't benefit from an interim standard that isn't widely supported, SNS is meeting lots of critics and should also be slowed down to act upon community's feedback and imo ckBTC can wait if we can get a more solid standard that can be implemented without ever looking back as a result.

Lots of interesting ideas have been rejected during WGs cause they would have delayed the standard, it would have been nice to know by how much and in case of prioritization what would have been put on the backburner to prioritize them, e.g ETH integration delayed to implement named callbacks. Then we could have a community vote to decide what's the best course of action.

-------------------------

MotoshiNakasato | 2022-07-07 18:08:45 UTC | #50

I would agree with this analogy if what they're building is patently damaging, which I think the opposite is the case for the reasons I typed out in the post you're replying to. I think of ICP as a platform that can absorb all demand, because it's so flexible it can do anything. I prefer to have more options available for any service, that I can use my personal judgment to choose from, not less options, I don't want "experts" to force me to use this or that service. It's on you to prove that psychedelic has heroin in it, your post on their intent is borderline conspiracy theory at this point, unless you have information you're not sharing.

-------------------------

MotoshiNakasato | 2022-07-07 18:16:05 UTC | #51

"noooo I don't want independent developers that disagree with dfinity's approach to build their own service"

Really dude? You understand what open infrastructure means yeah?
Dfinity has had an ultra conservative approach to their services, example they want to whitelist projects through the NNS first, so I'm actually glad a more open alternative is being built. DFINITY could just use the NNS to have a subsection of the SNS as "verified" or "safe" and allow people to filter their options in order to be under the wing of "experts" IF THEY SO CHOOSE. Instead of literally denying the service to initiatives they don't deem worthy and denying people that like to judge by themselves the opportunity to take risks.

-------------------------

Bevis | 2022-07-08 00:59:18 UTC | #52

I think NNS controls SNS. I think it's necessary. Let's take a look at the titanium chain, the coin security smart chain, and the fire coin chain. If you want to issue coins, you can issue coins? What concept project can be launched? After selling money, the world evaporated. In terms of project quantity, most of these chains are rubbish. The ICP launched by cheating people and money must break through their model and become a high-quality chain. I support NNS control SNS.

If you don't want NNS to control SNS projects but want to develop on IC, you can give up SNS's coin-issuing mode. SNS is not mandatory.

-------------------------

Forreal | 2022-07-08 03:01:25 UTC | #53

So why not leave things as they are and let them play out?

-------------------------

infu | 2022-07-08 09:54:41 UTC | #54

Here a sequence diagram demonstrating the current flow (without the new approve-commit)

![icrc|660x500](upload://884Cs73B0uoaNefjiMpu4jZlc3x.png)
Legend: 
**Account** - AccountIdentifier - AID
**Treasury account** - One account where all tokens are gathered (eliminates the need to store in memory every RCA clients sent tokens to)
**RCA** - receiver controlled account. Generated with accountIdentifier.fromPrincipal(reciever_principal, subaccount), where subaccount could be:
1) random
2) the client accountIdentifier
3) id obtained from Receiver 


I usually end up using (2) because * client can easily resume - it's always the same * Receiver doesn't have to store anything in memory * Receiver can only let Client with the correct Principal to use the notify function and nobody else

---
You can make your own easily here: https://sequencediagram.org/
The code generating this one:
```
title ICRC-1 Successful transfer & notification

actor Client
participant Ledger
participant Receiver

Client->Ledger:transfer tokens to receiver controlled account (RCA)
Ledger-->Client:transfer successful
Client->Receiver:notify
Receiver->Ledger:query balance of RCA
Ledger-->Receiver:balance
Receiver->Ledger:transfer tokens to receiver treasury account
Ledger-->Receiver:transfer successful
Receiver-->Client:success
```

-------------------------

infu | 2022-07-08 10:02:21 UTC | #55

Here is an even faster flow
![icrc (2)|647x500](upload://a5iesNBnyN2b5S17Zd2bKcYh3Mk.png)

Cons: it depends on a query, which only asks one node, not the whole network, so it may not be as secure?
Receiver has to implement a collection mechanism which will gather all tokens at some point, otherwise using them is hard

-------------------------

Zane | 2022-07-08 16:33:50 UTC | #56

This is what the flow should look like imo:
![ICRC1|690x409](upload://fAMVh1q4uEXeMPJCJlO9zUKnVlP.png)

The flow shown above would be extremely easy to use, potentially removing the need of 3rd party wallets or services for many interactions and set the IC payment flow apart from other chains.

There would be a place also for approvals with customizable expiration, but it'd require scalable storage and we'd have to figure a system to counter bad actors storing thousands of extremely cheap approvals to drain the ledger, It'd be nice to have but not a must.

-------------------------

domwoe | 2022-07-08 10:33:27 UTC | #57

[quote="infu, post:55, topic:14109"]
Cons: it depends on a query, which only asks one node, not the whole network, so it may not be as secure?
[/quote]

If "Receiver" is a canister then then the "query balance" call is also replicated, i.e. essentially executed as an update call.

-------------------------

infu | 2022-07-08 10:41:01 UTC | #58

![icrc (4)|435x406](upload://s685fFCiPfhiFOT4Yfl5VfcrXDg.png)

If we are going to use notify inter-canister call, then it can be reduced to this.
However, we are told that inter-canister calls going to an untrusted canister can be dangerous.
https://www.joachim-breitner.de/blog/788-How_to_audit_an_Internet_Computer_canister

What I am doing in Anvil is having all my canisters in a safe space where they can call each other and authenticate themselves. So I use notify coming from my Ledger canisters. And I wrap ICP for faster use.

The only drawback to this is that if someone from another ecosystem wants to use my canisters, they have to - (A) wrap ICP with my wrapping canister
(B) - pay with cycles (so far it looks like this is going to be the universal payment method for services because it's built-in in the language and we can't mess with it) @lastmjs suggested we handle ICP the same way, and its a good idea. (But then, how do we make other tokens work beside ICP)
(C) - pay with my own token

-------------------------

Zane | 2022-07-08 10:42:43 UTC | #59

I thought about this approach, but it would imply if the service canister is malicious and never returns anything, the user wouldn't know what happened without querying the ledger. With the flow I proposed the user would be notified of tx result so he knows for sure whether the tokens have been transferred and then he gets to know from the service if he got what he paid for.

[quote="infu, post:58, topic:14109"]
However, we are told that inter-canister calls going to an untrusted canister can be dangerous.
[/quote]
Named callbacks would fix this issue, but its a complex task which would delay the standard by many months (not sure how many).

-------------------------

infu | 2022-07-08 11:49:31 UTC | #60

Now here is the real puzzle. This is the challenge token standards (flows) need to be solving, because they are just a **crypto primitive** used to build bigger machinery.

Atomic swap means you synchronously make the swap or you let clients get a refund. There is no asyncronicity that can somehow drain someone's account without returning them what they paid for. It's just not possible, you always get what you pay for or a refund.

In reality, it seems we are always exhanging one token for another. Even if it is a token for a receipt (a receipt is a token). You may say - but I am just increasing a number in memory in return (but well.. that's what tokens are)

So basically each actor fills their RCA1 and RCA2 accounts with whatever they want. The simplest - two tokens in two different ledgers. Or it could be a token for nothing (Which is a simple one-way transfer). But it could be 2 NFTs + 1 FT against 2 FT + 1NFT like in the picture I have shown (part of Anvil designs) 

![image|690x366](upload://wmRpO2q1P7KEm6o3CPsXakOvosX.jpeg)

What really happens under the hood is this:

![icrc (6)|561x500](upload://sdz3gmCgIJvFYIokh7t3ZlSy031.png)

Cons + puzzle: How do we notify ONE and TWO that the swap happened, Do we use timeouts. If we use timeouts then if TWO is a canister, then does it use heartbeat to constantly poll for an answer? What happens if ONE and TWO are canisters. Or there is another way of notifying them.
**Maybe the new approve-commit changes solve it? Maybe not? Does anyone feel like drawing them?**

(sequencediagram.org)

```
title Atomic swap

actor ONE
actor TWO

participant ICP
participant BTC

participant "Receiver (Custodian)" as Receiver

ONE->ICP:transfer tokens to receiver controlled account (RCA1)
ICP-->ONE:transfer successful
ONE->Receiver:notify
Receiver->ICP:query balance of RCA1
ICP-->Receiver:balance


TWO->BTC:transfer tokens to receiver controlled account (RCA2)
BTC-->TWO:transfer successful
TWO->Receiver:notify
Receiver->BTC:query balance of RCA2
BTC-->Receiver:balance

note over Receiver: Swap internally the owners of RCA1 and RCA2
note over ONE: Wait for timeout and query Receiver
note over TWO: Wait for timeout and query Receiver

ONE->Receiver: request tokens
TWO->Receiver: request tokens
```

-------------------------

Zane | 2022-07-08 11:56:26 UTC | #61

Another potential flow could be this one, combining both approvals and notications:
![ICRC1-a|412x468](upload://72QvCYwnZ2v850lajiMf3OsQTxO.png)

The benefit of it are:
1) If the service canister is down the transfer isn't immediately executed so the client still owns the tokens and can revoke the approval.
2) If the service canister can't process the payment due to potential errors or the service being purchased not being available anymore, e.g NFT bought by someone else, there is no need to handle refund logic, just deny the transfer.

-------------------------

infu | 2022-07-08 12:26:07 UTC | #62

case: ONE and TWO are canisters
Turns out it's not that hard to do with the existing mechanics
Note: When ONE does "initiate" it is an untrusted inter-canister call so it's not waiting for a response. Instead, Receiver (trusted custodian) is calling ONE later
![icrc (7)|483x500](upload://dTePeDNrQJUsMFJcTbtbMZKfrrf.png)

Now at that point ONE and TWO can call Reciever and move their tokens from RCA1 and RCA2 to wherever they want. 
Or - we can do it before sending success. For that to happen, both "notify" calls need to be providing target account identifiers. (I will post that version next)
(Notice in all sequence diagrams how useful Account Identifiers are, one canister owning a lot of them leads to a lot of possibilities)

-------------------------

infu | 2022-07-08 12:52:19 UTC | #63

![icrc (8)|453x500](upload://dU2LbVWAhFW4ZgaP4sb6lRK0pLX.png)

And there we have the whole solution. 
**Claim 1: everything needed for DeFi is atomic swap. Transfer functions are basically atomic swap where one of the parties gets nothing**
**Claim 2: that exact flow solves everything DeFi needs and does it with the existing token flow used for a long time by ICP Ledger.** No changes needed.

Can anyone see problems with this? 


```title Atomic swap between canister owners (diagram code: ASC1)

actor "ONE (Initiator)" as ONE
actor TWO

participant ICP
participant BTC

participant "Receiver (Custodian)" as Receiver
ONE->ICP:transfer tokens to receiver controlled account (RCA1)
ICP-->ONE:transfer successful
ONE->Receiver:notify
Receiver->ICP:query balance of RCA1
ICP-->Receiver:balance
Receiver-->ONE:success
ONE->TWO:initiate

TWO->Receiver: query to get confirmation ONE has done their part of the deal
Receiver-->TWO: Yes, proceed

TWO->BTC:transfer tokens to receiver controlled account (RCA2)
BTC-->TWO:transfer successful
TWO->Receiver:notify
Receiver->BTC:query balance of RCA2
BTC-->Receiver:balance

note over Receiver: Swap internally the owners of RCA1 and RCA2. From now on swap is done
note over Receiver: From now on If async calls fail, ONE and TWO can manually request tokens

Receiver->ICP: transfer tokens to final account 1
ICP-->Receiver: success
Receiver->BTC: transfer tokens to final account 2 
BTC-->Receiver: success

Receiver->ONE: success
Receiver-->TWO:success
```

Ratoko FTW

-------------------------

Zane | 2022-07-08 13:05:14 UTC | #64

[quote="infu, post:63, topic:14109"]
Can anyone see problems with this?
[/quote]

If the service goes down after the first transfer you'd lose the money, at the same time the service also has to handle cases where the TWO party backs down from the deal and refund ONE.

-------------------------

infu | 2022-07-08 13:22:10 UTC | #65

Thanks for your challenging it.
I have shown the successful flow, if things start erroring, I would have to make 50-60 sequence diagrams showing how it works, but I am pretty sure there won't be a problem. The reason is if Receiver goes down (I am assuming this means the connection fell apart, not that Receiver has gone malicious.)
ONE can call the refund function and take its tokens back.
if TWO backs down ONE gets refund as well. 
ONE has all its tokens in RCA1 and Receiver can easily return everything.
RCA1 can be accountIdentifier.fromPrincipal(Receiver, ONE)
Receiver doesn't have to store in memory pairs with RCA1 -> One
Because it can make a check if accountIdentifier.fromPrincipal(Caller, request.subaccount) equals RCA1

Your challenge did not disprove the claim * writing it for easier readability

-------------------------

Zane | 2022-07-08 13:30:54 UTC | #66

>I am assuming this means the connection fell apart, not that Receiver has gone malicious

Could be it became malicious, ran out of funds or became unresponsive due to errors. There is also the possibility the refund logic is flawed.

Having to manually implement refund logic right now is a downside, maybe in future it will be abstracted away by libraries/services but at the moment it has to be coded from scratch, which means you have to be extra careful cause an error could mean losing people's money.

-------------------------

infu | 2022-07-08 13:40:20 UTC | #67

- Malicious code - Not a problem in our current domain. We can get ICP, BTC and Receiver to be canisters controlled by NNS if we can't put trust in anyone except it. You can have malicious code in all of them. You can have the BTC canister lying about sending BTC at the end. We can have a report system inside this which gathers cryptographic evidence in case of such problems.
- Canisters running out of cycles is again a trust problem. Otherwise, anyone can put an auto refueling system.

Your challenges did not disprove the claim

-------------------------

Zane | 2022-07-08 13:51:46 UTC | #68

ICP and BTC canister will be handled by the NNS and their code will 99.9% be safe and non malicious, but you can't expect every service canister's code to be verified. The entire IC is under NNS control but I doubt we can make a proposal and expect it to pass everytime a couple ICPs are stuck in a canister. The effort required to verify what happened is too much, so the community won't care most likely.

-------------------------

skilesare | 2022-07-08 14:26:09 UTC | #69

Sure.  In our mint governance dapp at https://governance.origyn.network/#/ to stake, you 1. Send OGY to the governance canister, 2. Claim them. 3. Stake them. 

From a useability standpoint If 1 failed due to a network issue we can just try again. If 2 fails then they have stranded tokens on the server and we have to build some search code to look at the ledger and 'refind' a user's unburned transaction. If 3 fails then we have deposited tokens but they aren't staked and we have to expose a direct deposit function(Now we have two ways of doing something which confuses users).

When we have a commit_approve this will be a bit easier because the tokens won't actually move until we're ready for them.

-------------------------

infu | 2022-07-08 14:49:34 UTC | #70

It is true that you can't trust canisters easily. They have to be owned by NNS or another reputable DAO. That is the plan and what DAOs do, decentralize governance to gain trust.

So the first way where each developer deploys their own canisters looks like this:
![image|690x399](upload://qYoiW3dZuRvj9gX319rjIrLaPCP.jpeg)


The problem you specify is real, it just requires a bigger change I am not sure everyone will be up to. The solution above is using canisters anyone can deploy (*1). Devs can also add custom code to these Ledger canisters, which I currently don't know if it's beneficial or not compared to a solution where Ledger canisters are all the same and customization is done with configuration. So far I haven't found something that can't be done.

Now it may seem like we were plotting towards this moment, when I am going to advertise :) But the other solution is what (open-source) Anvil infrastructure is actually doing and I am working on it for 9 months now ( I have started with NFTs because they are less dangerous to start with, but it also has FTs). There is a gate controlled by a DAO and all tokens are created through it, configured and the DAO makes sure it's all executed as planned and even their creators can't mess with some token properties. This DAO could be the NNS, this could result in everyone adopting it. (Note, this does not mean there can be only one of these, there can be more NNS-controlled gates/mints) Or if the NNS doesn't want to get Anvil from me and govern it, it could be our own ANV token, but adoption will be local. Or every ecosystem can have one of these multi-token mints, because they are not sure if one will work for all, because of ->(*1)
Personally, I prefer working, finishing it, and transferring keys to the kingdom to NNS for a reward. Rather than getting VC funding, selling a new token, and IC having another token we have to decentralize, rooted in the foundation of an ecosystem. It will result in many ecosystems splitting developers. Developers working to exit to NNS should be hundreds of times cheaper and more secure for the IC ecosystem and ICP token-holders.

The DAO-controlled multi-token mints look like this (this is using the current Anvil multi-canister multi-subnet token solving the issue where one subnet is loaded and the 750 concurrent users threshold for single canister tokens you have mentioned in Discord. But the multi-cansiter token is whole other thing down the rabbit hole. Diagram will look similar with single canister tokens)
![image|690x341](upload://7pKRlTICTCrIjoL6mAigCqEqRgz.jpeg)

-------------------------

skilesare | 2022-07-08 15:23:59 UTC | #71

We discussed doing notify with one shot that would be secure. I think it was moved away from because of complexity, but I think it should be an extension.  Maybe I'll work up the notify extension and see if we can't get it included.

-------------------------

mariop | 2022-07-08 15:26:11 UTC | #72

We postponed `notify` just because a change at replica level, either one-shot or named callbacks, is needed in order to properly support `notify`. We will definitely talk about it in future as an extension.

-------------------------

roman-kashitsyn | 2022-07-08 15:26:16 UTC | #73

Thanks!

I recall that we had similar issues in the NNS Dapp and CMC.

I think the argument here is that a complex multi-step action is much more likely to succeed if it runs on the IC and not on the client. So requiring the client to make a transfer followed by notification is riskier than requiring the client to approve and then notify.

`approve`/`transferFrom` flow is probably not the only way to address the unreliability of the client. I wonder if the notify flow (that we agreed we want to have as an extension once named callbacks are available) can address the issue as well: in this case, a single `transferAndNotify` call would make the transfer and notify the governance, so even if the client fails, the governance won't have troubles learning about the transaction.

-------------------------

Zane | 2022-07-08 17:10:32 UTC | #74

[quote="mariop, post:72, topic:14109"]
in future as an extension
[/quote]
Not sure if they can be called extensions, to me they look like completely new standards considering blackholed ledger and service canisters using the first version won't be able to use the new features.
If we keep adding features to a standard that make the old ones obsolete in the long run it will have add needlessy complexity for services that need to support all payment flows.

[quote="roman-kashitsyn, post:73, topic:14109"]
`transferAndNotify` call would make the transfer and notify the governance
[/quote]
Something like this?

[quote="Zane, post:56, topic:14109"]
![ICRC1|690x409](upload://fAMVh1q4uEXeMPJCJlO9zUKnVlP)

ICRC1788√ó468 10.4 KB
[/quote]

-------------------------

infu | 2022-07-08 16:05:30 UTC | #75

I have had "hanging" tokens in between calls too (because of some interruption). Maybe it was something like your problem. So far I have solved them by saving an id (sometimes not needed) in browser localStorage. Then a function (on browser focus) is checking if there are such unresolved ids and resuming the requests. That is so far works but looks like a hack.

So let us try to fix that. The default way of doing things (At least what first comes to mind) is that when a user authenticates in a dapp with Internet Identity, the dapp is given a public key and PrincipalId.
From there we have been directly transforming the PrincipalId + subaccount to AccountIdentifier.
Then directly calling the Ledger. 

I have been thinking for a while. What if we don't do it directly, but let a canister owned by the dapp be in the middle - called Wallet. So the AccountIdentifier we show in the dapp (with user personal tokens) is actually 
AccountIdentifier.fromPrincipal(Wallet, UserPrincipal)
 and not
AccountIdentifier.fromPrincipal(UserPrincipal, null)

Now when a canister is holding it, communication perhaps will be more secure, we can save things into memory, resume if we need to and it can be called by other canisters, while browser cant. It can proxy all calls or only selected. 
So in the diagram below, ONE is a canister - the Wallet. TWO is let's say staking canister.
The idea is that we are swapping ICP for ICP_LP (staked or in a liquidity pool)
![icrc (10)|477x500](upload://9V6j1vr13KAjLjeVGKkx5g4My3z.png)

-------------------------

skilesare | 2022-07-08 16:25:44 UTC | #76

With an on chain wallet a good bit of this can be automated away from the user. :slight_smile: It is on the road map for Origyn and ICDevs has a bounty out on it.  Hopefully, we have a starter on-chain wallet soon.

-------------------------

roman-kashitsyn | 2022-07-08 18:01:46 UTC | #77

[quote="Zane, post:74, topic:14109"]
Not sure if they can be called extensions, to me they look like completely new standards considering blackholed ledger and service canisters using the first version won‚Äôt be able to use the new features.
[/quote]

The model I had in mind is [XMPP](https://xmpp.org/): it has a core messaging part and hundreds of [extensions](https://xmpp.org/extensions/xep-0001.html) (XEPs). You can send messages around securely without any extensions, so it's not terribly hard to implement a client (I used to use a client implemented in Emacs lisp), but extensions provide a lot of quality-of-life improvements to the protocol.

The extensions won't supersede existing functions, they will extend the capabilities. Some extensions I have in mind:
1. `transferAndNotify` and `notify`. They don't make `transfer` obsolete in any way.
2. Specification for standard block encoding and certification. This is crucial to implementing a rosetta node.
3. Specification for executing transactions pre-signed by the sender, the flow that Jordan proposed in one of the working group meetings.

Not all ledgers need to implement all the features. Services like DEXes can inspect the capabilities of a ledger and use a more efficient flow if it's supported or fall back to the core API otherwise.

[quote="Zane, post:74, topic:14109"]
If we keep adding features to a standard that make the old ones obsolete in the long run it will have add needlessy complexity for services that need to support all payment flows.
[/quote]

I firmly believe that it's far more important to have an evolution path than to have a perfect artifact. IC is going to evolve, the core teams will ship new exciting features that can change the way we think about canister communication. No matter what we standardize now, there will be better ways of solving problems.

Side note on blackholed canisters (that's my opinion, not necessarily reflecting the views of my employer): I think the concept of immutability is overrated:

  1. All interesting software is buggy; I can't imagine how we could trust a system that cannot be fixed if a major flaw is discovered.

  2. In a Turing-complete environment, immutability doesn't mean much. Code is data. Are you sure the canister doesn't have a little stack machine interpreter somewhere and a hidden endpoint that allows the authors to upload a script? Or maybe it has a switch that forces the canister to forward all calls to another (not blackholed) canister?

[quote="Zane, post:74, topic:14109"]
Something like this?
[/quote]
Yes, something like that (I assume the "success" after notify should go to the ledger, not to the client).

-------------------------

Zane | 2022-07-08 19:18:12 UTC | #78

[quote="roman-kashitsyn, post:77, topic:14109"]
Services like DEXes can inspect the capabilities of a ledger and use a more efficient flow if it‚Äôs supported or fall back to the core API otherwise.
[/quote]

Which means the more flows we add, the more code DEXes and services have to write, test and maintain.

[quote="roman-kashitsyn, post:77, topic:14109"]
All interesting software is buggy
[/quote]
True, but a ledger isn't that complex, software running on airplanes is formally verified, we could do the same with the ledger code and provide everyone with a bug free implementation.

[quote="roman-kashitsyn, post:77, topic:14109"]
re you sure the canister doesn‚Äôt have a little stack machine interpreter somewhere and a hidden endpoint that allows the authors to upload a script?
[/quote]
Verified builds can be used for open source code. Immutability is a must for a ledger, without it there is no point in using a blockchain. I know DAOs can be used but it's not easy to make sure the allocations and distribution are done correctly, it requires effort on the devs end and trust by the user, which is something we are trying to take out of the equation. 
If you ask me one of IC's biggest flaws right now is precisely the NNS due to how tokens were distributed, even big entities with hundreds of experts can make mistakes. With all recent events surrounding Luna and Solend I'm more skeptical about DAO governance than ever, especially when there is no Proof of Personhood.

[quote="roman-kashitsyn, post:77, topic:14109"]
I assume the ‚Äúsuccess‚Äù after notify should go to the ledger
[/quote]
Actually both ledger and user now that I think about it, the user needs a confirmation to know the purchase went through, ledger needs it so it doesn't keep waiting for a response.

-------------------------

roman-kashitsyn | 2022-07-08 20:29:32 UTC | #79

[quote="Zane, post:78, topic:14109"]
Which means the more flows we add, the more code DEXes and services have to write, test and maintain.
[/quote]

I know it's very tempting to fix an API once and for all, but there are very few successful examples of this approach. The most efficient and convenient APIs are the ones that evolve with the industry. The core of the C standard library is the same as it was 30 years ago, it's also one of the worst examples of API design I'm aware of.

[quote="Zane, post:78, topic:14109"]
software running on airplanes is formally verified
[/quote]

I doubt that all of it is *verified*, most likely, it's merely *certified* by authorities. Maybe the OS kernel is formally verified if they use the seL4 kernel, which is only a few thousands of lines of C code, which required hundreds of thousands of lines of spec and engineer-decades of development effort.

[quote="Zane, post:78, topic:14109"]
a ledger isn‚Äôt that complex
[/quote]

[quote="Zane, post:78, topic:14109"]
Immutability is a must for a ledger, without it there is no point in using a blockchain.
[/quote]

As a person who patched subtle security holes in a ledger holding millions in assets, I politely disagree.

[quote="Zane, post:78, topic:14109"]
Verified builds can be used for open source code.
[/quote]

To verify a build, you need to inspect all the source code, the source code of all dependencies, the source code of the build, and the source code of all the build dependencies (what if the last step of the build script is "throw away the build artifact and replace it with another binary"?). Nothing stops you from reviewing the full JS code of applications you use on the web, but I don't know anyone who does that.

-------------------------

Zane | 2022-07-08 21:57:06 UTC | #81

[quote="roman-kashitsyn, post:79, topic:14109"]
but there are very few successful examples of this approach
[/quote]

I agree it's not easy, but at least we should try to do out best with the knowledge we have at the time, we already know the current standard will be made obsolete by new tech.

Management said there are currently no resources to work on named callbacks and it'd take too much, it would have been nice to know a rough estimate and maybe reconsider some other features to prioritize named callbacks over. Tokenization is one of the key components of Web 3 and as the name suggests a token standard is the foundation of it, as a proof both SNS and ckBTC are blocked by this pillar, considering its importance it would seem reasonable to make it the absolute priority, Dfinity should focus as much as possible on the protocol instead of the application layer, ckBTC and SNS could have been worked on by the community and time spent on them could have been used elsewhere.

Now my question is: is it worth creating future debt for services and headaches for ledger devs for a standard that seems to lack community support? At the very least Dfinity should get a concrete understanding of who will and who won't support it and then evaluate if it's really worth releasing the standard as is.


[quote="roman-kashitsyn, post:79, topic:14109"]
I politely disagree.
[/quote]
I stand corrected on my claim about ledger complexity then, but I'm still firmly convinced a ledger should ideally be as immutable as possible.

-------------------------

infu | 2022-07-09 11:09:58 UTC | #82

[quote="roman-kashitsyn, post:79, topic:14109"]
To verify a build, you need to inspect all the source code, the source code of all dependencies
[/quote]

Isn't that statement valid for Rust, but invalid for Motoko? You don't have to inspect dependencies with Motoko, because it's not as powerful and can't touch memory and ruin things like Rust?
Now when I think about it... I guess there are still ways. If I include SHA256 function it may wait for a secret sequence to start acting malicious. It won't be changing the memory, but it still can result in a vulnerability.

-------------------------

infu | 2022-07-08 22:17:53 UTC | #83

[quote="Zane, post:81, topic:14109"]
I‚Äôm still firmly convinced a ledger should ideally be as immutable as possible.
[/quote]

A ledger needs to add transactions to an infinitely scalable cluster of history canisters. You can make these immutable. It won't sacrifice upgradability. If the DAO goes and messes with the ledger state, this can be proven, because it won't be matching the state you can rebuild from history. This means the DAO will lose trust and its token value will fall. So a DAO doing something like that is a public suicide.  Or it could be interpreted as a hard fork. And someone could copy the whole thing (if it's open-source and it should be) and spawn a new instance that is proveably legit.

-------------------------

levi | 2022-07-08 22:36:52 UTC | #84


@skilesare 

Lets walk this through,

[quote="skilesare, post:69, topic:14109"]
to stake, you 1. Send OGY to the governance canister, 2. Claim them. 3. Stake them.
[/quote]

[quote="skilesare, post:69, topic:14109"]
If 2 fails then they have stranded tokens on the server and we have to build some search code to look at the ledger and ‚Äòrefind‚Äô a user‚Äôs unburned transaction.
[/quote]

What do you mean by stranded tokens? At this point the user's tokens are in the user's-neuron's-subaccount on the governance-canister. The user can re-try the claim-method with the neuron-number. The service managing the user's-staking keeps track of the user's-neuron-numbers like how the nns-dapp-canister works. (there is no need to refind a transaction)

[quote="skilesare, post:69, topic:14109"]
If 3 fails then we have deposited tokens but they aren‚Äôt staked and we have to expose a direct deposit function
[/quote]
What do you mean by 'direct deposit function'? At this point the neuron is registered in the governance canister with a 0 dissolve-delay. The `stake` functionality is the IncreaseDissolveDelay function which makes sense to give the users.

[quote="skilesare, post:69, topic:14109"]
When we have a commit_approve this will be a bit easier because the tokens won‚Äôt actually move until we‚Äôre ready for them.
[/quote]

What are the specific steps you have in mind for a service with an approval to take to get 'ready' for a commit-transfer? The service still has to 1.transfer, 2.claim, and 3.increase-dissolve-delay(stake). Steps 2 or 3 can still fail (if on a heavy load) even if a canister is calling them. the same senarios can happen.

-------------------------

infu | 2022-07-09 12:09:30 UTC | #85

A bit optimised version.

Receiver (Custodian) - can be made immutable and its code can be verified. Once it's no longer viable, because of evolution, we stop using it and use something else. It doesn't hold anything long-term so its easily replaceable. Because its immutable and verifiable, other canisters can trust it.

Maker - someone who has created an order and waits for it to be fulfilled by anyone. That could be a: person trying to swap ICP for BTC
a dex swapping ICP for ICP_BTC_LP
ICP+BTC for ICP_BTC_LP 
staking ANV for ANV_VLP


![icrc (11)|516x500](upload://w3tbO5IFQPL3GgPoFiMlcI2wljT.png)


We could also merge columns in the sequence diagram however we want and that will simplify things. It will make sense if you merge staking (TWO) with its ledger like this

![icrc (12)|510x500](upload://aow7Mnzg01u13NPsVUtygVKFw8J.png)

And even merge Reciever + Market + Ledger, but it's a different trust dynamic, you lose the easy Reciever immutability option, but gain speed. (ignore notes over TWO - wrong now)

![icrc (13)|411x500](upload://kq7XE8NA1SymJySv8Mr3KA9tK4Z.png)

And if we remove the internal canister messages from that diagram, we end up with...

![icrc (15)|667x500](upload://sHtxBdcYi2XCJX9LyiKMedqL6Ic.png)

Which is.. what we started with and use already. The bigger (more complex diagram) is just giving us more options, but we can merge and remove them.

-------------------------

bobbylingus | 2022-07-09 23:06:12 UTC | #86

What is the current state of the standard?

-------------------------

mariop | 2022-07-10 09:47:27 UTC | #87

[quote="bobbylingus, post:86, topic:14109, full:true"]
What is the current state of the standard?
[/quote]

The core of the standard, e.g. address format and the basic functionalities, is [pretty much done](https://github.com/dfinity/ICRC-1/). DFINITY also has an implementation of the core that will be used by SNS and ckBTC.

We are discussing about more sophisticated functionalities now and how to proceed with them.

Overall services and users on the IC will be able to start using the standard very soon.

-------------------------

link2020 | 2022-07-10 09:53:27 UTC | #88

I'm very concerned about this question.
Does the ICRC-1 token standard have Approve and Transfer from methods like ERC20Ôºü

-------------------------

mariop | 2022-07-10 19:32:14 UTC | #89

The standard doesn't have them yet as you can see from [its repository](https://github.com/dfinity/ICRC-1/tree/cdf0f156503335e0cd89111ee3e7ff2994f9cd9f).

The working group which is responsible for the ICRC-1 Token Standard is discussing right now the possibility of adding something similar to ERC-20 approve/transferFrom but with some limitation. This new set of API has the name _2-steps transfer_. You can find part of the discussion [here](https://forum.dfinity.org/t/erc-20s-approve-transferfrom-security-concerns-for-the-icrc-1-token-standard/13610?u=mariop). You can also see the 2-steps transfer methods in the [interface of the ICRC1 Ledger implementation from DFINITY](https://github.com/dfinity/ic/blob/05ec713ace71ea02de1eb59761cdd713fe4204e1/rs/rosetta-api/icrc1/ledger/icrc1.did#L164).

Do you have any specific concerns that I can try to answer?

-------------------------

skilesare | 2022-07-10 22:03:15 UTC | #90

[quote="levi, post:84, topic:14109"]
What do you mean by stranded tokens? At this point the user‚Äôs tokens are in the user‚Äôs-neuron‚Äôs-subaccount on the governance-canister. The user can re-try the claim-method with the neuron-number. The service managing the user‚Äôs-staking keeps track of the user‚Äôs-neuron-numbers like how the nns-dapp-canister works. (there is no need to refind a transaction)
[/quote]

This may be the way the NNS works, but the ogy governance and and origyn nfts work differently. In v1 all the governance canister funds are held in one account(the canister's default account). Who owns what is managed with an internal ledger. To "claim" your deposit you give the governance canister the block height of your deposit and the canister checksnit and burns the block height if valid so you can only claim once. In v2 of the canister we will likely be moving to using subaccounts to keep better seperation of concerns.

From a canister's standpoint the sub account is like magic and saves you a call. The one tough thing is that your client needs to know your sub account schema(ie. Hash of your principal) If everyone knows your schema them you lose a bit of privacy. With everying in one account we can keep your "internal to the canister" transactions more private(but it can also enable more funny business, so a double edged sword.)

-------------------------

infu | 2022-07-11 10:07:36 UTC | #91

Swapper - custodian in the previous posts. Calling it a Swapper, because "custodian" is already used heavily in crypto with a different negative meaning.
Participants put tokens in boxes (accounts controlled by the Swapper) according to order (description of the swap).
Cancelation is available to all participants anytime before the atomic swap.
If all participants placed correct contents in their boxes and nobody canceled, the swap is done.
From there on they can take their contents out.
Maybe this state machine diagram of how the Swapper works will also help.
Note - Swapper is a role, it can be in its own canister (possibly immutable) or inside another canister part of the swap.
Why did I put this in the token standard thread? It describes a solution to the problem (atomic swap) and the token standard is the foundation of the solution. Small changes to the standard cause huge changes ahead. 

![image|690x451](upload://8O83bkNxAKpYPyOCdUNfYCGG1lk.png)

-------------------------

bobbylingus | 2022-07-11 11:31:08 UTC | #92

The standard specifies that the total supply value is Nat32. Does this mean that a total token supply can't exceed 2^32 = 4 294 967 296 tokens ?

-------------------------

mariop | 2022-07-11 12:31:20 UTC | #93

No, that was a mistake. I corrected it now, `icrc1_totalSupply` returns nat64.

-------------------------

infu | 2022-07-11 13:19:10 UTC | #94

While implementing the Swapper and trying to use that latest repo, I stumbled upon this change
![image|690x135](upload://gGmiMy0ftzf6GYZxlyOlCJGq0UB.png)
Before you could query balance by passing AccountIdentifier, now you need to pass principal and subaccount.
This change makes the ledger pretty much use Zero-knowledge proof. If you know someone's AccountIdentifier, you can't query their balance, which is a bit weird. Is that intentional? 
It pretty much becomes a private ledger and not a public one.
Going to post the Swapper soon

-------------------------

roman-kashitsyn | 2022-07-11 13:54:33 UTC | #95

[quote="infu, post:94, topic:14109"]
This change makes the ledger pretty much use Zero-knowledge proof. If you know someone's AccountIdentifier, you can't query their balance, which is a bit weird. Is that intentional?
[/quote]

The ICRC-1 standard doesn't define AccountIdentifiers for multiple reasons:
1. Simpler mental model: We no longer need to explain what account ids are. With account ids, you had to learn about three entities (principals, subaccounts, account ids). With ICRC-1, you need just two entities (principals and subaccounts).
2. Client code is simpler and easier to get right: you don't need to link CRC-32 and SHA-224 libraries into each client anymore.
3. Once we extend the interface to expose the block structure, dapps can scan the blocks to detect transactions to and from specific principals. Having principals and subaccounts explicitly will enable new flows (e.g., an app can proactively monitor the ledger transactions for transfers). The ICP ledger won't support this extension.

If you're working with the ICP ledger built around account identifiers, you can use its interface (instead of the ICRC-1 interface) to look up the balance by an account identifier.

-------------------------

infu | 2022-07-11 14:30:27 UTC | #96

Valid reasons. I like the idea of not using sha-224 and crc-32. 

Simpler mental mode, not so much. I am not explaining to users in my dapp what Principals are and not showing it at all and it works pretty well, not a single user complained.

But how will that work? Our accounts will always go in pairs Principal + subaccount. Currently, no blockchain requires two things to identify one account. So I guess we will end up creating a new AccountIdentifier, which has both pieces inside concatenated instead of hashed?

-------------------------

infu | 2022-07-11 16:35:46 UTC | #97

Swapper working prototype is done :fireworks: :sparkler: :fireworks:
 https://github.com/infu/swapper

Also here (wont be updated) (Motoko playground): https://m7sm4-2iaaa-aaaab-qabra-cai.raw.ic0.app/?tag=3795373633

It works according to the diagrams shown above using only `balance` and `transfer` to achieve everything needed.
It's not DoS resistant yet and may need a few more things to get easier to use

Realizations while making it: I think we need a `fee` function in the standard, each token may have a different fee even if using the same standard. The smart contract needs to query the fees for each token and add them to the requirements, otherwise, it won't be able to transfer tokens out. You could return it in the balance query so only one call is made instead of two.

-------------------------

levi | 2022-07-12 01:05:48 UTC | #98

[quote="skilesare, post:90, topic:14109"]
the ogy governance and and origyn nfts work differentl
[/quote]

If you are writing your own governance canister, you can write your own ledger canister where in the `transfer`-method, if the transfer is for the governance-canister, the ledger-canister first calls the governance-canister to stake, and if the call is success, makes the transfer.

-------------------------

link2020 | 2022-07-12 03:36:58 UTC | #99

Thanks so much.
One more question.
The tokens issued by ICRC -1 use Principal ID. But ICP uses Account ID.
Will users feel confused?

-------------------------

zran | 2022-07-12 03:45:51 UTC | #100

I think the biggest risk now is that token functions can be called directly. For example, in a game dapp, it is necessary to obtain Principal to mark a player. At this time, if there is a token in the player's Principal, the game can directly call transfer to steal the player's token without the player's confirmation. Whether ICRC-1 solves this problem„ÄÇ

-------------------------

jzxchiang | 2022-07-12 06:15:06 UTC | #101

@mariop Apologies if this has been asked before, but what is the difference between this ICRC [interface](https://github.com/dfinity/ic/blob/master/rs/rosetta-api/icrc1/ledger/icrc1.did) and this [one](https://github.com/dfinity/ICRC-1/blob/main/ICRC-1.did)? Which should I believe? Why are there two?

-------------------------


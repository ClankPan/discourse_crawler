ais | 2022-11-25 16:15:52 UTC | #1

**TL;DR We want to add privacy to the IC by enabling canisters to perform threshold key derivation**

# Summary

Empower dapps to perform encryption, threshold decryption, and signing on the IC by allowing canisters to call a threshold key derivation interface. This feature will enable canisters or individual users to encrypt messages under the public key of the subnet, so that they can be decrypted by calling the threshold key derivation interface for the corresponding decryption key that is secret-shared among the replicas. Integrating this feature will enable canisters to store end-to-end encrypted user data (e.g., storage, messaging, social networks) without having to rely on browser storage for user-side secrets, as well as enabling transaction privacy within canisters (e.g., closed-bid auctions, front-running prevention).

# Status

Discussing

# Key People Involved

@gregory, @andrea, @ais, @franzstefan, & @victorshoup 

# Timelines

* 1-pager on the Forum (to follow shortly after we see your first comments/requirements)
* 1st Community Conversation (Concept, context, and use cases, community questions. Confirmed for Nov 29th - Register [here](https://internetcomputer.org/live-sessions#Community-Conversation-Threshold-Key-Derivation-How-a-Blockchain-Can-Keep-Many-Secrets)!)
* 2nd Community Conversation (Presentation of proposed design)
* NNS Motion Proposal (to approve design + project)
* If the NNS Motion Proposal passes, implementation and deployment would take a few months

# Description

The promise of blockchain technologies is to remove a central point of trust allowing anyone to read, write, and verify data on the system. This is often achieved by making operations and data stored on blockchains publicly visible. While this transparency can be useful to build the trust needed in a decentralized system, it can also be prohibitive. This includes using blockchains for public, but also for private and business reasons. Removing a central point of trust should not mean that everyone should sacrifice confidentiality of their data.

Given the existence of public-key encryption, itâ€™s easy to encrypt data and send it or store it on a blockchain, but problems arise when we want to decrypt, especially in the distributed setting. Storing the decryption key on a userâ€™s device is secure and useful in the traditional E2EE case, but if we want to share decryption capabilities, while still maintaining privacy (no single node knows the key), a flexible approach is to require the participation of some threshold of parties. In this proposal we aim to build such a threshold (decryption) key derivation scheme.

**High level objective**
* Make a threshold key derivation Interface
* Canisters can obtain encrypted threshold signatures
* Allow symmetric encryption and public key / identity-based encryption

**Proposal description:** Motivated by E2EE and front running use cases, we aim to build a flexible and scalable solution to achieve user privacy by means of a new cryptographic building block called ***verifiably encrypted threshold key derivation* (vetKD)**. In brief, vetKD can be seen as the key derivation of an (identity-based) encryption scheme where the master secret is secret-shared among a set of servers that can assist users in deriving keys by sending encrypted shares of those keys to the users. The shares are encrypted under a public key provided by the user, so that the servers do not learn the derived key, but can verify that a ciphertext indeed contains a valid key share. Users are therefore guaranteed to recover the correct key if they receive sufficiently many encrypted shares.

A first sketch for an Interface that you can call on the mgmt canister would like something like:
`derive_encrypted_key(master_key_id, transport_public_key, identity) -> EncryptedKey`

Potential applications include:
* End to end encryption
* Secret bid auctions and MEV protection
* Time-lock encryption
* Dead manâ€™s switch
* â€¦

# Next steps
The first step is to **get feedback** from the community. Weâ€™re particularly interested to hear what are the issues you have faced wrt privacy or confidentiality. Is there something you couldnâ€™t build because you didnâ€™t have this feature, or do you have specific examples of where it could be useful?

We then plan to outline a design and present it in a community conversation, after which weâ€™re happy to take comments and to adapt. Beyond this, we plan to open the more general privacy conversation by hosting twitter spaces and growing a community in the [privacy portal](https://dscvr.one/p/privacy).

Then weâ€™ll issue a motion proposal, which, if accepted, will spark development.

-------------------------

skilesare | 2022-11-14 16:06:09 UTC | #2

This is an amazing feature and we need it.  Looking forward to the discussion.

-------------------------

jzxchiang | 2022-11-14 16:10:00 UTC | #3

Do you mind elaborating on who will be using the derived decryption keys? Do the canisters use the key to decrypt user data before returning it to the user (as part of a query method)?

I'm also confused whether the "master key" is user-provided or equivalent to the subnet public key. Sorry id these are silly questions.

-------------------------

gregory | 2022-11-14 18:16:37 UTC | #4

Great questions, @jzxchiang !

As for who will be using the derived decryption keys: it could be either the canister, or the user himself. In the latter case, the shares of the decryption key will be sent to the user, encrypted under a "transport key" that the user provided. This way, neither the canister, nor any of the replicas learns the decryption key.

Wrt the master key: yes, you can think of it as the subnet public key. It is generated in a decentralized manner by the nodes in the subnet so that the master secret key is never reconstructed on any machine.

-------------------------

rabbithole | 2022-11-14 20:58:57 UTC | #5

This is definitely what I need!

The current implementation has to store the key on the client side and this creates an UX/UI problem. A user can easily lose access to data if he does not have a key synchronized on another device.

As I understand it, the canister can have the ability to work with encrypted data. The canister, like the user, can be the recipient of the decryption key. That is, the canister can process encrypted data and create new ones based on them. For example, I'm interested in generating previews for encrypted images. Now this needs to be done on the client and sent in encrypted form to the canister.

P.S. I am glad that this topic is being raised and efforts are being made to implement it, this will make a qualitative step in building applications!

-------------------------

apotheosis | 2022-11-14 23:57:30 UTC | #6

Sounds like a good use case of Shamirâ€™s secret sharing.. to actually handle the key sharing.

This is required for storing any business data. Also I think it would be required for storing any personal information in many regions.. Really there are infinite uses ;)

-------------------------

0xyu5 | 2022-11-15 12:30:35 UTC | #7

Does this cryptographic scheme allow arithmetic operations of data while encrypted?

-------------------------

spnrapp | 2022-11-15 14:13:21 UTC | #8

This is great news! Please see if the following scenario is what will be enabled by this feature:

1. User generates a fresh pub/sec key pair Pk and Sk for encryption.
2. User sends pub key Pk to a canister.
3. The canister is able to reply to the user a message M encrypted using Pk.
4. User decrypts M with Sk and get the secret S.
5. Secret S is not known to anyone except the user.

If this is indeed possible, it begs the obvious question: how does the user first generate S and send it to a canister to keep?

-------------------------

gregory | 2022-11-15 14:23:31 UTC | #9

[quote="0xyu5, post:7, topic:16560, full:true"]
Does this cryptographic scheme allow arithmetic operations of data while encrypted?
[/quote]

Not by itself, no. 

But you could use vetKD to "bootstrap" into a (fully or partially) homomorphic encryption scheme by IBE-encrypting the decryption key of the homomorphic scheme. This way, the canister could perform operations on the homomorphically encrypted data and use the vetKD interface to manage who gets to see the result.

-------------------------

jzxchiang | 2022-11-16 05:18:38 UTC | #10

Thank you for the response. I have a couple follow-up questions. Apologies if these are quite basic, as I am no cryptography expert.

1. I know that a subnet's public key is primarily used to verify signatures created from that subnet's private key (whose shares are distributed across its nodes). I didn't know that a subnet's public key could also be used for encryption. Could you verify that subnet public keys on the IC can indeed be used for asymmetric encryption and not only for digital signatures?

2. If that is true, what is the purpose of key derivation here? Typically, key derivation is used to generate ephemeral keys for short-lived sessions, I think. But in this case, it seems to be used as a cheap method to generate per-user keys on demand without going through the expensive process of key establishment each time. Is that accurate?

3. Can users use a master key that is *not* the subnet public key? If Alice and Bob both use the subnet public key to encrypt their data, and then derive their own secret keys Key-Alice and Key-Bob from it, how does the scheme ensure that the holder of Key-Bob (i.e. Bob) can't decrypt Alice's data (since they both used the same public key to encrypt their data)? I think I'm misunderstanding something basic here.

4. The transport key seems to be somewhat orthogonal to the derived decryption key. In other words, it belongs to a completely separate key pair and isn't technically a part of the "core feature", although it helps a lot in providing confidentiality. Is that accurate?

Thank you so much!

-------------------------

gregory | 2022-11-16 12:56:20 UTC | #11

Hi @spnrapp,

I'm afraid you lost me at step 4 in your scenario. What is the relation between M and S? Is S included in M? Who chooses M, who chooses S?

Note that there's not much point in the canister encrypting a secret to a user, because all replicas running that canister will know the secret.

-------------------------

gregory | 2022-11-16 13:16:45 UTC | #12

> 1. I know that a subnetâ€™s public key is primarily used to verify signatures created from that subnetâ€™s private key (whose shares are distributed across its nodes). I didnâ€™t know that a subnetâ€™s public key could also be used for encryption. Could you verify that subnet public keys on the IC can indeed be used for asymmetric encryption and not only for digital signatures?

You're raising another very good point. We're planning to support vetKD for the Boneh-Franklin IBE, for which the decryption keys are actually BLS signatures. Algebraically speaking, that means that we could actually re-use the same BLS keys that we already use for subnet signing. However, it would not be good "cryptographic hygiene" to do so, so we'd rather opt for having a separate set of threshold BLS keys for vetKD purposes.

> 2. If that is true, what is the purpose of key derivation here? Typically, key derivation is used to generate ephemeral keys for short-lived sessions, I think. But in this case, it seems to be used as a cheap method to generate per-user keys on demand without going through the expensive process of key establishment each time. Is that accurate?

Kind of, yes. The derived decryption keys indeed do not need to be short-lived. For example, in a secure storage use case, you could set the long-term encryption key to be the vetKD decryption key derived from a user's principal.

> 3. Can users use a master key that is *not* the subnet public key? If Alice and Bob both use the subnet public key to encrypt their data, and then derive their own secret keys Key-Alice and Key-Bob from it, how does the scheme ensure that the holder of Key-Bob (i.e. Bob) canâ€™t decrypt Aliceâ€™s data (since they both used the same public key to encrypt their data)? I think Iâ€™m misunderstanding something basic here.

Indeed, that's not obvious: this feature would threshold-derive decryption keys for an identity-based encryption (IBE) scheme. Such a scheme allows anyone to encrypt to a master public key and an identity, so that only the holder of the decryption key of that identity (that is derived from the master secret key and the identity) can decrypt.

> The transport key seems to be somewhat orthogonal to the derived decryption key. In other words, it belongs to a completely separate key pair and isnâ€™t technically a part of the â€œcore featureâ€, although it helps a lot in providing confidentiality. Is that accurate?

As a mental model, that's exactly right. But... :-) Without wanting to get too much into the nitty-gritty details of the vetKD scheme, but it can make sense to use a particular transport encryption scheme that has some sort of "homomorphism" that enables replicas to (1) check that an encrypted key share indeed contains a valid key share, or (2) to aggregate sufficiently many encrypted key shares into a compact encrypted key. But these are optimizations, really, the basic principle can work without such homomorphism.

-------------------------

aiv | 2022-11-16 15:23:42 UTC | #13

I have a project were I need to store some secrets (symmetric AES-128 encryption keys) to state, separate from any 1 particular user. The issue is that a malicious node provider may be able to read the state. Would this feature essentially solve that issue?

For reference, this is my project: 
https://twitter.com/ntagled

I have some workaround solutions planned, but confidential canister state and end-to-end encryption would be the ideal solution!

-------------------------

gregory | 2022-11-16 16:52:11 UTC | #14

[quote="aiv, post:13, topic:16560, full:true"]
I have a project were I need to store some secrets (symmetric AES-128 encryption keys) to state, separate from any 1 particular user. The issue is that a malicious node provider may be able to read the state. Would this feature essentially solve that issue?
[/quote]
I'm assuming that, in your use case, a first user generates a random AES key that a second, unrelated user should be able to read? Yes, this feature would solve that.

The easiest way is simply to let the AES key be the threshold-derived decryption key for some identifier of the object that the AES key encrypts. The canister then decides which users it grants access to the same derived key; none of the nodes ever get to see the decryption key, only the allowed users do.

If for some reason it's important in your use case that the first user chooses the AES key himself, you can have him IBE-encrypt that key under some identifier and store the ciphertext in the canister. The canister can then decide which users get access to the corresponding IBE decryption key, and hence the AES key. Again, nodes don't get to see the IBE decryption key or the AES key.

-------------------------

spnrapp | 2022-11-16 17:00:48 UTC | #15

Hi Greg,

If we look at this type

[quote="ais, post:1, topic:16560"]
derive_encrypted_key(master_key_id, transport_public_key, identity) -> EncryptedKey
[/quote]

The `EncryptedKey` would be `M`, and actual `Key` (the secret) would be `S`.

I want to ask if `Key` is fixed per `(master_key_id, identity)` pair? If it is, then a user can't really choose the secret, and once the secret is leaked, it is no longer secure and a new identity must be used. Is this understanding correct?

-------------------------

aiv | 2022-11-16 17:06:12 UTC | #16

[quote="gregory, post:14, topic:16560"]
The canister then decides which users it grants access to the same derived key; none of the nodes ever get to see the decryption key, only the allowed users do.
[/quote]

I want only the canister to be able to access the key, not any particular user.

I'm making transferrable HW wallets. There are two secrets:

1. A randomly generated AES key associated with each NFC tag, which is held by the canister to authenticate messages from these tags (they generate a unique URL with each scan). It's important that this key is never externally shared to any party. The principal owning the tag will change, and no previous owner should retain any rights to the asset whatsoever, so this key cannot be associated to any particular user. The NFC tags are also very simple, they cannot sign any ECDSA messages.
2. A randomly generated 16 byte "Transfer Code" which is externally given only to the current owner of the tag. This is physically written to the tag when the owner decides to (unlock) the tag. Then the next person to scan the tag will immediately become the new owner, as long as the tag credentials and transfer code are valid. If the scan credentials are valid but the transfer code is not, then they only get "read only" access and cannot claim ownership of the tag.

As mentioned before, neither of these secrets can be stored in the state in their raw form, otherwise a node provider would be able to remotely claim ownership of a tag. The entire point of the project is to make sure that the only way to claim ownership of the tag is if you have it in your hand in person.

-------------------------

jzxchiang | 2022-11-18 07:47:27 UTC | #17

This rabbit hole goes deeper than I thought (as usual). Thanks for the explanation!

-------------------------

singularity | 2022-11-18 09:44:33 UTC | #18

Can an unintended person take ownership of a tag that is in transit being mailed to someone who has bought it? by scanning it

-------------------------

aiv | 2022-11-18 16:17:24 UTC | #19

If the tag is unlocked, the next person to scan it can take over ownership (after they log into the dapp with their IC wallet).

However, to scan it your device needs to be within 10 cm (basically touching it), so they wouldn't be able to scan it through a shipping box while in transit. If you wanted to ship it in a thin envelope, you could simply wrap it in a small piece of aluminum foil to block any possible passive scanning attempts.

In this sense, it's basically the same as shipping cash. You'd be able to ship it discreetly, but at the end of the day if someone steals the package and opens it there's only so much you can do. Frankly, in this case most people would have no idea that the tag held crypto, or that it could even be scanned with their phone, or that they'd need an IC wallet to claim it, so it would actually be a lot more secure than shipping cash.

Also, the tag can only be unlocked in person, not even the owner could unlock it remotely, so it needs to be shipped unlocked.

When I ship tags to customers, it'll be in discreet envelopes and I'll make sure any passive scan attempts would be blocked.

-------------------------

gregory | 2022-11-23 08:56:18 UTC | #20

[quote="spnrapp, post:15, topic:16560]
I want to ask if `Key` is fixed per `(master_key_id, identity)` pair? If it is, then a user can't really choose the secret, and once the secret is leaked, it is no longer secure and a new identity must be used. Is this understanding correct?
[/quote]

That's right, the key is fixed per `(master_key_id, identity)` pair, and if it were to get leaked, one would have to switch to a different identity.

I'm not sure how that's a drawback, though. If you want to store a user-chosen secret, then just encrypt that secret with the derived key and store that ciphertext within the canister. To recover the secret, you re-derive the decryption key and decrypt the secret from the stored ciphertext.

Also, if a user-chosen secret leaks, you would also have to switch to a different secret, so I'm not sure how that's any different either?

-------------------------

ais | 2022-11-25 16:22:18 UTC | #21

Hi everyone! 

Updating that we'll have the first community conversation next Tuesday, November 29th (8 AM PT / 5 PM CET) - registration is [here](https://internetcomputer.org/live-sessions#Community-Conversation-Threshold-Key-Derivation-How-a-Blockchain-Can-Keep-Many-Secrets)!

This will be the first of (at least) two community conversations. Here, the plan is to give the conceptual overview of what we'd like to do, give some context and use cases, and to clarify any questions you may have. Think of it as an opener to the topic in general. 
We'll then schedule another conversation later to discuss a design proposal. 

So come one and come all - with questions, queries, wishes, or just to hear a little crypto chat. Can't wait!

-------------------------

lastmjs | 2022-11-26 17:37:04 UTC | #22

Is it possible this could provide an alternative to tECDSA? If a single ECDSA private key can be threshold encrypted, stored on the IC, and only decrypted on a client device, then couldn't users store any kind of keypairs on the IC? We wouldn't even need to wait for EDDSA or any other schemes...not sure this would work for all use cases, but am I thinking of this correctly?

-------------------------

spnrapp | 2022-11-28 08:10:11 UTC | #23

[quote="gregory, post:20, topic:16560"]
Iâ€™m not sure how thatâ€™s a drawback, though
[/quote]

Changing principal id after a secret is leaked isn't easy. The only way seems to be asking a user to register a new II account. On the other hand, if an arbitrary secret can be stored / updated, it would be less hassle.

-------------------------

gregory | 2022-11-28 08:47:46 UTC | #24

[quote="lastmjs, post:22, topic:16560, full:true"]
Is it possible this could provide an alternative to tECDSA? If a single ECDSA private key can be threshold encrypted, stored on the IC, and only decrypted on a client device, then couldn't users store any kind of keypairs on the IC? We wouldn't even need to wait for EDDSA or any other schemes...not sure this would work for all use cases, but am I thinking of this correctly?
[/quote]

That's a very good point, you can use vetKD to threshold-encrypt any data on the IC, including an ECDSA private key. However, the security of doing so is not exactly the same as for threshold ECDSA. 

You're right that the security level against a key recovery attack based on the data "at rest" is similar for tECDSA and vetKD-encrypted ECDSA: you need to corrupt a threshold number of nodes to recover the private key. An important difference, however, is that in the vetKD-based solution, the full ECDSA private key would have to be reconstructed in the user's browser, where it may get exposed to malware etc running on the user's machine. With threshold ECDSA, the full private key is never reconstructed on any machine.

-------------------------

gregory | 2022-11-28 10:00:27 UTC | #25

[quote="spnrapp, post:23, topic:16560, full:true"]
[quote="gregory, post:20, topic:16560"]
Iâ€™m not sure how thatâ€™s a drawback, though
[/quote]

Changing principal id after a secret is leaked isn't easy. The only way seems to be asking a user to register a new II account. On the other hand, if an arbitrary secret can be stored / updated, it would be less hassle.
[/quote]

Sorry, I may have expressed myself poorly before. 

The `identity` in `(master_key_identity, identity)` does not have to be the user's principal or anything related to it. It can be any string; it's up to the canister to decide which user/principal gets access to the decryption key of which identity string.

In the scenario that I sketched above where a user encrypts a user-chosen secret with a derived key, if the secret is leaked, the user can simply encrypt a new secret under the same derived key (i.e., for the same identity string). If the derived key was also leaked, the user could switch to a different derived key (i.e., for a different identity string). But in neither case would the user have to change his principal; that would only be needed if the secret key to the principal also leaked.

-------------------------

emmaperetti | 2022-11-28 10:06:42 UTC | #26

come and join community conversation [here](https://internetcomputer.org/live-sessions#Community-Conversation-Threshold-Key-Derivation-How-a-Blockchain-Can-Keep-Many-Secrets) happening on November 29, 2022.

-------------------------

ais | 2022-11-29 15:19:33 UTC | #27

We'll be there in less than an hour now! We'll try to finish before 17:45 in case anyone wants to join the SNS-1 sale. 

Looking forward to it!

-------------------------

anonymous | 2022-11-29 18:09:27 UTC | #28

Unrelated, but not sure where else to ask â€“ is there an eta on the secure logins? Gone plenty of times of losing my notes due to the lack of this kind of feature. It would be amazing to have.

-------------------------

jzxchiang | 2022-12-13 06:48:59 UTC | #29

@gregory @ais - Thank you for the excellent community conversation! I just watched the replay, and I wanted to say that it clears up a LOT more than just reading this post.

-------------------------

ais | 2022-12-13 10:06:40 UTC | #30

Thanks a lot for the questions and comments earlier in the thread. They help a lot to shape how and what we presented. A joint effort ðŸ¤

-------------------------

jzxchiang | 2022-12-15 02:21:14 UTC | #31

One quick question - how do you envision on-chain encryption in a world with [AMD SEV](https://forum.dfinity.org/t/amd-sev-virtual-machine-support/6156/24?u=jzxchiang) nodes? Do they solve for the same problem, i.e. "defense in depth"? Or do they actually solve for different problems?

I am struggling to think of a use case where on-chain encryption is still needed when subnet nodes run AMD SEV.

-------------------------

jzxchiang | 2022-12-15 02:24:00 UTC | #32

For example, is it accurate to say that AMD SEV only encrypts a node's memory but doesn't encrypt data at rest on disk?

If a user stores a confidential file unencrypted in the stable memory of a canister running on a AMD SEV-enabled subnet, the node can't read the canister's memory contents but perhaps it can read the on-disk snapshots generated from that memory? Is that where on-chain encryption can help?

Thank you for the help.

-------------------------

jzxchiang | 2022-12-15 02:45:39 UTC | #33

Sorry, one last question: I am curious how on-chain encryption compares and contrasts with the Signal Protocol for E2E encryption. It seems more flexible and more efficient, but I would like to hear your thoughts on it. Thanks!

-------------------------

gregory | 2022-12-15 08:11:35 UTC | #34

AMD SEV doesn't encrypt data on disk by default, but it does have the option to do so. Obviously, if the IC is to use SEV in the future, it will make use of the disk encryption feature.

In that sense, AMD SEV indeed solves the same use case as threshold key derivation, even in a more powerful sense because SEV nodes can perform computations on the cleartext data.

The big drawback of SEV are the trust & attacker model. First, SEV requires you to trust the centralized entity of AMD. If AMD decides to implement a covert channel into its chips, or if AMD's root key leaks, all bets are off. Second, the security offered by SEV isn't all that great. It doesn't protect against attackers with physical access to the machine, for example, [as has been demonstrated by a cheap and practical attack](https://arxiv.org/abs/2108.04575).

With threshold key derivation, you don't have to trust any single entity, you just have to trust the threshold assumption on the subnet where the master key is hosted. And it does protect against attackers with physical access to the machine, because they can only see encrypted ciphertexts.

-------------------------

gregory | 2022-12-15 08:20:29 UTC | #35

[quote="jzxchiang, post:33, topic:16560, full:true"]
Sorry, one last question: I am curious how on-chain encryption compares and contrasts with the Signal Protocol for E2E encryption. It seems more flexible and more efficient, but I would like to hear your thoughts on it. Thanks!
[/quote]

That's a very good question. You can indeed implement Signal-style E2E encryption on the IC already right now. That would involve managing decryption keys in user devices though, e.g., by scanning QR codes to admit new devices. It's possible, but threshold key derivation makes that job much easier, as it can piggy-back on the device management that is already included in Internet Identity (or any other IC identity provider), so that the only logic that the canister has to implement is to decide which principal is given access to which derived key.

On top of that, Signal-style protocols can't solve those use cases where the canister itself derives a key to decrypt data, e.g., time-lock encryption, secret-bid auctions, or MEV prevention.

-------------------------

lastmjs | 2022-12-16 06:24:05 UTC | #36

The problem with any secure enclave technology as I understand it is that they are, as far as we know, currently fundamentally broken by being susceptible to side-channel attacks.

At best they just make it harder to decrypt the data.

-------------------------

lastmjs | 2022-12-16 06:29:01 UTC | #37

@gregory is any of this AMD-SEV stuff even worth doing in light of that paper you referenced? Does it improve the confidentiality of canister data materially?

-------------------------

dfisher | 2022-12-19 08:27:43 UTC | #38

Whatâ€™s the timeline on this feature ?

-------------------------

gregory | 2022-12-19 09:12:46 UTC | #39

That's a good question. My personal take on AMD-SEV is that it can add a "best-we-can-do" level of security to those features that we have no idea to (efficiently) solve otherwise, in particular, by means of cryptography.  Large-scale computing on confidential data could actually be one of those features. Fully-homomorphic encryption is definitely more secure, but will never scale as well as AMD-SEV does.

But you're right that AMD-SEV doesn't add all that much security, so I would also recommend against relying on it for critical features. Note that if we did, we could probably get rid of most of our consensus protocol.

-------------------------

gregory | 2022-12-19 09:17:44 UTC | #40

No timeline decided yet. We're still drafting up a first design to include in a motion proposal, if that gets through things will depend on prioritization. It should be considerably less work than threshold ECDSA, though, because (1) the vetKD protocol is much simpler and (2) we can piggy-back on our experience from tECDSA.

-------------------------

lastmjs | 2022-12-19 22:19:21 UTC | #41

You still need to order the messages right? How would you be able to get rid of most of the consensus protocol?

-------------------------

skilesare | 2022-12-19 22:30:15 UTC | #42

In my experience, enclaves are generally "good enough" for most enterprises applications. They demonstrate a clear commitment to security and a best effort attempt to protect users.This is usually enough to meet regulatory and contractual standards(whether that should be the case is another discussion). If we want to open the IC up to enterprise SEV is probably our best option at the moment.

-------------------------

benjmanable | 2022-12-25 15:46:08 UTC | #43

Wonder why I can't include links in my post :thinking:

I found a paper posted on Twitter in response to this thread here. They propose a protocol named D-KODE to solve the problem of producing a "Public key of an offline Bob" (quote p4, Begin of section "Scenario 2").

How is the vetKD proposed here related to D-KODE? If not related, is there a paper where I can read up on the math and implementation specifics behind vetKD?

If such a system distributed n key shares to n IC nodes, is it a possible scenario that an attacker gains access (i.e. read capabilities) to t key shares and therefore is able to reconstruct the secret?

-------------------------

benjmanable | 2022-12-25 15:49:34 UTC | #44

This is the paper:

Authors: Easwar Vivek Mangipudi and Aniket Kate
Title: D-KODE: Mechanism to Generate and Maintain a Billion Keys
Published: Cryptology ePrint Archive, Paper 2022/161

-------------------------

ais | 2023-01-16 16:21:33 UTC | #45

Hi @benjmanable! 
(apologies for the delayed reply, I missed this with various holidays.)
The D-KODE motivation is indeed related to ours but the proposed solutions are quite different (namely that we will take a simpler pairing-based approach, while they take a heavier lattice-based approach). 

There is no paper yet as we're still pinning down the details, but it is in progress. Have no doubt that I will post here when we have something publicly digestible :)

Re an attacker gaining access to t shares -- generally we (and all blockchains) work under the assumption that an attacker won't get access to t of n nodes (and thereby t (master-)secret key shares). 
We do, however, plan for protection of the derived decryption keys by deriving *encrypted* shares. Even when combined, this gives the guarantee that nodes and/or a dapp will only see an encrypted (unusable) version of the user's decryption key. Depending on dapp design, the user could decide who (eg. them alone, or a canister, or a node, or another user) has control to decrypt and use the key.

-------------------------

nandit123 | 2023-01-27 20:35:58 UTC | #46

Hi @ais @gregory, our team is building [Lighthouse](https://www.lighthouse.storage/) - Perpetual storage on Filecoin and also built IC Drive previously. We also recently released an open-source Encryption SDK - Kavach - https://github.com/lighthouse-web3/encryption-sdk. We are interested in using IC canisters for storing the shards of the encryption key to the file and retrieving and aggregating on the users only when a signature is verified from an EVM-based wallet address. We think this use case can be relevant for storing private data and bringing smart contract-based access control not just on IC but also on other web3 storage systems. 

It will be great to get your feedback on it as our team plan to implement it soon.

-------------------------

gregory | 2023-01-31 15:56:58 UTC | #47

Hi @nandit123 ! Very interesting use case you have there! Do you have some documentation on how this key sharding would work cryptographically? I assume a key "shard" is a Shamir share of the secret key? And would you keep all shards on the IC, or would you keep different shards on different chains? In the latter case: how would you protect the shards on those chains?

If you're building this mainly on the IC, then vetKD could be exactly what you need. Essentially, the decryption key shards/shares would not be stored on chain, but the nodes in an IC subnet would store master key shares that would allow your users to reconstruct decryption keys on the user's side whenever they need them, protected by any access policy that can be expressed in a canister---which is pretty much anything you can think of, including verifying an ETH transaction.

-------------------------

nandit123 | 2023-02-09 10:35:44 UTC | #49

It uses BLS Threshold Cryptography as in our [GitHub repo](https://github.com/lighthouse-web3/encryption-sdk). Currently, shard generation happens on a centralized server, and shards are stored on 5 nodes controlled by our team. Let me know if you need more info here.

The plan is to keep all shards on the IC chain independent of the use case.

Yeah, I wasn't aware of vetKD. Is it already live? By "nodes in an IC subnet," do you mean IC Canisters? @gregory

-------------------------

domwoe | 2023-02-14 10:50:44 UTC | #50

Hey @nandit123,

Sorry, for the late reply. I'll try to answer your questions but would also encourage you to watch the [community conversation](https://www.youtube.com/watch?v=baM6jHnmMq8) on this topic.

[quote="nandit123, post:49, topic:16560"]
Is it already live?
[/quote]
No, it's not live yet.

[quote="nandit123, post:49, topic:16560"]
By â€œnodes in an IC subnet,â€ do you mean IC Canisters?
[/quote]
Nodes are the physical machines that make up a subnet on the Internet Computer. Canisters are run by these nodes.

-------------------------

hokosugi | 2023-03-18 10:43:27 UTC | #51

Do you have any updates for us?

-------------------------

ais | 2023-03-20 10:40:42 UTC | #52

Almost! 

We are still discussing interface details and working on prioritization internally, but we have made some progress with the formalization. 

Main updates:
* The paper is as well as done and will appear online in the next week or so. I'll post it here. 
* @gregory will go to Tokyo to give the talk at the [Real World Crypto (RWC)](https://rwc.iacr.org/2023/) conference next week.
* I am writing a **vetKD primer** that will give a bit of background about tBLS, Identity Based Encryption (IBE), and a high level intro to vetKD. I'll put it online before the end of the week, with the goal that you can use it as a basis to better understand the talk/paper. If there are any other major things you'd like explained, let me know.

They are the main updates.


*Aside.* If you are interested generally in what's going on in cryptography, I highly recommend that you attend RWC (physically or virtually) it's really a great place to see the cutting edge of crypto research in practice. You need to be an IACR member to attend - anyone can join for $50 per year. IACR members can attend all IACR conferences online at no cost. You can see the program for RWC [here](https://rwc.iacr.org/2023/program.php), register [here](https://rwc.iacr.org/2023/registration.php), and learn more about the IACR and becoming a member [here](https://iacr.org/).

-------------------------

hokosugi | 2023-03-20 22:17:18 UTC | #53

Thank you!
I appreciate that the primer will be up this weekend. I will read it before next week's RWC and if I have any questions, I will ask him directly :smiley:

-------------------------

ais | 2023-03-28 12:27:29 UTC | #54

Hello! 
Apologies for the delay - many things to explain, github outages, and coordinating across three continents.. you know how it goes.

Greg's talk is in the morning and [the VETKeys primer is now live on the blog](https://internetcomputer.org/docs/current/blog/features/vetkey-primer)! 
It gives a brief overview of the background for VETKeys, the primary goal is to introduce you to crypto terms and notation. Note, if I talk about crypto, I always mean cryptography. 

There are many, many other things to explain, so if you like this sort of foundational thing, tell us and we can do more. Also good to know if there are specific topics that you'd like.

**Action items for you!** 
We are discussing priorities now, and still finishing the paper. It would be really helpful if you tell us 
1) If you would like to see us develop this feature, why, and how important is it to you?
2) what would you need in terms of support from us (technical explainers like the primer, tutorials, samples, etc)

Thank you and enjoy!

-------------------------

b3hr4d | 2023-03-28 15:35:13 UTC | #55

Hello DFINITY community,

I am currently working on developing a no-key-wallet that allows users to securely interact with another blockchain without having to manage their private keys. My goal is to provide a user-friendly solution that maintains a high level of security and privacy.

I've been exploring the use of threshold ECDSA to distribute the signing process across multiple parties, which would eliminate the need for users to manage their private keys directly. However, I recently came across this discussion and wanted to inquire whether this technology would be a better fit for my project.

As I understand it, VETKeys also involves distributing sensitive information (like private keys) across multiple parties to minimize the risk of compromise. I would like to know if VETKeys offers any significant advantages over threshold ECDSA for my specific use case or if there are any critical differences between the two technologies that I should be aware of before moving forward.

Additionally, I would like to understand how the current development status of VETKeys might impact my project timeline. I noticed that the VETKeys initiative is still in its early stages, with the community feedback phase being discussed. If I were to consider VETKeys as a solution, what would be a realistic timeframe for its availability?

I would greatly appreciate any insights or advice from the community and the DFINITY team. Your expertise will help guide my decision-making process as I strive to develop a secure and user-friendly no-key wallet for the Internet Computer ecosystem.

Furthermore, I would also appreciate any suggestions or recommendations for other technologies or methodologies that could be suitable for my project. As a developer, I am always open to exploring new solutions and approaches to ensure the best possible outcome for the end users.

Thank you in advance for your valuable feedback and support. I look forward to engaging with the community, learning from your experiences, and contributing to the ongoing discussions around privacy, confidentiality, and key management on the Internet Computer.

Best regards,

Also, I would like to address the two questions you asked:

1. If you would like to see us develop this feature, why, and how important is it to you?

Yes, I would definitely like to see the development of the VETKeys feature. As a developer working on the Internet Computer, privacy and key management are crucial aspects of building secure and user-friendly applications. Implementing a feature like VETKeys has the potential to greatly improve user experience by simplifying key management and enhancing privacy. For my specific use case, the no-key wallet project, it would be an invaluable addition, allowing users to access their wallets without worrying about private key management. The importance of this feature cannot be overstated, as it could help to drive the adoption of the Internet Computer by making it more accessible to non-technical users.

2. What would you need in terms of support from us (technical explainers like the primer, tutorials, samples, etc)?

In terms of support, the following resources would be extremely helpful for developers looking to integrate VETKeys into their projects:

* A detailed technical primer explaining the underlying concepts, principles, and mechanisms behind VETKeys.
* Step-by-step tutorials covering various use cases and scenarios, with examples in different programming languages, to demonstrate how to implement and use VETKeys in real-world applications.
* Sample code and templates that developers can use as a starting point for integrating VETKeys into their own projects.
* Comprehensive documentation covering the VETKeys API, including clear explanations of all functions, parameters, and return values, along with examples of how to use them effectively.
* Regular updates on the development progress of VETKeys, including any planned enhancements, bug fixes, or changes to the API.

-------------------------

mparikh | 2023-03-28 16:28:03 UTC | #56

Comment/s

In the article under https://internetcomputer.org/docs/current/blog/features/vetkey-primer

(i) in explaining IBE, you probably meant


KD runs the IBE key generation algorithm to generate a master (public and private) key pair (**mpk,msk**) instead of (**msk, mpk**).

(ii) in "The threshold setting" you suddenly mention T,V,E. For a naive user,  you might want to define V, E,T prior to this mention.

Questions:
(a) how does Bob authenticate idbob to KD in IBE? through internet identity?

 (b) In an implementation on IC of VETKD,  do you envisage a threshold set of canisters running this protocol for each bob?

-------------------------

dfisher | 2023-03-28 21:12:49 UTC | #57

Iâ€™ll happily be that annoying guy who just asks when E2E is being shipped? 

Realistic before the end of Q2? Excited for this feature.

-------------------------

ais | 2023-03-29 14:31:18 UTC | #58

I believe that is partially up to you! We are in the process of prioritizing work for the coming months, so it would be great to know what people are interested in more or less. 
Any particular use cases that require this feature would be good to know about so I can build a strong case here.

A full implementation is for sure not realistic by EoQ2, but we are planning an interface with a test-key canister (Ã  la bitcoin integration beta testing last year) so that people can already experiment with integrating and playing around with use cases.

-------------------------

ais | 2023-03-29 14:43:08 UTC | #59

Thanks for that, I switched pub and priv and bolded V, E, and T in the first paragraph. 

Re questions
> (a) how does Bob authenticate idbob to KD in IBE? through internet identity?

Yes, Internet Identity would be one way to do it, but any access control policy implemented in an app could also work depending on the type of application. "Identity" can be considered quite fluid in this feature, it can be an arbitrary string, so it could be that authentication is not necessary. Consider the example where you encrypt a message 'to the future', the ID or string that you encrypt to could be a future date. When that date is reached, the dapp derives keys for that day and send to the user. 
Happy to describe more use cases in a blog post if you think it's useful.
> (b) In an implementation on IC of VETKD, do you envisage a threshold set of canisters running this protocol for each bob?

Yes, exactly. The idea is that there would be at least one subnet that is 'equipped' with master keys from which Bobs can derive VETKeys. Depending on the implementation and subnet size we hope to achieve at least 100 key derivations per second.

-------------------------

ais | 2023-03-29 15:57:08 UTC | #60

Hi @b3hr4d, thanks so much for the detailed feedback and for your answers to the questions. It's much appreciated! Your project sounds great and I wish you the best with it. 

The main difference is that VETKeys are essentially threshold BLS keys which generally tend to be easier to deal with than T-ECDSA keys. If you want to sign transactions on other chains (eg Bitcoin or Ethereum) then it is likely that you'll still need an ECDSA signing key. This could be stored in shares on the IC but any signatures would need to be generated locally on the user's device or in the browser. It's not entirely clear how this would differ in terms of efficiency relative to using the threshold ECDSA signing directly. Also, note above some comments between @lastmjs and @gregory about the security considerations for this. 

Regarding the development status, again, this is still in discussion, but we do our best to get a test/beta interface out soon.

For the other technologies, I leave you in the capable hands of the community :slight_smile: 
I get the feeling that some other community wallet/auth projects have similar questions, so stick around the forum and I'm sure there will be some interesting conversations popping up.

-------------------------

0xyu5 | 2023-03-30 07:06:09 UTC | #61

[quote="ais, post:52, topic:16560"]
@gregory will go to Tokyo to give the talk at the [Real World Crypto (RWC) ](https://rwc.iacr.org/2023/) conference next week.
[/quote]

[The presentation video](https://youtu.be/-d0Ny7NAG-w?t=3585) is now available for everyone to watch!

-------------------------

mparikh | 2023-03-30 15:20:25 UTC | #62

Thanks! A clarificatory question:

When you refer to a **Node** in the **Syntax** section of https://internetcomputer.org/docs/current/blog/features/vetkey-primer , i believe you are referring to SmartCanisters and **not** Nodes (as in Nodes on Internet Computer). Did i get it right?

-------------------------

free | 2023-03-30 15:34:59 UTC | #63

No, these are actually nodes making up a subnet (similar to tECDSA).

If it was canisters holding shares of the master key, it would be trivial to collect all these shares (by looking at the state of a single replica; or at least one replica per subnet, if said canisters were spread across multiple subnets) and reconstruct the master key. With nodes holding the shares, you'd need simultaneous control of a majority of the subnet's nodes (similar to what you'd need to do to extract a subnet's secret key).

-------------------------

mparikh | 2023-03-30 18:30:59 UTC | #64

cool. 

Trying to understand this statement : "Nodes can also combine encrypted shares to produce the full encrypted derived key ek using a Combine algorithm".

Because each Node participating in this protocol has it's own master-secret-key-share (msks-i) and is passed in the full public transport key (tpk) along with the id (i.e.bob@email.com) from bob, it can produce a derived encrypted key share (eki) representing a "shared" bob. 

A threshold set of ekis are required to produce a "complete" bob; provided that these ekis can be decrypted. Since only bob holds the private transport key (tsk) with which these ekis are encrypted, a node can gossip with other nodes and produce that combined threshold share (aka full derived keys) which are encrypted. 

This Combine function is therefore convenient because an actor (Bob) needs to interact with only one node; as opposed to threshold set of nodes.

Did I get the above right? 

What happens if that node is a rogue node?

-------------------------

skilesare | 2023-03-30 19:21:29 UTC | #65

The talk was great!!!

I'm making an assumption that it would be nice to have verified.  The Dapp controls these access to the keys correctly?  So if the smart contract says that Bob can decrypt Alice's encryption then he gives Bob the key he needs.  Is that correct?  It seems like this adds another level of trust to this scheme and the canister code is going to have to get pretty serious about immutability or DAO horizoning.  In other words, could an upgraded canister arbitrarily decide to start issuing decryption keys to everyone?

-------------------------

skilesare | 2023-03-30 19:26:36 UTC | #66

I believe that next to ETH integration(to capture the known degens), this is likely the most important feature for the IC.  Encryption in a secure way needs to be solved to bring enterprise onto the IC. As mentioned in the talk this would open up numerous use cases for businesses in the "Shared Data Spaces" realm.

At Origyn we need to encrypt certain product and user details that should only be accessible to authenticators, customers, or service providers who have been granted access.  So certificates end up with a mix of open, transparent data and permissions, encrypted data.

Keep up the good work and I can't wait to see what you all come up with!

-------------------------

lastmjs | 2023-03-30 20:11:06 UTC | #67

I just thought of a potential use case while on an airplane today.

I was thinking about how a DAO or group could control an npm account and push new package versions to npm. The token could be verifiably encrypted, and a canister could decrypt the token just when necessary to do an http outcall to deploy a new version of a package.

Though, the decrypted token would be available temporarily in the memory of the nodes right? Hopefully AMD-SEV or something similar gets deployed soon to help on that front.

-------------------------

free | 2023-03-30 20:20:09 UTC | #68

[quote="mparikh, post:64, topic:16560"]
Did I get the above right?
[/quote]

Exactly.

[quote="mparikh, post:64, topic:16560"]
What happens if that node is a rogue node?
[/quote]

I don't know much about the specifics of vetKD, but given that this is a subnet, the result would be the same as talking to a random malicious node on a random subnet: it could take arbitrarily long to respond, it could respond with garbage, but it wouldn't be able to produce an invalid response with a valid subnet signature. So after either a timeout or an invalid response, you would query again for the status of your request and will likely hit an honest node.

-------------------------

mparikh | 2023-03-30 21:06:50 UTC | #69

[quote="skilesare, post:65, topic:16560"]
In other words, could an upgraded canister arbitrarily decide to start issuing decryption keys to everyone?
[/quote]

Assuming that Bobâ€™s authentication to idbob passes through a dapp, the dapp could update itself to pass "true" to every authentication request. See below. 

[quote="ais, post:59, topic:16560"]
Identityâ€ can be considered quite fluid in this feature, it can be an arbitrary string, so it could be that authentication is not necessary.
[/quote]

So yes your assertion is correct. Immutability / some kind of sensible implementation would be required.


@free @ais 

Given that there's one masterkey and assuming various different dapps that piggyback on the same arbitrary string (ie "bob@email.com"), what is the mechanism of distinguishing different idbobs (one idbob per dapp)?

-------------------------

mparikh | 2023-03-30 21:47:03 UTC | #70

Indeed! 

More generally,  this would solve "how to store a api-key securely to call private apis which require api-keys" on IC ; baring a small window of time where the dapp smart canister (hosted on nodes) would have the decrypted api-key (aka token) in RAM.

-------------------------

free | 2023-03-31 06:48:29 UTC | #71

Disclaimer: I'm not a cryptographer, I'm a systems software engineer. My first run-in with cryptography beyond the basics of public key cryptography (I just had to look up the proper term for it) was when I joined DFINITY a few years back. I'm also not directly involved with vetKD. So take my answers with a grain of salt.

[quote="mparikh, post:69, topic:16560"]
Given that thereâ€™s one masterkey and assuming various different dapps that piggyback on the same arbitrary string (ie â€œ[bob@email.com](mailto:bob@email.com)â€), what is the mechanism of distinguishing different idbobs (one idbob per dapp)?
[/quote]

I imagine one simple solution would be for the vetKD implementation to e.g. always prepend the canister ID (of the canister making the request) to the provided ID. That way, when Alice asks canister C to derive a public key for ID `"bob@email.com"`; or Bob asks canister C to derive the secret key for the same; they will actually be getting the public/secret key derived from `"<C>|bob@email.com"`. So asking canister C for the public/secret key for `"bob@email.com"` would result in a different key pair than asking the same from a canister D.

And the only way to get the former key pair would be to go through canister C. And canister C may enforce whatever rules it chooses to decide whether to allow or not a given principal to retrieve the secret key derived from `"bob@email.com"`.

-------------------------

hokosugi | 2023-04-05 00:00:57 UTC | #72

What is the difference between vetKD and [drand](https://github.com/drand/tlock)?
Both use t-BLS signatures and IBE cryptography for encryption and decryption. Please tell us what exactly are the differences.

-------------------------

rabbithole | 2023-04-08 15:26:33 UTC | #73

I need this functionality because this is the whole point of my application! I am working on encrypted file storage and I abandoned the idea of storing keys on the user side as soon as I learned about the possibility of using end-to-end encryption in the canister in the near future. At the moment, I just have a file storage until I again implement encryption support already on the side of the canister. I'm also inspired by the ability to decrypt data based on time, sharing files with someone in case of an accident. I would like to be able to work with this functionality in the near future, so please add +1 to the number of applications that really need it :slightly_smiling_face:

-------------------------

dfisher | 2023-04-09 21:37:43 UTC | #74

So maybe Q4 full implementation?

-------------------------

lastmjs | 2023-04-16 04:15:53 UTC | #75

I've thought of another use case, this time for the Internet Computer itself. I've written a tweet thread and I'll open a forum post if initial feedback is good: https://twitter.com/lastmjs/status/1647448096744550403

The idea is to use ZK proofs to vet node operators, and then use VetKD to encrypt their KYC/B information, store it in the NNS subnet, and allow decrypting it only with an NNS proposal.

This would allow almost anonymous node operators while allowing deterministic decentralization, legal compliance, and legal or reputational courses of action if node operators misbehave.

I truly believe, if I haven't made some grave mistake in understanding, that this is a solution to one of the biggest attack vectors of the IC, that being collusion between node operators in static subnets.

-------------------------

Sormarler | 2023-04-16 06:38:38 UTC | #76

I really think this is a win-win situation for both the internet computer and node operators.

-------------------------

hokosugi | 2023-04-16 06:58:24 UTC | #77

Who determines the authenticity of the initial KYC data that the node provider registers, Dfinity? 
If the prover is the node provider himself, I don't think we would know if the KYC is true or not.

-------------------------

timo | 2023-04-16 07:45:30 UTC | #78

[quote="lastmjs, post:75, topic:16560"]
this is a solution to one of the biggest attack vectors of the IC, that being collusion between node operators in static subnets
[/quote]

I understand the goal of allowing node operators to stay anonymous as much as possible, as a goal in itself. But it does not change anything regarding their ability to collude. Those who want to collude will find each other no matter what. Or do you mean they would be harder to attack by an attacker whose goal is to hack multiple and then â€žmakeâ€œ them collude?

-------------------------

lastmjs | 2023-04-17 10:57:28 UTC | #79

This would make it much harder for node providers to collude wouldn't it? Right now they have free and open access to each other's contact information more or less. With this solution I'm hoping it would be much harder for them to find each other, especially once we have node rotation/shuffling.

-------------------------

JaMarco | 2023-04-17 14:46:21 UTC | #80

[quote="timo, post:78, topic:16560"]
Those who want to collude will find each other no matter what.
[/quote]

What do you mean by that, how would anonymous node operators find each other secretly?

-------------------------

Severin | 2023-04-17 15:44:28 UTC | #81

Maybe by being the same node operator with multiple identities

-------------------------

timo | 2023-04-17 17:13:18 UTC | #82

Node provider posts pseudonymously on this forum, asking innocently for help with technical issues, identifying himself as a node provider. Now anyone can contact him, just like it would be the case when node providers were publicly known. 

Point is any node provider can be anonymous but doesnâ€™t have to be. Any node provider can at any point make as much of his identity public as he chooses. Or make himself reachable. In other words anonymity of always optional. Hence, by definition, anonymity cannot provide any advantage against collusion.

-------------------------

timo | 2023-04-17 17:21:12 UTC | #83

Exactly. The threat is not honest node providers turning malicious after being contacted by some other malicious node provider. The threat is an attacker signing up as multiple node providers by using a bunch of strawman entities. And against threat non-anonymity is better. Because the more people can scrutinize the node provider applications the higher the chances to reveal the true identity behind them.

-------------------------

0xyu5 | 2023-04-27 05:06:32 UTC | #84

As you know, @victorshoup explained Threshold FHE on IC in yesterday's R&D meeting. Is Threshold FHE scheme independent from the way that Gregory explained, FHE using vetKD for bootstrap?

[quote="gregory, post:9, topic:16560"]
But you could use vetKD to â€œbootstrapâ€ into a (fully or partially) homomorphic encryption scheme by IBE-encrypting the decryption key of the homomorphic scheme. This way, the canister could perform operations on the homomorphically encrypted data and use the vetKD interface to manage who gets to see the result.
[/quote]

-------------------------

ais | 2023-05-02 12:08:29 UTC | #85

Hello! Good news! **[The paper](https://eprint.iacr.org/2023/616.pdf) is finally online** if you are interested to really go into the details :partying_face: 
If you have questions, want explainers about anything in particular, or any other comments, let us know.

Some replies to earlier messages..

[quote="dfisher, post:74, topic:16560"]
So maybe Q4 full implementation?
[/quote]

Hard to say. The design and integration of a full implementation is still being discussed.
However, the Crypto team is working on a canister interface that will allow to experiment with a test implementation. This should be ready soonâ„¢..


[quote="hokosugi, post:72, topic:16560"]
What is the difference between vetKD and [drand ](https://github.com/drand/tlock)?
Both use t-BLS signatures and IBE cryptography for encryption and decryption. Please tell us what exactly are the differences.
[/quote]

I have not looked too much into the details of drand. On the conceptual level they are similar. The most notable difference is that drand key shares are not encrypted. Also on the network / usage level they will be different. How far did you get with reading both? Happy to fill in any gaps.

[quote="0xyu5, post:84, topic:16560"]
As you know, @victorshoup explained Threshold FHE on IC in yesterdayâ€™s R&D meeting. Is Threshold FHE scheme independent from the way that Gregory explained, FHE using vetKD for bootstrap?
[/quote]

Yes, @victorshoup's work with Zama is independent. Rather than 'bootstrapping' into FHE, they are pushing the boundaries of FHE to allow it to happen onchain in a much more practical way. Very cool stuff.

-------------------------

lastmjs | 2023-05-02 13:26:46 UTC | #86

That's why we use robust ZK identity providers to stop this.

-------------------------

lastmjs | 2023-05-02 13:28:11 UTC | #87

We should seek to hide the network topology from the node operators, so that they don't even know what subnet they are in. If they don't know what subnet they are in currently, nor at any point in the future with node shuffling, it would become extremely difficult to collude with a small number of node operators in the same subnet.

-------------------------

MCLYang | 2023-05-27 01:17:35 UTC | #88

watch and learn here :eyes:

-------------------------

rabbithole | 2023-06-08 13:44:14 UTC | #89

[quote="ais, post:85, topic:16560"]
However, the Crypto team is working on a canister interface that will allow to experiment with a test implementation. This should be ready soonâ„¢â€¦
[/quote]
It is mentioned in [this thread](https://forum.dfinity.org/t/icp-lab-storage-scalability-summaries/20242) that vetKey's demo was shown. When can we see it? I look forward to any news about this functionality

-------------------------

ais | 2023-06-08 14:10:31 UTC | #90

Hey! That was a brief preview which we are wrapping up now. It should be ready soon, and we'll organise a Community Conversation to talk through it in detail, show some of the use cases, and have some time for Q&A. The 'mock' canisters will be there as well for you to play around with.

-------------------------

ais | 2023-06-23 07:41:14 UTC | #91

Hi guys, we've picked a date and scheduled the second community conversation where we'll recount some of the obstacles that vetKeys help to overcome, show the first demo, and preview an updated version of the encrypted notes dapp. 

It will be on Zoom (recorded and uploaded to YouTube later) on July 11th at 17h30 CET.

See the details and sign up here: https://internetcomputer.org/live-sessions?mc_cid=a6e0143773&mc_eid=UNIQID#Community-Conversation-vetKeys-Demo

Happy to hear if you've any questions and / or requests before then. Looking forward to it!

-------------------------

rabbithole | 2023-06-24 16:57:32 UTC | #92

[quote="ais, post:90, topic:16560, full:true"]
Hey! That was a brief preview which we are wrapping up now. It should be ready soon, and weâ€™ll organise a Community Conversation to talk through it in detail, show some of the use cases, and have some time for Q&A. The â€˜mockâ€™ canisters will be there as well for you to play around with.
[/quote]

I'm trying to play with this, I found a branch and this [commit](https://github.com/dfinity/examples/commit/a24baa0cb936d23df24720e8b2f28dd025d509b3). The WASM code connected on the front-end and imitates the work of the code that will be implemented in the canister, but `tpk` is not used in `crypto.js` in any way on the front-end. I assume this is an unfinished version and should we expect commits before the demonstration?

-------------------------

franzstefan | 2023-06-26 07:52:28 UTC | #93

Hi @rabbithole, it's great to see your interest in already playing with this! Indeed, this is some preliminary and unfinished work. The intention is to have our demos ready and committed by the date of the community conversation (July 11). Hope to see you there!

-------------------------

conorseed | 2023-07-02 03:19:43 UTC | #94

I just watched the first community conversation and this looks to be exactly what I need to build out my use case. Thanks for working on this, and I'm excited to see, or maybe even contribute to, the second conversation. Looking forward to it too.

-------------------------

dfisher | 2023-07-02 10:19:08 UTC | #95

@ais I noticed Zama launched its solution on Ethereum. 

Do we have any updates on our collaboration with Zama for encrypted computation?

-------------------------

hokosugi | 2023-07-03 06:19:35 UTC | #96

Looking at ZAMA's announcement, it seems that fhEVM can perform threshold decryption with multiple validators and create anonymous ERC-20. fhEVM on IC already performs threshold signing with ChainKey, so wouldn't it be possible to deploy EVM on IC if it is realized? Also, won't we need fhWasm or zkfhWasm to do full-scale secret operations on GPUs, etc.?
Also, more to the point, fhEVM has only one private-public key pair, but I am guessing that there could be cases of high privacy data operations that require a private key for each user. Wouldn't vetKey be a solution then?

-------------------------

rabbithole | 2023-07-03 17:01:47 UTC | #97

[quote="franzstefan, post:93, topic:16560"]
itâ€™s great to see your interest in already playing with this! Indeed, this is some preliminary and unfinished work.
[/quote]
I found [another branch](https://github.com/dfinity/examples/tree/franzstefan/enc-notes-using-vetkd/motoko/encrypted-notes-dapp) of yours in the repository, compiled the *vetkd_system_api* canister and tested it on my application. It's amazing!

-------------------------

ais | 2023-07-07 10:36:26 UTC | #98

@conorseed That's great! Happy to hear if you what to share what use case you're working on. In any case, see you next week for the next community conversation. 

@dfisher and @hokosugi - thanks for the questions! I defer to @victorshoup for news on FHE. Re the last point, it would depend on details as usual, but indeed, whenever there's a need to derive decryption keys on demand, it would be cool to see how vetKeys can be plugged in.

-------------------------

ais | 2023-07-10 15:06:21 UTC | #99

Hi all, just a little reminder that the Community Conversation Demo will start in a little over 24 hours from now. 
Feel free to register here: https://internetcomputer.org/live-sessions?mc_cid=a6e0143773&mc_eid=UNIQID#Community-Conversation-vetKeys-Demo

-------------------------

josephgranata | 2023-07-10 18:20:45 UTC | #100

Very cool project, I hope the current iteration goes beyond in browser encryption, as the first Motoko project did, which encrypted data in the browser cache.

Congratulations for the paper, I see the name of a Cryptographer friend there, bravo @gregory! And I see many names I recognize in the white paper, Victor S. is there too.

It is a powerful technology for sure. Looking forward to tomorrow's discussion to know more about it. I only checked the Motoko example before, but this iteration seem much more ambitious.

Joseph Hurtado

-------------------------

conorseed | 2023-07-12 09:10:52 UTC | #101

@ais - dang! It was at 3:30am in my timezone and I slept right through my alarm :sweat_smile: Any chance it'll be up on youtube quickly?

> @conorseed Thatâ€™s great! Happy to hear if you what to share what use case youâ€™re working on. In any case, see you next week for the next community conversation.

Also happy to chat with you about this - maybe just not on a public forum. Is there a way I can reach out privately?

-------------------------


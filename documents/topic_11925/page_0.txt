mariop | 2023-03-16 14:29:26 UTC | #1

**Ledger & Tokenization Working Group**

DFINITY lead: @dieter.sommer 
Coordinator: @benji

Discord: [Ledger & Tokenization Channel](https://discord.com/channels/748416164832608337/976871875043016704)
Forum: [Main thread with updates](https://forum.dfinity.org/t/announcing-token-standard-as-topic-of-the-first-meeting-of-the-ledger-tokenization-working-group/)
GitHub: [GitHub - dfinity/ICRC-1: A fungible token standard developed by the Ledger & Tokenization working group for the IC.](https://github.com/dfinity/ICRC-1/)
Slides and Recordings: [Link to Google Drive](https://drive.google.com/drive/u/0/folders/1TlaDISjZpAKpqJdXzYMw4hhuKj5YxZ3J)
Cadence: Bi-weekly on Tuesday at 6:00 PM CET ([Google Calendar](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t), [calendar browser link](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich))

First meeting: April 12, 2022, at 5:00 pm CET

The Leder & Tokenization Working Group has emerged due to the need for a unified token standard on the Internet Computer and the fragmentation in this space seen beforehand. The working group attempts to create a widely-agreed core token standard that everyone deploying a token on the IC should support. This will allow dApps like DEXs to seamlessly integrate with all tokens while using a single implementation. Extensions to this standard will be available as well and are optional to implement for more specific use cases.A single unified and widely agreed token standard is one of the most paramount things required for a blockchain, thus it is needless to stress the importance of this working group for the IC ecosystem at large.This is a truly open platform and everyone in the community is invited to participate in the standards activities, either actively or just for listening in.

-------------------------

jzxchiang | 2022-04-06 00:41:43 UTC | #2

Hopefully, someone can share the meeting notes afterwards.

I would love to attend, but 8am PDT is somewhat prohibitive for me.

-------------------------

jzxchiang | 2022-04-06 00:44:56 UTC | #3

I hope you will be able to discuss the fact that community-developed DEXs seem to be adopting one standard (DIP20) and the DFINITY-developed SNS seems to be adopting another standard (NNS ledger interface).

Not to mention the upcoming wrapped BTC canister... I'm not sure which standard they are using.

This fracturing will lead to headaches down the road, I suspect.

-------------------------

mariop | 2022-04-06 07:17:44 UTC | #4

hey @jzxchiang,

DEXs are integrating with the NNS ledger interface as far as I know.
I'm the developer of ckBTC, aka wrapped BTC for the IC, and we are using the NNS ledger interface to keep it consistent with the interface used by SNS and NNS. The NNS ledger interface is the standard of both NNS and SNS.

I agree that fracturing will lead to headaches. The working group has been created to help dealing with this. I hope to have a constructive discussion about it on Tuesday :slightly_smiling_face: .

p.s. we are considering other times for the meeting of the working group. I'll see what we can do.

-------------------------

Fulco | 2022-04-11 11:26:02 UTC | #5



-------------------------

mariop | 2022-04-12 17:46:11 UTC | #6

Hi everyone,

Thanks everyone for participating in the first meeting of the Ledger & Tokenization working group. We got a lot of good feedback and some action points for the next meeting.

As decided in this working group, the next meeting will be dedicated to presenting the various token standard ideas. Everybody will be able to present their own take on the topic and get a Q&A about it. Let's try to keep the presentations under 10 minutes to allow everybody a fair amount of time.

The date for the next working group meeting will be the 26th of April.

You can find a link to the slides I presented today [here](https://docs.google.com/presentation/d/e/2PACX-1vQV0zrmd9t3dOg5N7RbBQ6BKcY0KfQPo0JlQU_20b925_QUhn0gO7Ya5Bzi3a4b0IbxDq59OG0_G4Yt/pub?start=false&loop=false&delayms=3000).

We would be grateful if you could fill [this survey](https://www.google.com/url?q=https://dfn.typeform.com/to/dXonq5BQ&sa=D&source=editors&ust=1649783048245194&usg=AOvVaw2QzKwPebGqV_sRufh4_T7X) about the working group to help us improving this new process.

It has been great to meet all of you and have a nice discussion about token standards on the IC!

See you next time!

-------------------------

JaMarco | 2022-04-12 19:42:50 UTC | #7

Is there/will there be records of the meetings?

-------------------------

jzxchiang | 2022-04-12 20:09:53 UTC | #8

+1, I'd love to watch a replay and/or read some minutes.

-------------------------

moritz_tum | 2022-04-13 08:19:24 UTC | #9

Yesterday it was not possible to record the meeting due some privacy / legal (?) reasons. They will try to figure out if they can record future meetings.

-------------------------

mariop | 2022-04-13 08:28:54 UTC | #10

There was no recording for the first meeting. I will see if we can record the next ones.

-------------------------

Fulco | 2022-04-13 11:45:36 UTC | #11



-------------------------

daijianlin | 2022-04-13 14:17:02 UTC | #12

Token Standard is very important and pretty urgent. The community  complain a lot regarding the token standard. Hope you could find a solution asap. I don't think a meeting cross 1 month is good enough, maybe have a meeting to discuss once in one week?

-------------------------

mariop | 2022-04-13 15:02:02 UTC | #13

@daijianlin we have decided to have a meeting every 2 weeks for the Ledger & Tokenization working group. The next one will be the 26th of April.

-------------------------

jzxchiang | 2022-04-13 23:09:46 UTC | #14

Is the time for the ledger working group still set at 2 hours before the time for the developer tools one?

-------------------------

mariop | 2022-04-14 13:58:23 UTC | #15

Yes, the time is 5:00pm CET. I'm discussing within Dfinity to have another meeting for people who cannot attend this one. Would it be easier for you to join the meeting if it was at 7:00pm CET?

-------------------------

jzxchiang | 2022-04-15 01:00:56 UTC | #16

Yes it would but I don't want to force anyone to meet later than they can. :sweat_smile:

I think if there are recordings in the future that would already help a lot.

-------------------------

nikhil.ranjan | 2022-04-26 09:53:58 UTC | #17

The meetings zoom link is changed. New link 

https://dfinity.zoom.us/j/94765742644?pwd=d3pFRjFnUy91MncxSnN3ajdCdkRDZz09

-------------------------

skilesare | 2022-04-27 04:02:05 UTC | #18

Can you all create/update the event link on the main working group thread to every two weeks?  I missed today...hope it was a good one!

-------------------------

mariop | 2022-04-27 14:27:24 UTC | #19

Hi everyone,

First of all, thanks for participating to yesterdayâ€™s working group session. It has been nice to talk about token standards more in details and share ideas. Iâ€™m happy to see that we are aligning toward a common standard more and more and Iâ€™m eager to continue the conversation. You can find the slides [here](https://docs.google.com/presentation/d/1cqxUhDbudI6aUmz4aJPSXvXpaM-TA4Cp1aWsomr0FwU/edit?usp=sharing).

Unfortunately, it looks like some people couldnâ€™t participate to the session because of a broken Zoom link. Iâ€™d like to apologise for the technical issue on behalf of the Dfinity foundation, the link was created by somebody who is not at Dfinity anymore and for some reason the updated link didnâ€™t reach all our users.

We are considering organising a new session next Tuesday, the 3rd of May, to continue the discussion about standards. It would be helpful to know who would be interested to join that meeting (e.g. because they couldnâ€™t join yesterdayâ€™s meeting). Please reply to this post if youâ€™re interested. If there is enough interest then we will organise it and send an invite.

Looking forward to chat with you again.
Best

-------------------------

skilesare | 2022-04-27 14:18:20 UTC | #20

Very interested. :coin::coin::coin::coin::coin::coin::coin::coin:

-------------------------

skilesare | 2022-04-27 14:25:13 UTC | #21

[quote="mariop, post:19, topic:11925"]
like some people couldnâ€™t participate to the session because of a broken Zoom link. Iâ€™d like to apologise for the technical issue on behalf of the Dfinity foundation, the link was created by somebody who is not at Dfinity anymore and for some reason the updated link didnâ€™t reach all our
[/quote]

Slides aren't linked.

-------------------------

mariop | 2022-04-27 14:28:36 UTC | #22

[quote="skilesare, post:21, topic:11925"]
Slides arenâ€™t linked.
[/quote]

They should be now, you can find them at [https://docs.google.com/presentation/d/1cqxUhDbudI6aUmz4aJPSXvXpaM-TA4Cp1aWsomr0FwU](https://docs.google.com/presentation/d/1cqxUhDbudI6aUmz4aJPSXvXpaM-TA4Cp1aWsomr0FwU)

-------------------------

dieter.sommer | 2022-04-27 14:46:53 UTC | #23

Also very interested in being able to participate!
Missed it also because of the issues with the invitations.

Thanks for your efforts here to give everyone the opportunity to participate! :-)

-------------------------

nicopoggi | 2022-04-28 17:28:34 UTC | #24

Happy to join with the Psych crew!

-------------------------

mariop | 2022-05-01 10:02:16 UTC | #25

Thanks everyone. I think we have enough people. I've added a new Ledger & Tokenization working group meeting for Tuesday at 6pm. I added to the calendar. See you there!

-------------------------

skilesare | 2022-05-01 13:37:53 UTC | #26

Mario, can you relink where this calendar is?

-------------------------

mariop | 2022-05-01 14:18:06 UTC | #27

Sure, you can find the event calendar [here](https://calendar.google.com/event?action=TEMPLATE&tmeid=NTQyN2UybXFwNTBzNm1ybzQ5bzVjbnBnajFfMjAyMjA0MTJUMTUwMDAwWiBjX2NrMGdyNzlia2djb29pY24xcDg3bW8xZXJvQGc&tmsrc=c_ck0gr79bkgcooicn1p87mo1ero%40group.calendar.google.com&scp=ALL).

-------------------------

skilesare | 2022-05-02 18:43:04 UTC | #28

Maybe I'm looking at the wrong place, or maybe google calendar is doing something funny. Is there a meeting tomorrow? This link just points to one that is "every second Tuesday of the month" and doesn't schedule a meeting for tomorrow.

-------------------------

nikhil.ranjan | 2022-05-03 10:01:06 UTC | #29

Event calendar for today's [event](https://calendar.google.com/calendar/u/0/r?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t)

-------------------------

skilesare | 2022-05-03 16:06:01 UTC | #30

Also try here:
https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich

-------------------------

emmaperetti | 2022-05-03 16:09:35 UTC | #31

zoom link to enter: https://dfinity.zoom.us/j/94765742644?pwd=d3pFRjFnUy91MncxSnN3ajdCdkRDZz09

-------------------------

nikhil.ranjan | 2022-05-09 11:33:10 UTC | #32

Hey guys, Next meeting is tommorow 10 may 5 pm CET. The calendar event can be found [here](https://calendar.google.com/calendar/u/0/r?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t). Zoom link is [here](https://www.google.com/url?q=https://dfinity.zoom.us/j/94765742644?pwd%3Dd3pFRjFnUy91MncxSnN3ajdCdkRDZz09&sa=D&source=calendar&ust=1652527288352687&usg=AOvVaw1vznn0t5qYkfjUFTRsF4AO). Please update your calendars.

-------------------------

Maxfinity | 2022-05-09 13:51:32 UTC | #33

Guys, why are we  giving people just one day's notice for the meeting? This will not boost participation.

-------------------------

nikhil.ranjan | 2022-05-09 14:13:33 UTC | #34

We are doing this meeting every next tuesday. It was announced before. Posted links again to remind people to join.

-------------------------

nikhil.ranjan | 2022-05-10 08:47:30 UTC | #35

You can find notes and slides here https://docs.google.com/presentation/d/1igawlgijYU7i06-O3fscMIJPd3xe7sIWhIlo39udjkI/edit?usp=sharing

-------------------------

mariop | 2022-05-11 19:11:42 UTC | #36

Hi everyone, thanks for joining the last meeting of the working group.

As follow up, I've created a shared document [here](https://docs.google.com/document/d/1Um3Z2uUgWVyhUvQEjtrSxMG7puTpXRGPT9cvPQ_qroo/edit?usp=sharing) about the IC Ledger Standard. Everyone can contribute to the document by adding comments and discussing about proposed ideas.

Please have a read to the document and think about:
* What is missing or too much for a minimum standard?
* What else do you want in a minimal standard?

The document will be used as starting point for the next session. We will go through each comment and try to find a common ground about the proposed feature or whether that feature should not be part of the standard.

The next session with be the Thu 19th of May. We will send out the invite soon.

Thanks again everyone.

-------------------------

RatherIcy | 2022-05-11 19:37:35 UTC | #37

This is something that seems like it should have been formulated before the ICP launch, but better late than never. ðŸ¤ž

-------------------------

mariop | 2022-05-24 09:23:56 UTC | #38

Hi everyone,

Thanks for joining today. We have setup a chat for the working group @ [DFINITY DEV OFFICIAL](https://discord.gg/J8Xer3Hm) and we are going to speed up the discussion around the token standard by having sessions bi-weekly. Next meeting will be Tue 24 May at 5pm 6Ì¶pÌ¶mÌ¶ Ì¶(Ì¶nÌ¶oÌ¶tÌ¶ Ì¶5Ì¶pÌ¶mÌ¶ Ì¶aÌ¶sÌ¶ Ì¶aÌ¶nÌ¶tÌ¶iÌ¶cÌ¶iÌ¶pÌ¶aÌ¶tÌ¶eÌ¶dÌ¶ Ì¶bÌ¶eÌ¶cÌ¶aÌ¶uÌ¶sÌ¶eÌ¶ Ì¶oÌ¶fÌ¶ Ì¶aÌ¶nÌ¶ Ì¶oÌ¶vÌ¶eÌ¶rÌ¶lÌ¶aÌ¶pÌ¶pÌ¶iÌ¶nÌ¶gÌ¶ Ì¶mÌ¶eÌ¶eÌ¶tÌ¶iÌ¶nÌ¶gÌ¶ Ì¶@Ì¶ Ì¶DÌ¶fÌ¶iÌ¶nÌ¶iÌ¶tÌ¶yÌ¶)Ì¶ and it will focused on address format.

Best

EDIT: due to a conflict with a community conversation we have restored the time back to 5pm.

-------------------------

mariop | 2022-05-25 09:15:13 UTC | #39

Hi again, we have decided to close the meeting for Ledger&Tokenization to avoid further intrusions. We need to collect the email of the people that want to participate to the meeting next Friday. Can you please fill [this form](https://dfn.typeform.com/to/foRmXTpe) and share it around? Thank you :).

-------------------------

mariop | 2022-05-30 08:39:10 UTC | #40

hi everyone, 
tomorrow we are going to discuss about payments with the various standard. I'll present the one using the ICP Ledger but it would be nice to do the same with the existing standards. This should help the community to understand pros/cons of each payment flow. Ideally we want **one payment flow** for the community-driven standard. It should be easy to support and work well within the context of the IC.
I cannot stress enough how important it is that we get to know each standard before we make a decision. The payment flow can make or break a token standard on the IC. So please spend some time tomorrow with us to talk about the flow you had in mind.

-------------------------

mariop | 2022-06-08 13:43:44 UTC | #41

Hi everyone, as promised during last meeting I've created a forum post about ERC-20's approve/transferFrom issues that we have collected. Please have a look [ERC-20's approve/transferFrom security concerns for the ICRC-1 Token Standard](https://forum.dfinity.org/t/erc-20s-approve-transferfrom-security-concerns-for-the-icrc-1-token-standard/13610).

-------------------------

mariop | 2022-07-05 12:37:39 UTC | #42

Hey everyone, a quick reminder that today we are going to finalise the core ICRC-1 token standard during the working group at 6pm CEST time. See you later!

-------------------------

emmaperetti | 2022-11-24 16:26:43 UTC | #43

join todays community conversation: https://internetcomputer.org/live-sessions/#Community-Conversation-ICRC-2-Bringing-Approve-and-Transfer-From-Functionality-to-the-IC-Token-Standard @mariop @dieter.sommer @roman-kashitsyn

-------------------------

dieter.sommer | 2022-11-28 18:58:21 UTC | #45

Dear community!

For tomorrow's (November 29) meeting of the ledger and tokenization WG we would like to propose an agenda with the following topics:
* ICRC-2 recap
  * Hum on current ICRC-2 proposal
  * Initiating the voting if there is rough consensus
* WG governance
  * Feedback from the governance WG
  * Next steps

If you have any other suggestions for topics, please let me know.

-------------------------

dieter.sommer | 2022-11-29 11:18:37 UTC | #46

Dear WG members and interested parties!

This is the "official" channel for the Ledger and Tokenization WG, the other one we had is "closed" to not fragment our online presence too much.

-------------------------

dieter.sommer | 2022-11-29 17:08:06 UTC | #47

Problem with the Zoom link, please use this one one:
https://dfinity.zoom.us/j/93088879165?pwd=K0plTFRvbU1BUXlXd0x1Z1ZSUFJodz09

-------------------------

dieter.sommer | 2022-11-29 19:39:58 UTC | #48

Due to a problem with the Zoom link that could not be fixed in time, the meeting of November 29th could not be held. The problem has been addressed now and a new invitation has been created. Please delete all old invitations and use the one in the [Working Group Calendar](https://calendar.google.com/calendar/embed?src=c_ck0gr79bkgcooicn1p87mo1ero%40group.calendar.google.com&ctz=Europe%2FZurich) ([Google Calendar link](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t)).

We propose to move the meeting from today to next week, same day and time, and remain on the current 2-week schedule after that.

**Next meeting:** December 6, 2022, 18:00-19:00 CET.

Note that the Zoom link has changed.
**Please always use the Zoom link from the calendar above!**

Sincere apologies for this and also for the multiple calendar emails you have received.

-------------------------

dieter.sommer | 2022-12-05 14:10:06 UTC | #49

Dear Working Group

**tl;dr**
**Next WG meeting tomorrow, Dec 6, 2022, 18:00-19:00 CET/UTC+1**

Because of the hiccup with Zoom last week, we are having the WG meeting planned for last week tomorrow, December 6, 2022, 18:00-19:00 UTC+1. We would like to move forward with the WG agenda and bring some items to a conclusion, therefore we have quite a full program.

**Please always use the Zoom link in the shared WG calendar:**
* [Google Calendar](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t)
* [Web calendar](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich)

**Proposed agenda**
- ICRC-2 proposal (ICRC-2)
  - Walkthrough over the proposal
  - Hum on current ICRC-2 proposal
  - Initiating the voting if we have rough consensus
- Working Group governance (ICRC-0)
  - Feedback from the governance WG
  - Call for feedback
  - Core working group
- Other
  - Voting participation
  - Working group composition
  - Upcoming items

**[Slides](https://docs.google.com/presentation/d/1nHgxpfDhkfR1eou91wLRn8Zz634BfwccCkysqEvEOfM/edit#slide=id.g125c3b1bfa8_0_0)**

**[ICRC-2 slides](https://docs.google.com/presentation/d/1ltqc1GR2BXcbVSU1KrW4h3LTXa7ZWudnaOdMmBjini4/edit#slide=id.p)**

Let us know on the [forum](https://forum.dfinity.org/t/announcing-token-standard-as-topic-of-the-first-meeting-of-the-ledger-tokenization-working-group/) or on [Discord](https://discord.com/channels/748416164832608337/976871875043016704) or send a private note if you would like something else to be also discussed in this meeting.

-------------------------

dieter.sommer | 2022-12-12 19:30:02 UTC | #50

From the abandoned topic of the working group, by @Embark, reposting here:
[quote="Embark, post:47, topic:15298, full:true"]
Dear colleagues, what are your thoughts about adding a restricted transfer function where the token minter can define conditions for transfers in a future version of ICRC?

Use-Cases include transfer-level conditions such as lock-up periods, identities to be known or accepted by Internet Identity personhood check as well as token-level conditions i.e. the token contract enforces a maximum number of investors or a cap on the percentage held by any single investor.

```
function canTransfer(address _to, uint256 _value, bytes _data) external view returns (byte, bytes32);
function canTransferFrom(address _from, address _to, uint256 _value, bytes _data) external view returns (byte, bytes32);
```
[/quote]

-------------------------

dieter.sommer | 2022-12-12 20:30:01 UTC | #51

Dear working group members!

Here are the agenda and slides for the ledger and tokenization WG meeting tomorrow.

**Agenda:**
* Communication & collaboration channels
* Working group composition
* Proposed change to voting
* Working group governance (ICRC-0)
* Textual Encoding format for ICRC-1 account addresses
* ICRC-2 proposal (ICRC-2)
* If time: ICRC-3

**Slides:**
https://docs.google.com/presentation/d/1dxypgWRN5Vz30uy2mdMIDqNBoNbMKMRibw5DU34xiMs/edit#slide=id.g1b48e05b3ca_0_45

**Please always use the Zoom link in the shared WG calendar:**

* [Google Calendar](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t)
* [Web calendar](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich)

-------------------------

dieter.sommer | 2022-12-13 18:46:13 UTC | #52

The WG vote on the [ICRC-2 proposal](https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-2/README.md) has been opened. Core WG members, please vote on [GitHub](https://github.com/dfinity/ICRC-1/issues/77). The vote is open for one week.

-------------------------

Maxfinity | 2022-12-13 23:13:42 UTC | #53

**On the textual encoding of subaccounts.** 

@mariop @dieter.sommer @roman-kashitsyn @jorgenbuilder 

Hi all, following the discussions in the working group, I would like to make a case for a single textual encoding that satisfies the following properties:

(1) Uniqueness. No two valid textual encodings should specify the same combination of ```<principal>:<subaccount>```. 
(2) Concise. The textual encoding should enable short sub-accounts if possible, e.g. those beginning  0,1 etc.
(3) Checked. Incorrectly copied textual representations, e.g. with a few digits altered from a valid textual encoding should be considered invalid.
(4) Readable. Easy for a person to read (This is primarily (2) but also includes a delimiter to separate principals and subaccounts.

I propose the following format, which I believe satisfies these properties better than the current proposed format. 

New format is given by the following function:

```CHECKSUM[<Principal>:TRUNCATE(HEX(<sub-account>))]```

CHECKSUM is a checksum function that capitalises based on the hash of the input.  As is done with Ethereum addresses we capitalise symbols of the output based on the hash of the input string of the non-capitalised/ non-checked textual representation. See how this is implemented in Ethereum here [here](https://coincodex.com/article/2078/ethereum-address-checksum-explained/). What's nice about this is that non-checked textual representations simply don't include the capitalisation, and so we can even have checked Principals as well as checked Principal: subaccounts, unlike in the previously proposed format.

```HEX(<sub-account>) ``` is the hexadecimal representation of the sub-account byte array. 

The truncate function removes all redundant zeros. For instance the Byte array in hex representation ```000...001``` is represented as the string `1` to satisfy the uniqueness property. 

As an example, suppose the following is a valid textual encoding, for purposes of comparison we will show some invalid representations made by making slight alterations. 
```
4Kydj-ryaAa-aaAaG-qaf7A-cai:1
```
Now, to give an example of what would be invalid representations - suppose we changed the subaccount to 2, then ```4Kydj-ryaAa-aaAaG-qaf7A-cai:2``` is invalid because it violates the checksum, the checksum would actually be some other capitalisation, say: ```4Kydj-rYAaa-aaAag-Qaf7A-cai:1```. Now suppose we also added an extra 0 to the subaccount: ```4Kydj-rYAaa-aaAag-Qaf7A-cai:01```. This is invalid because it contains an extra 0 before the 1 and would break the uniqueness property. 

Note also ```4Kydj-ryaAa-aaAaG-qaf7A-cai:0``` is invalid as this can be represented as ```4Kydj-ryaAa-aaAaG-qaf7A-cai``` 

I think this representation would give the nicest most readable principal:account-identifiers, whilst also enabling check-sums for both the ```<principal-id>:<subaccount>``` and vanilla ```<principal-id>``` formats. 




Note compared to the old representation, we don't need to know the length of the principal if we use a delimiter to separate the principal and subaccount. This is a better option because it results in a format that is easier to read by humans.

-------------------------

dieter.sommer | 2022-12-14 08:55:22 UTC | #54

@Maxfinity, thank you for continuing the discussion from yesterday's meeting. The above might also be interesting to @timo , @jorgenbuilder, @cryptoschindler, @hpeebles, @witter, @jzxchiang, @avi, and @mparikh.
The current standard proposal is [here](https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/README.md#textual-representation-of-accounts) ([slides 5 and 6](https://docs.google.com/presentation/d/1r85i2iAkli6dv-Ou_rD6l3wA2RTHoggBBsxXaj3rvFo/edit#slide=id.g15c8cda882c_0_8)).
Let's try to conclude on this before the holiday break!

-------------------------

timo | 2022-12-14 08:51:49 UTC | #55

[quote="Maxfinity, post:53, topic:11925"]
The truncate function removes all redundant zeros.
[/quote]

So subaccount 0 would look like this?
```
4Kydj-ryaAa-aaAaG-qaf7A-cai:
```

To clarify. Property (4) means "parseable by the human eye", right? So a human can see what the principal is.

Some considerations on the checksum:

* This type of checksum makes it easier for receivers to skip the validation. We have seen this on Ethereum. People were thinking their exchange would check the checksum on their withdrawal address but they didn't and funds got lost. The problem is that both the capitalized and non-capitalized versions are valid at least somewhere. It may not be as bad for us as it is for Ethereum because the principal is checksummed in itself, so the worst that can go wrong is the subaccount.
* On Ethereum it wasn't planned, they simply forgot to introduce a checksum and came up with the capitalization later as a hack.
* base32 was designed for all the same case to avoid similar looking characters. For example, I and L are allowed and both the lower-case combination il and the upper-case combination IL are clear. But a mixed-case Il isn't. (Those characters are `Il`.) If we expect nobody to type then maybe not an issue.
* Principals were designed to be easy to visually compare for equality. Partial capitalization may lose this property. For example compare these two:
4Kydj-ryaAa-aaAaG-qaf7A-cai
4kydj-ryaaa-aaaag-qaf7a-cai
vs these two:
4kydj-ryaaa-aaaag-qaf7a-cai
4kydj-ryaaa-aaaag-qaf7a-cai
So the question is if this proposal even gives us property (4) or not.

I have argued before that a checksum for subaccount isn't needed because we can recover from failures. If we believe it is needed and we want property 4 as well, then can't we leave the principal untouched and do an extra checksum somewhere related to the subaccount (for the price of making it longer)?

-------------------------

Maxfinity | 2022-12-14 09:16:45 UTC | #56

[quote="timo, post:55, topic:11925"]
I have argued before that a checksum for subaccount isnâ€™t needed because we can recover from failures. If we believe it is needed and we want property 4 as well, then canâ€™t we leave the principal untouched and do an extra checksum somewhere related to the subaccount (for the price of making it longer)?
[/quote]

*Good point, capitalisation of a specific letter say I or L could be avoided by the algorithm. 

*Personally, because the receiving address is checked, it doesn't actually need to look exactly the same for you to have a high degree of confidence that both receiving addresses are correct. Say you had derived: 

4Kydj-ryaAa-aaAaG-qaf7A-cai:1
from 
4kydj-ryaaa-aaaag-qaf7a-cai

Well, if you had made a mistake in copying any part of the principal, then the check would fail. So this is still kind of safe, and the fact the strings look vaguely similar should give a user enough confidence when using their apps. 

On your other point about whether checked sub-accounts should be optional: I would argue that checked sub-accounts would be a necessity. You could use a specific sub-account for receiving payments with each sub-account dedicated to a different user - in this case and many others, payments to the wrong sub-account are not recoverable. 

So the question should be where to put the check for the sub-account. Suppose we put it at the end, this would also be ok. However, I think you lose the property that a user can create their own subaccount address string by simply appending a 1, as the user now has to use some encoding to generate a check. You could also make the checksum optional, and I think that would also be ok. 

See below for an example:

4kydj-ryaaa-aaaag-qaf7a-cai:1
4kydj-ryaaa-aaaag-qaf7a-cai:1:aa-bc

-------------------------

timo | 2022-12-14 15:35:48 UTC | #57

[quote="Maxfinity, post:56, topic:11925"]
Say you had derived:

4Kydj-ryaAa-aaAaG-qaf7A-cai:1
from
4kydj-ryaaa-aaaag-qaf7a-cai

Well, if you had made a mistake in copying any part of the principal, then the check would fail. So this is still kind of safe, and the fact the strings look vaguely similar should give a user enough confidence when using their apps.
[/quote]

I am sure it's safe enough but I am worried about the user experience. Say a user gets shown deposit address in a pop up window (4Kydj-ryaAa-aaAaG-qaf7A-cai:1). Now we are asking the user to compare that to the canister id that he sees somewhere else (e.g. in his address book where it is all lower caps) to make sure he pays the right canister. Even if it is safe, it's still too confusing for the user.

[quote="Maxfinity, post:56, topic:11925"]
However, I think you lose the property that a user can create their own subaccount address string by simply appending a 1
[/quote]

But you lose that with the capitalization, too. The user has to run a tool to compute the capitalization.

-------------------------

benji | 2022-12-14 18:49:40 UTC | #58

The capitalization checksum idea is interesting. But since the principal is already checksummed, and we'd like the user to be able to easily compare visually, why don't we just cap checksum the subaccount part?

Then we would have:
`4kydj-ryaaa-aaaag-qaf7a-cai:1`
`4kydj-ryaaa-aaaag-qaf7a-cai:3fCe35D21Aa8`

which is 1)unambiguous in which principal you're transferring to, 2)easily human constructible in simple cases and 3)checksummed when machine generated long subaccounts are used.

-------------------------

benji | 2022-12-14 19:06:04 UTC | #59

And for this to be canonical `4kydj-ryaaa-aaaag-qaf7a-cai:0` is always written as such.

-------------------------

levi | 2022-12-14 19:37:37 UTC | #60

[quote="Maxfinity, post:53, topic:11925"]
so we can even have checked Principals as well as checked Principal: subaccounts, unlike in the previously proposed format.
[/quote]

Hi @Maxfinity, the current textual account representation does have a checksum(principal + subaccount)

-------------------------

Maxfinity | 2022-12-14 21:57:05 UTC | #61

@timo, @benji I would be happy with this suggestion, just capitalise the subaccount. Most receiving addresses in code would be machine generated, and these short sub-accounts could be used for one-off payments between users (can be manually checked if things go wrong). 

 Also like @timo's original suggestion but with an extra check bit for security. 

Of course, If we primarily use the ```approve, transfer_from``` payment flow, rather than paying to receiving addresses that need subaccounts, it becomes less of a necessity to check the subaccounts. Well subaccounts are much less needed in general here, but the former payment flow is much more common on the IC so...

-------------------------

dieter.sommer | 2022-12-16 21:17:52 UTC | #62

@Maxfinity, thank you for your last-minute change proposal w.r.t. the textual representation. @roman-kashitsyn, @benji, and I just had a good discussion on the proposal and what has been discussed in the forum by @Maxfinity, @timo and others.

# Here's a summary of our findings.

## The properties we want to achieve

* A textual encoding of any non-reserved principal is a valid textual encoding of the default account of that principal on the ledger.
* The decoding function is injective (i.e., different valid encodings correspond to different accounts). This property enables applications to use text representation as a key, for example in a map.
* Protection against copy-paste errors or typos
* Human readability (particularly the ability to identify the subaccount with the naked eye)

## Approach

We concluded that the most suitable representation meeting those properties is the one presented in the following examples (note that the principal contains a checksum over itself):

* `4kydj-ryaaa-aaaag-qaf7a-cai` (default subaccount = principal)
* `4kydj-ryaaa-aaaag-qaf7a-cai:1` (simple subaccount, no checksum on subaccount)
* `4kydj-ryaaa-aaaag-qaf7a-cai:3fCe35D21Aa8` (complex subaccount, contains checksum over the whole 2-tuple through the case of letters in the hexadecimal representation of the subaccount)

### Informal specification

Let *f* be the textual encoding function specified as follows, where *||* is string concatenation. Let *principal* be a principal in textual representation and *subaccount* a subaccount in byte array representation.

*f(principal, subaccount) := principal || ":" chk(principal || ":" || hex(subaccount), subaccount)*

*chk(a, b)* is a checksum function that capitalises *b* based on the SHA-256 hash of *a*. The input string *a* is a canonicalized hexadecimal string, i.e., comprising only the characters *[0..9, a..f]*. The hexadecimal representation *a* is hashed with SHA-256 to obtain *h*, and for each digit with index *i* in *a*, print it in uppercase in the result, if the *4\*i*-th bit of the hash is 1, in lowercase otherwise. Digits are taken over from *a* to the result. I.e., we capitalise letter symbols of *b* in the output based on the hash *h* of *a*. This is analogous to [Ethereum address checksums](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md).

### In words

* The encoding is created from the principal, followed by a colon, followed by the subaccount
* The subaccount is defined as follows:
  * Take the subaccount in hexadecimal representation with leading zeroes stripped
  * Compute a checksum over the principal and subaccount and represent it through the case of the letters in the hexadecimal representation of the subaccount (the principal remains untouched)

## Question / discussions

* Do we need to include the ":" in the input to the checksumming, as a "domain separator"? Does not harm, but not clear whether it is really needed. If not, it should be removed.
* Why does Ethereum EIP-55 use the *4*i* and not just *i*? For a good hash function, this should not make any difference.
* Should we rather do the hashing on the byte-array representations? Might be cleaner, it would be an easy change that we need to discuss.

## What does this achieve?

* This checksum is part of the resulting subaccount only if the hexadecimal representation of the subaccount contains letters. I.e., for "simple" subaccounts like 1, 2, etc. there is no checksum available for this reason as digits don't have a case. For subaccounts derived through a hash function, e.g., SHA-224 or SHA-256, we have an expected ~21 or ~24 bits of checksum, respectively, expressed through casing of the letters, which catches copy-paste errors with high probability. Simple accounts like "1", "1234" etc. do not have a checksum.
* We leave the principal untouched, so it can be easily compared via eyeballing.
* We have a checksum over everything if the subaccount is not a "simple" subaccount. Having checksums over complex, long subaccounts addresses requirements addressed in the forum threat. Not having checksums over short, simple subaccounts seems OK in the light of the discussions.
* Having upper/lowercase in the subaccount has not been seen as an issue so far (but also not explicitly addressed). @timo?
* Users can still create simple subaccounts on their own as they are not checksummed.

We think that this approach is the best compromise we can make given the discussion we have had so far in the forum. It has checksums where helpful, but skips them where we think that they are less required. We think this is a clear improvement over the [previous proposal](https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/README.md#textual-representation-of-accounts).

Please let us know what you think about going forward with this proposal. If we do not hear objections, someone needs to spec it properly and then we can open a vote on it. At least it seems that what we have now is strictly better than what we had before.

-------------------------

timo | 2022-12-17 11:40:47 UTC | #63

Is the checksum optional? That is, can a user opt-out and just write everything lower case if he wishes and forego the benefits of the checksum?

Do we need the checksum to include the principal? Isn't it sufficient if it is computed from the subaccount alone?

The principal's internal checksum is based on CRC32. Instead of introducing a new function, sha256, would it make sense to use crc32 again to reduce code dependencies and maybe it is also faster?

-------------------------

timo | 2022-12-17 12:02:53 UTC | #64

We have no checksum for small subaccount ids and >20bit for large ones. But what about the middle size? I am sure there are application where subaccount ids are generated sequentially and handed out.

For a 4 byte size (8 characters) we have on average 3 bits of checksum. For a 8 byte size (16 characters) we have on average 6 bits of checksum. Compare that to an IBAN which has ~6.5 bits.

If we consider that number of bits fine then I think we are better off adding a fixed length of 1 byte (2 characters) to the subaccount id, i.e. instead of
```
4kydj-ryaaa-aaaag-qaf7a-cai:3fCe35D21Aa8
```
write one of these (if the checksum is 1b):
```
4kydj-ryaaa-aaaag-qaf7a-cai:3fce35d21aa8.1b
4kydj-ryaaa-aaaag-qaf7a-cai:3fce35d21aa81b
4kydj-ryaaa-aaaag-qaf7a-cai:3fce35d21aa8:1b
4kydj-ryaaa-aaaag-qaf7a-cai:3fce35d21aa8-1b
4kydj-ryaaa-aaaag-qaf7a-cai:1b.3fce35d21aa8
4kydj-ryaaa-aaaag-qaf7a-cai:1b3fce35d21aa8
4kydj-ryaaa-aaaag-qaf7a-cai:1b:3fce35d21aa8
4kydj-ryaaa-aaaag-qaf7a-cai:1b-3fce35d21aa8
```
It avoids confusion for users who aren't used to the capitalization. Moreover, with a 4 byte subaccount 1 out of 4 subaccount ids will be all lower case or all upper case. Then the user will wonder if what he is looking at is checksummed or not. These things are avoided by adding dedicated checksum characters.

-------------------------

levi | 2022-12-18 00:35:08 UTC | #65

[quote="dieter.sommer, post:62, topic:11925"]
We think this is a clear improvement
[/quote]

Hi @dieter.sommer, @Maxfinity, 
This would remove the copy-safe characteristic of the current textual representation.
[quote="dieter.sommer, post:62, topic:11925"]

* `4kydj-ryaaa-aaaag-qaf7a-cai:1` (simple subaccount, no checksum on subaccount)
* `4kydj-ryaaa-aaaag-qaf7a-cai:3fCe35D21Aa8` (complex subaccount, contains checksum over the whole 2-tuple through the case of letters in the hexadecimal representation of the subaccount)
[/quote]
In both of these examples it is very easy for a user to only copy the principal and miss the subaccount. One of the main benefits of the current textual representation is that it is 100% copy-safe. A user cannot mis-copy any part of the account-id because no part is valid without the whole. This is a very valuable feature.

I think in most cases a dao will not help a user who sends tokens to the main account when the tokens are supposed to go to a subaccount, the tokens may be already transferred out of the main account by then or similar.

It is also straightforward and easy for a dapp to have a UI where the user can create subaccounts using simple numbers (1,2,3) and the dapp-ui will generate the account-id for it.

-------------------------

dieter.sommer | 2022-12-18 16:43:32 UTC | #66

[quote="timo, post:63, topic:11925"]
Do we need the checksum to include the principal? Isnâ€™t it sufficient if it is computed from the subaccount alone?
[/quote]

It seems that the following argument of @levi applies here:

[quote="levi, post:65, topic:11925"]
In both of these examples it is very easy for a user to only copy the principal and miss the subaccount. One of the main benefits of the current textual representation is that it is 100% copy-safe. A user cannot mis-copy any part of the account-id because no part is valid without the whole. This is a very valuable feature.

I think in most cases a dao will not help a user who sends tokens to the main account when the tokens are supposed to go to a subaccount, the tokens may be already transferred out of the main account by then or similar.
[/quote]

Our impression of earlier discussions was that we could forego the checksum for "simple" account ids, striking a balance between simplicity and checksumming. But it seems there are strong opinions of having everything checksummed, always, and an explicit checksum somewhere in the string. It seems there are multiple strong opinions to go for the
`<<principal>>:<<subaccount>>:<<checksum>>`
approach following the latest discussion. I.e., one of the approaches @timo has outlined above.

Thanks for the active discussions and bringing this forward.

Other opinions on the importance of the whole account id being checksummed, always?

-------------------------

mparikh | 2022-12-19 01:47:31 UTC | #67

I think that the whole_account = <<principal>>::<<subaccount>> being checksummed always makes sense. 

Consider the use-case of invoices for a customer, where a customer is a principal. 

customer1::1                                      would be simple account_id
customer2::12345                              would also be valid 
customer3::                                         "long description of account id" -> hashed to something smaller

-------------------------

timo | 2022-12-19 10:39:00 UTC | #68

[quote="dieter.sommer, post:66, topic:11925"]
It seems that the following argument of @levi applies here
[/quote]

I think @levi 's argument was different. It was primarily about the principal alone being a valid account encoding, hence it would be possible to miss the subaccount when copying and still end up with a valid account. That argument has no bearing on whether the checksum should be taken over the subaccount alone or the principal-subaccount combination. Because in the scenario that @levi is taking about the user has missed copying the checksum, so the nature of the checksum cannot have an influence on the outcome.

-------------------------

benji | 2022-12-19 10:46:51 UTC | #69

If we write the 0 subaccount canonically as `principal:0` it would solve @levi 's concern.

-------------------------

benji | 2022-12-19 11:21:08 UTC | #70

Several design trade-offs here:
i) Ease of reading vs explicit checksum
Embedding the checksum as capitalisation is easier to read than having an additional checksum as prefix or postfix. It's clear what the actual principal and account IDs are, without needing mentally parse/understand the seemingly random checksum byte.

ii) Ease of subaccount generation manually, without using an external tool
In the capitalisation checksum, for degenerate cases (subaccounts 0-9) there's no need to calculate the checksum, which is convenient because most such use cases would be transferring manually between subaccounts.


Decisions we need to make:
1) How to represent subaccount 0? We have previously decided that subaccount 0 should be represented as just the principal. Why was it decided that way? Wouldn't it make more sense to represent it as `principal:0`?
2) CRC32 vs SHA256
Since we're never encrypting the `principal:subaccount` with a stream cipher I see no problem with CRC32.
3) @roman-kashitsyn proposed that we should use Crockford's base32 encoding for the subaccount instead of hexadecimal for a more uniform representation, with the additional benefit of increasing the number of bits of checksum for large subaccounts.
4) Shall we use explicit checksum bytes?
Based on my reasoning above I would tend towards no.
5) Is checksum optional?
No. Because we don't have backwards compatibility issues like ETH and a single unique representation is always preferred.

-------------------------

timo | 2022-12-19 11:31:56 UTC | #71

[quote="dieter.sommer, post:66, topic:11925"]
It seems there are multiple strong opinions to go for the
`<<principal>>:<<subaccount>>:<<checksum>>`
approach following the latest discussion.
[/quote]

To discuss some details about this approach. What do you think about these?
1. Place the checksum in the middle so that the subaccount is more easily visible to the user at the end. Just in case there are scenarios where it is important to see, e.g., that the subaccount id matches a hash or is a certain small number.
2. Choose `-` as the separator. That seems easy on the eyes because the dash is already present on the left. So it would look like this: `4kydj-ryaaa-aaaag-qaf7a-cai:1b-3fce35d21aa8`. It puts a little less emphasis on the checksum, not creating the impression that there is a third material value. And finally, it makes it easier to make the checksum optional (see next point).
3. Make the checksum optional. For example both `4kydj-ryaaa-aaaag-qaf7a-cai:1` and `4kydj-ryaaa-aaaag-qaf7a-cai:1b-1` are valid for subaccount 1.

In my opinion the decision should be between 
a) the original proposal that was already spec'ed and that does not visibly expose the subaccount id, and
b) the proposal that we are discussion now, started by @Maxfinity, but with an _optional_ checksum

A checksum is only needed when there is transmission or copy-pasting going on. If we hand-craft an account id from the two components then a checksum does not help against errors (the errors would be made already on the inputs of the checksum). Instead it is a nuisance because it requires a tool to compute the checksum. If an account id is software generated and then passed to another software then a checksum does not help. Again, it is a nuisance because another library dependency is needed. Therefore, I think for scripting and command line use there is a huge benefit of leaving the checksum optional. We can add the following as property (5) to the list that @Maxfinity made:
(5) an account encoding can be hand-crafted from its two components.

Then proposal a) has properties (1)-(3) and b) has (2)-(5).

I think we should take (5) into account when deciding between a) and something else. And if we go with something other than a) then not leave (5) on the table. Or, by contraposition, if we need a tool to manufacture an encoding, i.e. if we don't have (5), then why not stick with proposal a)?

(I have no personal preference between a) and b). Both look good to me.)

-------------------------

benji | 2022-12-19 11:27:15 UTC | #72

What are properties (1)-(4) that you were referring to? @timo

-------------------------

timo | 2022-12-19 11:28:27 UTC | #73

Sorry, it is too far up already. Here they are:

[quote="Maxfinity, post:53, topic:11925"]
(1) Uniqueness. No two valid textual encodings should specify the same combination of `<principal>:<subaccount>`.
(2) Concise. The textual encoding should enable short sub-accounts if possible, e.g. those beginning 0,1 etc.
(3) Checked. Incorrectly copied textual representations, e.g. with a few digits altered from a valid textual encoding should be considered invalid.
(4) Readable. Easy for a person to read (This is primarily (2) but also includes a delimiter to separate principals and subaccounts.
[/quote]

-------------------------

benji | 2022-12-19 11:37:10 UTC | #74

Then this proposal satisfies all properties (1)-(5). 
Namely: `<<principal>>:<<subaccount in base32 with capitalisation checksum>>`,
where the capitalisation checksum is a bitmask of `CRC32(<<principal>>:<<subaccount in base32>>)`.

Examples:
`4kydj-ryaaa-aaaag-qaf7a-cai:0`
`4kydj-ryaaa-aaaag-qaf7a-cai:4`
`4kydj-ryaaa-aaaag-qaf7a-cai:dF3Nkr7UPr5Ffa`

-------------------------

timo | 2022-12-19 12:46:28 UTC | #75

It seems impossible to have (5) with a capitalisation checksum. For (5) the checksum must be optional. And a capitalisation checksum cannot be optional because it naturally occurs with a certain frequency that all letters are lower-case in the checksummed version, in which case the receiver cannot tell if the sender excepts the checksum to be checked or not.

-------------------------

benji | 2022-12-19 14:34:51 UTC | #76

The property (5) is achieved with the assumption that hand-crafted subaccounts have low IDs (0-9), and machine-generated cases have high subaccount IDs. Thus handcrafting `4kydj-ryaaa-aaaag-qaf7a-cai:4` is arbitrary.

Moreover the checksum is not optional, thus all lowercase/uppercase must be valid checksums too.

-------------------------

timo | 2022-12-19 14:41:28 UTC | #77

You mean low ids are only allowed 0-9 and everything starting from 10 has to be base32 encoded?

-------------------------

benji | 2022-12-19 15:08:03 UTC | #78

0-9 encoded using [Crockford's base32](http://www.crockford.com/base32.html) are 0-9 themselves.

-------------------------

skilesare | 2022-12-24 18:44:55 UTC | #79

[quote="benji, post:74, topic:11925"]
0
[/quote]

I'm messing with @quint 's Base32 and trying to output these.

https://m7sm4-2iaaa-aaaab-qabra-cai.raw.ic0.app/?tag=2189969043

Would you basically round off the preceding As?  This library outputs uppercase...I'm guessing adding the CRC32 checksum would be something we'd need to add somewhere.

Why does [1] Encode to AE?  Shouldn't it just be B?  I may be missing something significant about Base32.

What I need:  a motoko library that converts a subaccount [Nat8] (usually of length 32) to the proper account part of the textual representation.

-------------------------

timo | 2022-12-26 12:32:07 UTC | #80

[quote="skilesare, post:79, topic:11925"]
Why does [1] Encode to AE? Shouldnâ€™t it just be B? I may be missing something significant about Base32.
[/quote]

[1] is still a full byte. Instead of shrinking it to 5 bits (which would be 00001=B) you have to pad it to 10 bits which makes it 00000_00100=AE. 

[quote="skilesare, post:79, topic:11925"]
What I need: a motoko library that converts a subaccount [Nat8] (usually of length 32) to the proper account part of the textual representation.
[/quote]

I don't like base32 (any variation of it) for the subaccount part.

-------------------------

skilesare | 2022-12-26 13:31:41 UTC | #81

I misunderstood the base32 part...looks like we are just using hex.

-------------------------

benji | 2022-12-27 05:43:50 UTC | #82

That's still up for discussion. The current options are base32 (some flavour of it) or hex.

-------------------------

dieter.sommer | 2023-01-09 20:35:02 UTC | #83

Dear working group members!

Here is the proposed agenda for the ledger and tokenization WG meeting tomorrow, **Tuesday, January 10, 2023**. See the working group calendars ([Google Calendar](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t), [calendar browser link](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich)) for details and dial-in information.

* [ICRC-2](https://github.com/dfinity/ICRC-1/tree/main/standards/ICRC-2): Next Steps
* [ICRC-3]((https://github.com/dfinity/ICRC-1/pull/66/files)): A standard for accessing the transaction log
* [Textual encoding format for ICRC-1 account addresses](https://github.com/dfinity/ICRC-1/pull/55) ([forum discussion](https://forum.dfinity.org/t/announcing-token-standard-as-topic-of-the-first-meeting-of-the-ledger-tokenization-working-group/11925/62))

Looking forward to the meeting tomorrow!

-------------------------

dieter.sommer | 2023-01-21 14:22:13 UTC | #84

Dear working group members!

Here is the proposed agenda and draft slides for the ledger and tokenization WG meeting on **Tuesday, January 24, 2023**. See the working group calendars ([Google Calendar ](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t), [calendar browser link ](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich)) for details and dial-in information.

Agenda
* **Textual encoding format for ICRC-1 account addresses**

Draft [slides](https://docs.google.com/presentation/d/1J4RG6Dj2oFzOWTRbxh8J59I3iF49WSM1YoU92_vBMnM/edit#slide=id.g125c3b1bfa8_0_0)

If there's time, there are two other topics on the agenda (see slides).

I summarized the options that have been proposed for the textual encoding and included the key aspects of the forum discussions. Please have a look at the slides before the meeting!

It would be great if all people who have been actively involved in the encoding discussion could make it to the meeting!
@timo , @Maxfinity , @benji , @skilesare , @mparikh , @levi , @mariop , @roman-kashitsyn 

Looking forward!

-------------------------

dieter.sommer | 2023-01-23 19:00:51 UTC | #85

Reminder: Next standards meeting on Jan 24. See :fu:

TTYT

-------------------------

blabagastered | 2023-01-24 20:15:38 UTC | #86

More of an instinct than a thought but something just feels off about all this visual variety being valid encodings, especially if we add existing IC encodings for eg principals and canister IDs to the set of all valid identifiers on the IC.

![image|430x82](upload://jq7j8ddn6I6iADRwQRj5vOg6cMJ.png)

In general I get the impression that the IC makes many distinctions where other systems use a single category. Eg notions like Principal, Subaccount, Account ID, canister principals vs user principals, in say Ethereum all are a fixed-length output of a single hashing function of a single type of input. Some of those distinctions may be necessary or convenient, but each one adds a layer of conceptual and implementation complexity, and it's impossible to prevent that from turning into a degree of mental drag and confusion for users and developers (this very discussion and associated meetings for example are a consequence of having more than one type of identifier). Whether we like it or not, all friction is a barrier to adoption, for devs and users, and all complexity a source of error.

I just have a bad gut feeling about adding yet another substantially different format.

No overwhelming feelings and I'm certainly no expert, but I'd consider staying with the familiar IC-style of #55 or something like it (maybe a fixed-length version?), especially if I'm correct (not sure) in thinking that if you want to view or make available all subaccounts for a given principal at once, eg on an explorer, you can just decode the textual representation of #55, extract the principal, and use it to programatically obtain all principal-oriented data/assets, without any (or at most one?) conditional statements being required from the developer.

Just my two cents and I understand there's a history too.

-------------------------

mariop | 2023-01-26 14:20:06 UTC | #87

FYI [The ICP Ledger has been upgraded to support ICRC-1 and we published a javascript library that supports ICRC Ledgers](https://forum.dfinity.org/t/announcing-icrc-1-support-in-the-icp-ledger-and-a-javascript-library-for-icrc-ledgers/18194).

-------------------------

dieter.sommer | 2023-02-06 13:44:06 UTC | #88

Dear working group members!

Here are the proposed agenda and draft slides for the ledger and tokenization WG meeting on **Tuesday, February 07, 2023**. See the working group calendars ([Google Calendar ](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t), [calendar browser link ](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich)) for details and dial-in information.

Agenda
* **Textual encoding format for ICRC-1 account addresses**
If time
* Standard for and replacing DAB
* ICRC-3: A standard for accessing the transaction log

[Slides](https://docs.google.com/presentation/d/1vCIl8bMFcKUVyoNZl0MAq8WlSI_U2cBAPgN8XxO05BE/edit#slide=id.g125c3b1bfa8_0_0)

It would be great if all people who have been actively involved in the encoding discussion could make it to the meeting!
@timo , @Maxfinity , @benji , @skilesare , @mparikh , @levi , @mariop , @roman-kashitsyn 

Looking forward!

-------------------------

dieter.sommer | 2023-02-06 14:16:01 UTC | #89

See [here](https://github.com/dfinity/ICRC-1/blob/main/Charters.md#2023-01-24) for the summary of the discussion of the previous meeting of January 24 and [here](https://drive.google.com/file/d/1B04AtA-yMQcJdtFItb76dP48yAZkoiMu/view?usp=share_link) for the video.

-------------------------

dieter.sommer | 2023-02-14 10:35:26 UTC | #90

**New ICRC proposal**

There's a new ICRC extension proposal on *batch transfers* by @skilesare on the table: https://github.com/skilesare/ICRC-1/blob/Icrc4/standards/ICRC-4/readme.md

If you are interested in the subject, feel free to comment or make a PR.

-------------------------

dieter.sommer | 2023-02-20 13:19:13 UTC | #91

The slides, recording, and minutes of the WG Meeting of February 7 are available:
[**Slides**](https://docs.google.com/presentation/d/1vCIl8bMFcKUVyoNZl0MAq8WlSI_U2cBAPgN8XxO05BE/edit#slide=id.g1f8f37e578f_6_0)
[**Recording**](https://drive.google.com/file/d/1bgYyay1jgox2Cw6cm67lbEiKwDEAE0qx/view?usp=share_link)
[**Minutes**](https://github.com/dfinity/ICRC-1/blob/main/Charters.md#2023-02-07)

-------------------------

dieter.sommer | 2023-02-20 13:24:29 UTC | #92

Dear working group members!

Here are the proposed agenda and draft slides for the ledger and tokenization WG meeting on **Tuesday, February 21, 2023**. See the working group calendars ([Google Calendar ](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t), [calendar browser link ](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich)) for details and dial-in information.

Agenda

* **Textual encoding format for ICRC-1 account addresses**
If time
* Standard for and replacing DAB
* ICRC-3: A standard for accessing the transaction log

[Slides ](https://docs.google.com/presentation/d/1c62oP0p3bM2B21n5ORYI0OAJWVEytO0vCjEspTnIIgw/edit#slide=id.g125c3b1bfa8_0_0)

The main question is whether we can settle on having the checksum suffixed to the principal with a "-" separator:

`4kydj-ryaaa-aaaag-qaf7a-cai` principal = subaccount `0` (default subaccount)
`4kydj-ryaaa-aaaag-qaf7a-cai-1bef.1` subaccount `1`
`4kydj-ryaaa-aaaag-qaf7a-cai-7ab1.3fce35d21aa8` subaccount `3fce35d21aa8`

Let's finish the encoding discussion tomorrow and tackle new items soon!

-------------------------

dieter.sommer | 2023-02-22 16:29:24 UTC | #93

The slides, recording, and minutes of the WG Meeting of February 21 are available:
[**Slides** ](https://docs.google.com/presentation/d/1c62oP0p3bM2B21n5ORYI0OAJWVEytO0vCjEspTnIIgw/edit#slide=id.g20f9d73110e_0_20)
[**Recording**](https://drive.google.com/file/d/1lHevLT_Dmk-2wpyJ4chhzsJE00SYtiR3/view?usp=share_link)
[**Minutes**](https://github.com/dfinity/ICRC-1/blob/main/Charters.md#2023-02-21)

-------------------------

dieter.sommer | 2023-03-06 18:45:18 UTC | #94

Dear working group members!

Here are the proposed agenda and draft slides for the ledger and tokenization WG meeting on **Tuesday, March 7, 2023**. See the working group calendars ([Google Calendar ](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t), [calendar browser link ](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich)) for details and dial-in information.

Agenda
* Textual encoding format for ICRC-1 account addresses: Checksum
* ICRC-2: Recurring payments

Upcoming items
* ICRC-3: A standard for accessing the transaction log
* Standard for and replacing [DAB](https://github.com/Psychedelic/dab)

[Slides ](https://docs.google.com/presentation/d/11QcNtl8QFNg2LL1BrahDU559Uy7LoSXXPGJz_vDxKTk/edit#slide=id.g125c3b1bfa8_0_0)

Talk to you tomorrow!

-------------------------

levi | 2023-03-07 02:20:46 UTC | #95

Hi Everyone,

See this about keeping separate approval balances for each approval even for the same approver-spender combo. https://github.com/dfinity/ICRC-1/issues/93.

If we do, implementing periodic/recurring approvals is straightforward.

-------------------------

skilesare | 2023-03-07 04:57:59 UTC | #96

I thought an important point of having transferFrom was that the spender didn't have to know a block height and thus the payment flow was simplified.

It is a bit late for me to think of a solution, but "in the real world" each additional notification of something or waiting for something is another friction point that is causing our users issues.

Ideally I'd like for my user to be able to approve and then I'm able to pull those funds without them having to know the id of the block....searching for them is hard and in a flow where two separate systems maybe making the notification and sending the payment it makes things more complex.

I'll think more on it.

-------------------------

blabagastered | 2023-03-07 14:52:05 UTC | #97

Of possible interest to the working group: https://twitter.com/Tyler_Did_It/status/1632781451514073090?s=20

Details:
https://eips.ethereum.org/EIPS/eip-4337

-------------------------

dieter.sommer | 2023-03-10 14:56:08 UTC | #98

Let me share the following extensive report about the IC token standardization efforts:
https://coda.io/@connor/tokens-on-internet-computer

-------------------------

levi | 2023-03-16 22:44:21 UTC | #99

Hi Everyone!

See this correction for the ICRC-2 standard: https://github.com/dfinity/ICRC-1/pull/101.

Fixes [#93](https://github.com/dfinity/ICRC-1/issues/93 ). 

@skilesare This change does not require the spender to know any approval-block-ids. The `TransferFromArg` stays the same.

-------------------------

dieter.sommer | 2023-03-20 20:59:07 UTC | #100

The slides, recording, and minutes of the WG Meeting of March 07 are available:
[**Slides** ](https://docs.google.com/presentation/d/11QcNtl8QFNg2LL1BrahDU559Uy7LoSXXPGJz_vDxKTk/edit?usp=share_link)
[**Recording**](https://drive.google.com/file/d/1jpwUIQgkDl_M-IVdKLOBMzXfoPA8j6Ad/view?usp=share_link)
[**Minutes**](https://github.com/dfinity/ICRC-1/blob/main/Charters.md#2023-03-07)

-------------------------

dieter.sommer | 2023-03-20 21:00:29 UTC | #101

Dear working group members!

Here is the proposed agenda and draft slides for the ledger and tokenization WG meeting on **Tuesday, March 21, 2023**. See the working group calendars ([Google Calendar ](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t), [calendar browser link ](https://calendar.google.com/calendar/u/0/embed?src=c_ck0gr79bkgcooicn1p87mo1ero@group.calendar.google.com&ctz=Europe/Zurich)) for details and dial-in information.

Agenda
* ICRC-2: Recurring payments

If time
* ICRC-3: A standard for accessing the transaction log
* Standard for and replacing [DAB](https://github.com/Psychedelic/dab)

[Slides ](https://docs.google.com/presentation/d/1sOj9HEcnn_p9m1Xh1jlLfOFMB0KIUs9Lvy1XBwFE3qk/edit#slide=id.g125c3b1bfa8_0_0)

Talk to you tomorrow!

-------------------------


mariop | 2022-08-04 10:21:47 UTC | #1

Hi folks,

While working on the [ICRC-1 fungible token standard](https://github.com/dfinity/ICRC-1) we realised that it would be nice to have a string format for addresses that is human readable and compatible with most systems. This format is orthogonal to the standard but is a nice to have that could be incorporated with the standard itself.

We can discuss about it in the working group but I feel like this is a good discussion for the forum.

DFINITY proposal is to use URIs for account representation with the format:
```
ic:rc1:<principal>(.<subaccount>)?
```
where

1. `ic:rc1:` is fixed
2. `<principal>` is the string representation of principal, e.g `aaaaa-aa`
3. `<subaccount>` is a string version of subaccount. The format could be decimal and/or hexadecimal. E.g. decimal subaccounts are just numbers, e.g. `10`, and hexadecimal subaccounts start with `0x`, e.g. `0xa`.
4. the default subaccounts can be omitted to shrink the format for the default account to just `ic:rc1:<principal>`

For instance, `ic:rc1:aaaaa-aa.10` and `ic:rc1:aaaaa-aa.0xa` would be valid representations of the Account `record { owner = principal "aaaaa-aa"; subaccount = opt vec {0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;0;1;0;1;0} }`.

An alternative we could consider is to use [bech32](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) from BIP-0173. In this case the address could be something like `ic1<bech32(principal (. subaccount)?)>`. The reason why I'm not proposing this as first option is that we know some people don't like to encode accountid in the ICP Ledger because they find it confusing and bench32 could be considered the same.

There are also other options (Principal encoding or base58 either adaptive or not) that @infu put to vote in a poll https://forum.dfinity.org/t/icrc-1-token-standard-ledger/14109/109 .

What do you think we should use?

-------------------------

infu | 2022-08-04 11:16:31 UTC | #2

I like that you mentioned URIs. - Uniform Resource Identifier

> A **Uniform Resource Identifier** (**URI** ) is a unique sequence of characters that identifies a logical or physical resource used by web technologies. URIs may be used to identify anything, including real-world objects, such as people and places, concepts, or information resources such as web pages and books. Some URIs provide a means of locating and retrieving information resources on a network (either on the Internet or on another private network, such as a computer filesystem or an [Intranet](https://en.wikipedia.org/wiki/Intranet)); these are [Uniform Resource Locators](https://en.wikipedia.org/wiki/Uniform_Resource_Locator) (URLs). A URL provides the location of the resource. A URI identifies the resource by name at the specified location or URL. Other URIs provide only a unique name, without a means of locating or retrieving the resource or information about it, these are [Uniform Resource Names](https://en.wikipedia.org/wiki/Uniform_Resource_Name) (URNs).

I would like also to add the locating feature so that when you have an address you know where it's coming from. Makes sense in web3.
When that's needed:
Imagine the following scenario. We are at app 1 and we want to prove to it that we have proof of humanity NFT (or another soulbound token rewarded to us) in another dapp.
The user takes their address from app 2 and pastes it in app 1. Now app 1 can send frontend-to-frontend request to app 2 and prompt the user. If there is no location inside the address, then the user has to copy/paste the location too.


Also this can be optional, but part of the spec, like `https://address.com` and `//address.com` and `http://username:password@example.com/` are part of the same format. Same spec, optional parameters.

So you end up having something like 
```
(<domain>/)?ic:rc1:<principal>(.<subaccount>)?
```
Added benefit - when someone pastes that address in a browser, it can be made by the dapp devs to work like a blockchain explorer.
`
kontribute.app/ic:rc1:pcotu-nluuc-vzney-2ugxz-y2uis-duoyw-unfos-x6uyo-lnvgj-ohijr-sae.0xa
`
Another added benefit - users won't be "losing" their address origins. It looks like everyone is making wallets and a lot of dapps will also want to have their own wallets. They may use third-party "identities" but for backup/PoH, not for storing assets. So users will have a lot of different addresses. If they write down the address without location and they forget what the location is, they will lose access to their assets.

-------------------------

AdamS | 2022-08-04 17:55:35 UTC | #3

This would be URN-style, not a URL (the last of the three links in your quote).

-------------------------

bitbruce | 2022-08-05 04:12:51 UTC | #4

Account-id of ICP is a better solution. Reason.
1. Easier for users to use.
2. Consistent with ICP and developer friendly.
3. Support for privacy protection.

I never understood why this was used.

> type Account = record { owner: principal; subaccount: opt Subaccount; }

-------------------------

timo | 2022-08-05 05:46:00 UTC | #5

[quote="bitbruce, post:4, topic:14682"]
Easier for users to use.
[/quote]

Could you explain why it is easier to use?

-------------------------

bitbruce | 2022-08-05 06:44:28 UTC | #6

As a normal user, the address format in the wallet now has Principal and AccountId, which is already confusing.
Now that Token has introduced "Principal+Subaccount", won't the user be even more confused?
An account identifier is usually a relatively regular string of characters, so if "Principal+Subaccount" is used, how does the user send his account to another person? Using a format like "ic:rc1:pcotu-nluuc-vzney-2ugxz-y2uis-duoyw-unfos-x6uyo-lnvgj-ohijr-sae.0x0000000000000000000000000000000000000000000000000000000000000001”?  It will be difficult for users to accept.

-------------------------

timo | 2022-08-05 08:00:05 UTC | #7

[quote="bitbruce, post:6, topic:14682"]
the address format in the wallet now has Principal and AccountId
[/quote]

That was precisely the idea behind the proposal, to remove the fact that there are two identifiers and make it just one (the principal). So you could tell another person to send you tokens at `ic:rc1:pcotu-nluuc-vzney-2ugxz-y2uis-duoyw-unfos-x6uyo-lnvgj-ohijr-sae`. That's enough for the default account which is equal to subaccount `0`. If you want a different subaccount it would be `ic:rc1:pcotu-nluuc-vzney-2ugxz-y2uis-duoyw-unfos-x6uyo-lnvgj-ohijr-sae.1` in your example.

I think the use case where someone uses a long hex string as subaccount (for example a hash value) are rather special.

[quote="bitbruce, post:6, topic:14682"]
An account identifier is usually a relatively regular string of characters
[/quote]

Fair criticism. If you want a relatively regular string then that would be achieved with the second proposal from the original post (the one based on bech32).

-------------------------

mariop | 2022-08-05 08:45:36 UTC | #8

Hey @bitbruce, thanks for the feedback. Let me try to address it step-by-step.

[quote="bitbruce, post:6, topic:14682"]
As a normal user, the address format in the wallet now has Principal and AccountId, which is already confusing.
Now that Token has introduced “Principal+Subaccount”, won’t the user be even more confused?
An account identifier is usually a relatively regular string of characters, so if “Principal+Subaccount” is used, how does the user send his account to another person? Using a format like "ic:rc1:pcotu-nluuc-vzney-2ugxz-y2uis-duoyw-unfos-x6uyo-lnvgj-ohijr-sae.0x0000000000000000000000000000000000000000000000000000000000000001”? It will be difficult for users to accept.
[/quote]

Let's start with AccountId. AccountId will eventually be deprecated in favour of the ICRC-1 Accounts. The reason is that a part of the community was really strong about how unclear and opaque AccountIds are in the ICP Ledger. We heard the community and decided to replace AccountId with Account. Once ICRC-1 will be in place we will add more documentation for users. Note that eventually also ICP will support ICRC-1. 
Personally I think that AccountId were a mistake of DFINITY and it's good the community raised the issue. Kudos to the working group in particular for this.

Now let's talk about Principals. Principals have limitations, e.g. a Canister can have only one principal. Usually you want a user or smart contract to have multiple addresses. Hence Principals should not be used as addresses.
Let me also add here, before somebody jumps into the discussion, that changing the replica to solve a problem that can be easily solved at application level is not a good idea and would have deep security impact on the IC.

Given the two points above, the natural solution was to
1. make address equal to Principal+Subaccount, aka Account
2. provide a string representation for Account that would be the only thing seen by the user

Point 1. doesn't really affect users. I would expect users to see always the string format of Account in their wallet.
For point 2. we have different options which I enumerated above. II think that sending an account for a transfer will be easy as long as the account is a string that can easily be copied. This string can be generated by your wallet (btw that's always the case) and you would just copy it and send it. Any format would work.
The question is which format would be nicer. Should principal and account be transparent, but contain characters that are not alphanum, so that the user can double check? Should do the same but remove all the `:`, `.`, `-`? Should we instead use bech32 and have a less transparent string but compatible with existing libraries?

Finally a quick nitpick: with the transparent format, the address above would look more like `ic:rc1:pcotu-nluuc-vzney-2ugxz-y2uis-duoyw-unfos-x6uyo-lnvgj-ohijr-sae.1` which imho is easy to parse by both humans and machines :slight_smile:.

-------------------------

bitbruce | 2022-08-05 10:50:17 UTC | #9

I think this change will bring great harm to the ecology.

1. some users are already used to Principal and AccountId. they are already used to managing ICP assets with AccountId. If the ICP account format is suddenly changed, many people will think they have lost their assets. Be aware that they are not technical people. I have not seen a public chain project change its AccountId in this way after the main network has been launched.

2. Any Canister code that has been written using the original ICP interface needs to be upgraded. You have to balance compatibility and composability of the blockchain. The impact of this disruption on developers is very significant.

3. AccountId is not a bug, the idea is similar to BIP32 and allows for multiple account addresses as well as enabling anonymity.

4. If the "Principal+Subaccount" format is used, anonymity is lost and the format is difficult for the average user to understand (why would there be two fields for an account). Of course, this is not a problem for technical people, but it is different from the common sense of blockchain systems.

5. To eliminate the confusion between Principal and AccountId, it is recommended that Dapp reduce the use of Principal, which is only used for account management with matching private keys.

-------------------------

PaulLiu | 2022-08-05 11:28:17 UTC | #10

My personal take is that the 32-byte-length has some practical benefit, because it translates to U256. I am not aware of any major chain that has an address not fitting into 32 bytes.

-------------------------

mariop | 2022-08-05 11:59:30 UTC | #11

[quote="bitbruce, post:9, topic:14682"]
* some users are already used to Principal and AccountId. they are already used to managing ICP assets with AccountId. If the ICP account format is suddenly changed, many people will think they have lost their assets. Be aware that they are not technical people. I have not seen a public chain project change its AccountId in this way after the main network has been launched.
* Any Canister code that has been written using the original ICP interface needs to be upgraded. You have to balance compatibility and composability of the blockchain. The impact of this disruption on developers is very significant.
[/quote]

I think I didn't explain myself clearly. The ICP Ledger will always be compatible with AccountId. Changing that would break everything. Accounts and the ICRC-1 interface are in addition to the existing ICP interface. A new format will be added like it happens in many other networks where you have multiple type of addresses. Nothing will break, I promise :slight_smile: .

[quote="bitbruce, post:9, topic:14682"]
* AccountId is not a bug, the idea is similar to BIP32 and allows for multiple account addresses as well as enabling anonymity.
[/quote]

I can see the equivalence with BIP32 and similar formats. Anonymity on the other hand is not a valid arguments if we publish the subnets blocks, which has been required by the community. Specifically it would be always possible to link the "from" of a transfer with its principal.

For the user though there is little difference between the representation of AccountId and of Account proposed above. Both are strings you can use from a wallet.

[quote="bitbruce, post:9, topic:14682"]
* If the “Principal+Subaccount” format is used, anonymity is lost and the format is difficult for the average user to understand (why would there be two fields for an account). Of course, this is not a problem for technical people, but it is different from the common sense of blockchain systems.
[/quote]

I think it's easier to understand because it makes the existence of multiple accounts way more transparent. Each principal has many accounts that are identified by a subaccount. Simple and clean.

[quote="bitbruce, post:9, topic:14682"]
* To eliminate the confusion between Principal and AccountId, it is recommended that Dapp reduce the use of Principal, which is only used for account management with matching private keys.
[/quote]

I would suggest to switch to ICRC-1 Account as soon as the standard is in place. I think it's better than AccountId because you can extract Principal and Subaccount from it and it's also battle tested.

-------------------------

infu | 2022-08-05 13:10:15 UTC | #12

@PaulLiu @bitbruce That ship has sailed. This thread is not about the standard, but how we merge both pieces into one on a frontend level. The exact text users will see and nothing else.
How to convert the (Principal 29bytes and Subaccount 32bytes) into text so users can copy-paste it between apps. 
If we don't agree on one format, every dapp will use its own and users won't be able to copy addresses from one site and paste them into a transfer dialog on another, even if they both use the same standard.

Here is the thread related to the standard https://forum.dfinity.org/t/icrc-1-token-standard-final-draft/14343/36

-------------------------

bitbruce | 2022-08-05 13:35:03 UTC | #13

If you use AccountId, this thread will not appear.
This is artificially creating trouble.

A reality that has to be acknowledged.
The IC ecology is now a bit far from the crypto ecology, and there are many disconnects. It is the users of the crypto ecosystem and Cex who are now the mainstream user base, and the habits they have formed over a decade of experience are not easy to change. If account IDs are incomprehensible to them, many will be turned off and exchanges will find it difficult to list IC-related assets.

I hope you will do more to understand the habits of crypto users, especially those of the ETH ecosystem.

-------------------------

mariop | 2022-08-05 14:14:30 UTC | #14

[quote="bitbruce, post:13, topic:14682, full:true"]
If you use AccountId, this thread will not appear.
This is artificially creating trouble.

A reality that has to be acknowledged.
The IC ecology is now a bit far from the crypto ecology, and there are many disconnects. It is the users of the crypto ecosystem and Cex who are now the mainstream user base, and the habits they have formed over a decade of experience are not easy to change. If account IDs are incomprehensible to them, many will be turned off and exchanges will find it difficult to list IC-related assets.
[/quote]

I understand the concerns, believe me. The Foundation has discussed about this with our users and gathered a ton of feedback from the forum and other channels. The ICRC-1 Account is the result of that feedback and getting together with the community to agree on a standard. ICRC-1 is the first standard on the IC that is a joint effort between the Foundation and many entities on the IC.

AccountId is not incomprehensible. It's just not transparent because it's the hash of Principal+Subaccount and many users complained about that. I think it's fair but the point usually is that we should not hash the pair, not that the two components of AccountId are incomprehensible.

[quote="bitbruce, post:13, topic:14682, full:true"]
I hope you will do more to understand the habits of crypto users, especially those of the ETH ecosystem.
[/quote]

There is room for improvements and we will do our best to listen and understand the habits of our users. I'm sorry that we don't meet your expectations and I assure you we will try to improve. We are always happy to get feedback from our users. Consider that many changes have been done because of inputs from the community. The existence of the working groups themselves are the result of feedback from the users. Same for the ICRC-1 standards.
I also want to mention that we actively look for feedback in the working group. Next working group session, for instance, will also have a retrospective on how to improve the process.
Feel free to provide any feedback in the working group, here in the forum or even privately if you prefer.

-------------------------

infu | 2022-08-05 15:00:56 UTC | #15

I took the following address screenshots from IC, ETH, Cosmos, and Solana (at the end of the post). 
1) Almost never a full address is displayed
2) It always starts with the first 4+ characters and ends with 4+ characters

For crypto/anti-hacking purposes, it doesn't matter which characters the user is checking, but it's probably easier to read the first 4 and last 4 than reading 8 from the beginning or 8 from the end.

So we can't shorten it to `ic:rc1:....0xa` (because there are no pub key chars in that, anyone can make such an address) So it's best if we use the first few public key chars, then the last few pub key chars and then some coming from the subaccount. But then the problem is, that the full address won't look anything like the short address, which will confuse users. 
The short version has to be something like `PPPPPPP...SSSS` 
Where **P** is Principal char and **S** is a subaccount char. **P**-s are providing security while **S** is not in most cases.
or `PPPPPP...PPPP` if the Subaccount is null.
But what happens if a canister is for example making permissionless donation campaigns and giving each user a different Subaccount, but from one Principal - the canister? Then **P** won't be bringing a lot of security, anyone can create an account there. Only **S** will bring security and the difference can be one character. Probably nobody really types these by hand, but if you make a mistake, there will be no crc32 to error and you could be sending tokens to a bad address.
So we could do something like PPPPP..SSCC   Where **C** is crc32
But then you won't be able to clearly see your subaccount.

Another problem is Principals right now look like serial keys.
I guess I am more inclined to use base58 (which has more security inside the ~10 chars we show)
`AnwN...UCaY`
Which won't look too bad with a condensed font.
![image|380x126](upload://6q1kbOqCZTv1rmJhyHtT8MsaORY.png)
![image|648x150](upload://w8kbwodQRUd6yhS2E7QK55jVN3a.png)

Let's see how to location idea will work with this. You see the short version, hit copy and you get `mywallet.org/AnwNBG7a4rVJizGXQWTSQc69pFCUTCQJTC951zbLUCaY ` 
or `mywallet.org/ic:rc1:AnwNBG7a4rVJizGXQWTSQc69pFCUTCQJTC951zbLUCaY ` 
(Not sure if the location idea is good like that. Maybe it should be a nat64 -> location registry and always be inside the address, something like what cosmos is doing)
Food for thought

Other:

![image|398x122](upload://wXcUMXHugU7GZjJViKw85bmgFj5.png)
![image|690x88](upload://xQ9ehmC72B7A88E6biaSi1ckyP9.png)
![image|586x120](upload://r2UAgFzSxwLbaXNBHbRYgChAf2u.png)
![image|458x132](upload://5cfal60MIWEZjonpcaTnxfD6WDe.png)
![image|480x148](upload://5xXUfS4i7R5exH4hGnWWSY81w04.png)
![image|690x85](upload://hgDEnRqN9EcUQygaw0mUheaCpaf.png)
![image|572x100](upload://3Vqh4DEnkGCywvfDeVl9GwP82Ll.png)
![image|604x96](upload://uQrEruTdaHK0ALjW4UV6SnAtXUL.png)
![image|394x136](upload://nwaPwsNnIoNLgV5DnPMeUdYiki0.png)
![image|690x135](upload://f3tKQvPZhS8v53MXXyGzqKZgk7K.png)
![image|690x126](upload://c6FvBrSbggocHk9splxnBkm0kRT.png)
![image|690x232](upload://medv6ylwR8FQPRHbXip0ATJhdrI.png)
![image|690x91](upload://88h59taCaXnFvXgohWdAsLgwlcc.jpeg)
![image|690x88](upload://wGzApBen0137BSL4wo9M9u9N2wz.png)
![image|514x166](upload://qroSLlhaP8T2o3Nu2ItZitAjJZa.png)
![image|250x76](upload://xoRvZzNxQdM72J3sFRuu7PpEuPC.png)
![image|690x73](upload://xmk890f7kBKuoAi3AuBgMNsgOLh.png)
![image|690x65](upload://2nZZ7y41yjfRQOmpNF1yURjXJ9k.png)

-------------------------

mariop | 2022-08-05 15:16:24 UTC | #16

Great post, thank you @infu ! Should we consider bech32 (BIP0173) instead of base58? I think the [motivations given to use bech32 instead of base58](https://en.bitcoin.it/wiki/BIP_0173#Motivation) are very interesting and we are in the position where we can pick the better option.

-------------------------

bitbruce | 2022-08-05 15:20:20 UTC | #17

Of course, the working group can have its own decision. I just wish ICRC1 was better.

My preference would be for the Account to be a 32-byte hash value with a check digit, which is the format that users are used to.
There are a lot of things that can happen when users copy addresses, and they can easily lose assets. For example, if the address has a "." etc., by double-clicking to select them, some of the characters may be lost.

-------------------------

mariop | 2022-08-05 15:24:24 UTC | #18

[quote="bitbruce, post:17, topic:14682"]
My preference would be for the Account to be a 32-byte hash value with a check digit, which is the format that users are used to.
There are a lot of things that can happen when users copy addresses, and they can easily lose assets. For example, if the address has a “.” etc., by double-clicking to select them, some of the characters may be lost.
[/quote]

This issue can be avoided by encoding Account with base58 or bech32. It's a problem only with plain strings. Would you find using base58 or bech32 a good solution @bitbruce ?

-------------------------

bitbruce | 2022-08-05 15:38:43 UTC | #19

I agree. Encoding can improve the user experience.

As mentioned above, ICP will be compatible with Account-id. In a dapp, for example a wallet, three address formats will appear in the UI for better compatibility: Principal, AccountId (It is being used by CEX), ICRC1Address.

The question is, is this an acceptable outcome?

History is a burden. Don't change it so easily unless you have no choice but to do so.

-------------------------

infu | 2022-08-05 16:16:57 UTC | #20

One of the benefits of base32 from that link is **The mixed case in base58 makes it inconvenient to reliably write down, type on mobile keyboards, or read out loud.**
So it's basically removing the uppercase characters. This will also make addresses look better in UIs

Bech32 consists of (custom text) 1 (data) - where 1 is the separator and the custom text can be anything. For example: "bc"- main net, "tb"- test net, "avax". Cosmos addresses are Bech32 too and each network has a different prefix.

In our case, we have one network, but the wallet is different. Maybe not a good idea to put the location there as I originally thought. 

We could always let users copy a special unrelated to the address pairing code to connect both frontends or just enter the domain without the address. Then one of the sites opens the other in a window or Iframe and uses `postMessage` for secure communication (The same one used in extension wallets). 

We end up needing an open protocol for site-to-site (you can also say wallet-to-wallet) communication. Right now every wallet has a different protocol and they ask you to insert their js library to interface with their end. What we can do next is IC site-to-site frontend protocol so it's standardized and permissionless. 

At some point when users acquire soulbound tokens like certificates, fungible scores, awards, badges, and proof of humanity. Then if site X won't integrate wallet Y directly at signup, there will be a need for communication so that the user can sign/make non-transferring transactions with the soulbound tokens to prove to site X they own them.

Edit: It's actually a very common request right now "I have collected 1000 Plug addresses for my airdrop" I am getting and my dapps will only ever use Internet Identity or my own identity. So I need the user to prove they are the Plug address owner, while linking it securely to their new address. Anyway, that's for another thread

-------------------------

neeboo | 2022-08-05 16:19:06 UTC | #21

https://forum.dfinity.org/t/proposal-of-using-bech32-format-address-an-alternative-and-sounded-way-to-display-account-id/9898?u=neeboo

-------------------------

quinto | 2022-08-05 22:59:29 UTC | #22

[quote="infu, post:12, topic:14682"]
That ship has sailed
[/quote]

Or is it? Apparently you have lost the support of psychedelic, who openly criticized icrc-1 and decided to continue [push its own DIP-20 without subaccount](https://forum.dfinity.org/t/dip20-community-proposal-psychedelicdao/14611).

Now you are about to lose other people who supports subaccount but wanted a uniform & opaque AccountId. Reason is simple: no CEX will bother to support your custom address.

Happy sailing your lonesome ship!

-------------------------

skilesare | 2022-08-05 23:54:43 UTC | #23

[quote="bitbruce, post:13, topic:14682"]
I hope you will do more to understand the habits of crypto users, especially those of the ETH ecosystem.
[/quote]

While this is important, if the ic is to be successful it will come from users that have never seen an address before. 95%(or more) of the world is a blank canvas here.  Our system has more power and it will lol like nothing before when it is successful.

My mom had a phone number when she was a kid that was 5 digits long and you had to talk to the operator if you wanted to call someone out side of your zip code.  The system got better and people who thought they’d never be able to remember 7 number were just fine.

-------------------------

Zane | 2022-08-06 00:06:24 UTC | #24

Agreed but this isn't a step in that direction, currently IC addresses are even more confusing than BTC's, maybe encoding can help, but we're far from something the average user can understand.

-------------------------

skilesare | 2022-08-06 00:44:45 UTC | #25

So let’s fix it. Why not a phone book subnet/canister that does nothing but translate something like @savage_wolf_banana to accounts.  We are already taking about dns right? A couple groups have tried .icp, but this seems like one of those things that is more protocol level. Random addresses could be freeish(maybe they can only be handed to canisters and there is a cycle charge) and if you want a custom one you stake some ICP.

In fact if you really wanted a good SNS test ballon it would be with a very basic utility that does just one thing. If we can govern that then maybe we can govern something more complicated.

-------------------------

Zane | 2022-08-06 00:54:13 UTC | #26

I've thought about it, some chains already do something similar but I assumed it'd be out of scope for icrc1 and some might even complain such a feature isn't something Dfinity should build but it should be up to the community, which is understandable but I'd like to avoid another icns situation.

-------------------------

bitbruce | 2022-08-06 02:19:27 UTC | #27

[quote="bitbruce, post:19, topic:14682, full:true"]
I agree. Encoding can improve the user experience.

As mentioned above, ICP will be compatible with Account-id. In a dapp, for example a wallet, three address formats will appear in the UI for better compatibility: Principal, AccountId (It is being used by CEX), ICRC1Address.

The question is, is this an acceptable outcome?

History is a burden. Don’t change it so easily unless you have no choice but to do so.
[/quote]

If ICRC1 uses a bech32 encoded address, called ICRC1Address. then how much we can gain.
1, Contract developers can write a few lines of code less. (At the cost of the agent sdk having to deal with the new encoding)
2. More transparency and easier traceability. (sometimes a benefit, sometimes a disadvantage)
3, It will bring some sense of achievement?
(hopefully someone will give additions, and I'm in favour of change if the benefits are large enough)

So how much trouble does it bring.
1, the wallet will contain three address formats: Principal, AccountId, ICRC1Address. Users will be more confused. (The wallet developer had to provide them in order to be compatible with previous versions of the asset)
2, CEX access to assets is more difficult and some will be rejected.
3, It will be more troublesome when testing on the command line.
4, To be account-id compatible, ICP's Canister code will introduce complexity, which is a potential risk.
5, Loss of privacy protection. (Sometimes a benefit, sometimes a disadvantage)

Some things can be felt as gains when you start thinking about them, but when you start doing them, you find that a lot of new problems are introduced. Is this the time to rethink?

Going back to the beginning, if ICRC1 used the Account-id directly, compared to ICRC1Address, and reconsidered the benefits and disadvantages, what would then be the answer?

A central question is, what problem is ICRC1 trying to solve?
Does it want to unify the Token standard? (This seems to be an unachievable goal at the moment)
Is it to have minimal common interfaces for assets and to create a commonality between different standards? (This is something that is needed for wallet, SNS, CEX and makes huge sense. These needs only require asset sending functionality, and Account-id doesn't prevent you from achieving this)

So, could you rethink the positioning and reconsider the requirements? What we need is to solve the problem, not introduce complexity.

-------------------------

roman-kashitsyn | 2022-08-06 08:18:45 UTC | #28

One of the most significant advantages of the ICRC-1 addressing scheme is that we can send funds to principals directly without needing any tools (beyond the Candid text parser) to construct the payload.

Let's take advantage of this vital feature.

I propose we make each principal a valid ICRC-1 address. Most applications don't need subaccounts (including Coinbase and all exchanges relying on the Rosetta API), so (unjustified statistics ahead) 98% of users will never need to learn anything beyond principals, which they have to know anyway.

Since we're worried about shortening long addresses, we can move the subaccount part to the front. This way, each address will end with the principal's checksum:

```
// Principal encoding scheme
Encode(data) := Group(LowerCase(Base32(data || CRC32(data))))
```

I suggest we make the following valid ICRC-1 textual account representations:
```
// No subaccount, 98% of users will see this

4kydj-ryaaa-aaaag-qaf7a-cai
jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae

// Short subaccount, some geeks might use them:

0x0a.4kydj-ryaaa-aaaag-qaf7a-cai
0x01.jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae

// Long subaccounts, should be rarely displayed to humans
0xf2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2.4kydj-ryaaa-aaaag-qaf7a-cai
0x5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03.jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae
```

These addresses also look like domain names, complementing one of the original design goals of principal encoding.

Another benefit is that if you copy only a prefix of the address, the resulting string is unlikely to be a valid address.

-------------------------

infu | 2022-08-06 10:55:18 UTC | #29

I will reply to you in their thread - I am dev from the community

-------------------------

infu | 2022-08-06 13:45:14 UTC | #30

More Bech32 Pros:

* When someone sends you their "address" you will know how to request proof of ownership. It's commonly used in this manner. When you ask on Twitter or Discord for users to give you their addresses, they start pasting principals and you don't really know where they are coming from.

nns10yg27sw98nwmxxrz7razcvwt6kxmjezajrlmsaw840yvj. 
anvil1xz7nt4vv3k2fakyfetm6p6qyaymnta742qdyh4fyq799y
plug10yg27sw98nwmxxrz7razcvwt6kxmjezajrlmsaw840yvj
stoic158gkn9x77r4usmdxtlrnhy27aypsk7stkh49rkh7hlz7k

* There are already bulletproof libraries in all languages so we won't need to create our own https://www.npmjs.com/package/bech32

Playground here https://slowli.github.io/bech32-buffer/
Looks like Bech32m supports 90bytes (what we need) and bech32 supports only 32 (won't fit subaccounts)

-------------------------

mariop | 2022-08-07 11:44:27 UTC | #31

[quote="bitbruce, post:27, topic:14682"]
A central question is, what problem is ICRC1 trying to solve?
Does it want to unify the Token standard? (This seems to be an unachievable goal at the moment)
Is it to have minimal common interfaces for assets and to create a commonality between different standards? (This is something that is needed for wallet, SNS, CEX and makes huge sense. These needs only require asset sending functionality, and Account-id doesn’t prevent you from achieving this)
[/quote]

ICRC-1 goal is to establish a common interface for fungible tokens that is decided by the community and the Foundation instead of single entities. This was a direct answer to many complains from our userbase regarding fragmentation and issues with existing standards.
In practical terms, ICRC-1 binds the Foundation to support it as much as it can and gives the community a stable framework for the IC that is future-proof and can be extended.

ICRC-1 goal is not to unify standards. That's not possible but also not something we want to do. If ICRC-1 has to be adopted then it should be because it's a good standard and not because it's the only standard. Conversely additional standards with better ideas for IC may still emerge in future.

About the problems:

[quote="bitbruce, post:27, topic:14682"]
1, the wallet will contain three address formats: Principal, AccountId, ICRC1Address. Users will be more confused. (The wallet developer had to provide them in order to be compatible with previous versions of the asset)
[/quote]

Having multiple address formats is not ideal but I think it's unavoidable. Improvements happen, mistakes can be done and feedback can lead to better ideas. Bitcoin for instance has different formats and new formats were created for excellent reasons.

We have some opportunities here to limit the pain. AccountId and ICRC1Address represent the same info and it wouldn't be hard to migrate from one to the other. AccountId can be deprecated over time. Principal is also part of the ICRC1Address so it should be too hard to explain that ICRC1Address is an "extended" Principal. Also depending on the encoding of ICRC1Address, Principal would be a valid ICRC1Address (see what Roman proposes above). This fact can be a very compelling reason to pick one format instead of another one.

[quote="bitbruce, post:27, topic:14682"]
2, CEX access to assets is more difficult and some will be rejected.
[/quote]

My job as team lead of the Financial Integration team at DFINITY includes talking with CEXs. Most CEX don't really care but I can assure you they would love to have single format for all Ledgers and the only one that exists is ICRC1Address. Both Principal and AccountId don't fit the bill.

I also think CEX would like us to use a good charset similarly to bech32 for the encoding because it's easier to display.

[quote="bitbruce, post:27, topic:14682"]
3, It will be more troublesome when testing on the command line.
[/quote]

I assume you are talking about the ICRC1Account type and not the format discussed here because the latter is just a string.
I've been testing this a lot and ICRC1Account is much easier to use from the command line than AccountId and a little more complicated than working with Principal because instead of writing `principal "aaaa.aa"` would have to write `record { owner: principal "aaaa.aa" }`. Yes it's more chars but definitely usable.

[quote="bitbruce, post:27, topic:14682"]
4, To be account-id compatible, ICP’s Canister code will introduce complexity, which is a potential risk.
[/quote]

I agree that adding more code introduces potential risks. The additional code would be a tiny layer on top of the existing ICP API. AccountId are already created from principal and subaccount which means there is always a function from ICRC1Account to AccountId and it's always safe to call. That's really the only "complex" thing the ICP would have to do.

[quote="bitbruce, post:27, topic:14682"]
5, Loss of privacy protection. (Sometimes a benefit, sometimes a disadvantage)
[/quote]

I agree with this but isn't that invalidated by publishing the blocks of the subnet? At that point, isn't obfuscating principal and subaccount just a disadvantage?

[quote="bitbruce, post:27, topic:14682"]
Some things can be felt as gains when you start thinking about them, but when you start doing them, you find that a lot of new problems are introduced. Is this the time to rethink?

Going back to the beginning, if ICRC1 used the Account-id directly, compared to ICRC1Address, and reconsidered the benefits and disadvantages, what would then be the answer?

So, could you rethink the positioning and reconsider the requirements? What we need is to solve the problem, not introduce complexity.
[/quote]

Ideas should always be challenged. I was hoping the working group could be used for that but it's fine to do it also here in the forum and on discord. Sadly talking on the forum is often disconnected from the working group meaning that we need more synch between the two. We are working to improve this.

Talking about rethinking, AccountId was challenged by the community, not the Foundation.  For DFINITY it made sense to use AccountId and not ICRC1Account because switching to ICRC1Account is a huge amount of work on our side. This challenging didn't happen only in the working group and didn't start there. On the forum, for example, you can find many posts against AccountId, even recent ones claiming that hashing two arrays of bytes is cumbersome.

Rethinking also means listening and it made sense to create ICRC1Account after all the negative feedback AccountId got. Sure it will be a lot of work on the Foundation side to support it but it's for good reasons. Rethinking is what lead us to ICRC1.

A small final note: AccountId won't have the property to obfuscate principals because the subnet blocks will be published as requested by the community. If you drop that then the only advantage AccountId has over ICRC1Account is that it's smaller. That's it. ICRC1Account is superior in every other way and opens to new use cases. To give you an idea, ICRC1Account allows you to find all subaccounts of a principal by scanning the blocks. This allows a canister to keep an eye on potential orphan accounts it owns that were created due to bugs. It would even be possible to create a canister whose job is to publish all the accounts of a principal as a service. There are other examples like this one of how more powerful ICRC1Account is compared to AcccountId and the price for that is to keep a bit more data per block.

-------------------------

infu | 2022-08-07 14:10:01 UTC | #32

[quote="infu, post:20, topic:14682"]
We end up needing an open protocol for site-to-site (you can also say wallet-to-wallet) communication.
[/quote]

Just created a new thread about that. https://forum.dfinity.org/t/frontend-to-frontend-identity-protocol-funnelfi/14738

It's connected to this one in a way.

-------------------------

bitbruce | 2022-08-07 15:15:04 UTC | #33

[quote="mariop, post:31, topic:14682"]
Talking about rethinking, AccountId was challenged by the community, not the Foundation. For DFINITY it made sense to use AccountId and not ICRC1Account because switching to ICRC1Account is a huge amount of work on our side. This challenging didn’t happen only in the working group and didn’t start there. On the forum, for example, you can find many posts against AccountId, even recent ones claiming that hashing two arrays of bytes is cumbersome.

Rethinking also means listening and it made sense to create ICRC1Account after all the negative feedback AccountId got. Sure it will be a lot of work on the Foundation side to support it but it’s for good reasons. Rethinking is what lead us to ICRC1.

A small final note: AccountId won’t have the property to obfuscate principals because the subnet blocks will be published as requested by the community. If you drop that then the only advantage AccountId has over ICRC1Account is that it’s smaller. That’s it. ICRC1Account is superior in every other way and opens to new use cases. To give you an idea, ICRC1Account allows you to find all subaccounts of a principal by scanning the blocks. This allows a canister to keep an eye on potential orphan accounts it owns that were created due to bugs. It would even be possible to create a canister whose job is to publish all the accounts of a principal as a service. There are other examples like this one of how more powerful ICRC1Account is compared to AcccountId and the price for that is to keep a bit more data per block.
[/quote]

Account-id is consistent with engineering theory and with the conventions of the cryptographic community; it is not flawed. Some people think it is flawed because they cannot get the Principal from Account-id, which is precisely the advantage of Account-id, an advantage that is found everywhere in the cryptographic project.

It is short-sighted to think that Account-id is flawed. 
I think it is an act of business architectural laziness. the great thing about Account-id is that no one knows the Principal behind the Account-id when he is not accessing the contract. if one does need the Account-id to associate a Principal, then it is easily available when the Account first accesses the contract. 

The above are my views on Account-id.

------------

Some of the voices of the community are mixed, some are short-sighted, and some do more harm than good.

The community's challenges are based on the needs of their own projects, and each project's domain is different and their needs are different, which requires the working group to take stock. 

I hope the working group has its own goals and principles, following technical principles, architectural principles, engineering principles, and not being swayed by the voices of the community, including not necessarily adopting my suggestions.

-------------------------

levi | 2022-08-07 19:24:20 UTC | #34

[quote="roman-kashitsyn, post:28, topic:14682"]
we make each principal a valid ICRC-1 address.
[/quote]

[quote="roman-kashitsyn, post:28, topic:14682"]
we can move the subaccount part to the front.
[/quote]

[quote="roman-kashitsyn, post:28, topic:14682"]
we make the following valid ICRC-1 textual account representations:

```
// No subaccount, 98% of users will see this

4kydj-ryaaa-aaaag-qaf7a-cai
jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae

// Short subaccount, some geeks might use them:

0x0a.4kydj-ryaaa-aaaag-qaf7a-cai
0x01.jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae

// Long subaccounts, should be rarely displayed to humans
0xf2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2.4kydj-ryaaa-aaaag-qaf7a-cai
0x5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03.jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae
```
[/quote]

This is clean and clear. 
I love how the principal-text itself is part of the valid ICRC-1 id. Users of the IC must learn about principals somehow and this is a great way to do it. 
The subaccount must start with a `0x` and end with a `.` so that makes sure the user copies the subaccount correct. 
A dapp/rosetta-api can validate the principal is copied correct by the crc32-checksum built into the [principal-textual-representation](https://internetcomputer.org/docs/current/references/ic-interface-spec/#textual-ids).
This gives a simple way for users to construct their own subaccounts-ids on the fly without a computer. like at a coffee shop.

When a dapp wants a user to send some tokens to the user's-subaccount of the dapp - a common senario -, the one possible thing that can go wrong with the above encoding is that a user can only copy the principal and forget/leave-out the subaccount. Let's make this 100% and cover that hole, lets make the subaccount a must, so for a main-account (default-subaccount), the account-id will start with `0x.` for a sample: `0x.4kydj-ryaaa-aaaag-qaf7a-cai` . This way we can be 100% certain that the beginning and end of the account-id are copied correct. The users can comprehend the concept of a subaccount, show them @roman-kashitsyn 's [blog-post](https://mmapped.blog/posts/09-fungible-tokens-101.html#subaccounts). 
```
// valid ICRC-1 textual account representations.

// Main-account (default subaccount)
0x.4kydj-ryaaa-aaaag-qaf7a-cai
0x.jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae

// Main-account (default subaccount)
0x00.4kydj-ryaaa-aaaag-qaf7a-cai
0x00.jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae

// Short subaccounts
0x0a.4kydj-ryaaa-aaaag-qaf7a-cai
0x01.jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae

// Long subaccounts
0xf2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2.4kydj-ryaaa-aaaag-qaf7a-cai
0x5891b5b522d5df086d0ff0b110fbd9d21bb4fc7163af34d08286a2e846f6be03.jlcmz-cojlk-zdm46-mshzl-dtlre-ricph-khpzu-tqxrk-qo3ow-7jdsw-tae

```

-------------------------

roman-kashitsyn | 2022-08-07 20:15:00 UTC | #35

[quote="roman-kashitsyn, post:28, topic:14682"]
```
// Principal encoding scheme
Encode(data) := Group(LowerCase(Base32(data || CRC32(data))))
```
[/quote]

Sorry, I took this scheme from an outdated specification for principal encoding. As @levi correctly pointed out, the actual encoding starts with the checksum:
```
Encode(b) = Grouped(Base32(CRC32(b) · b))
```

So it makes more sense to put the subaccount on the right, as in Mario's original proposal. Such placement will maximize the information density in the prefix and the suffix of the account identifier.


I'm unsure whether we should require the subaccount prefix/suffix as  or leave it out by default.

-------------------------

Zane | 2022-08-07 20:21:09 UTC | #36

[quote="bitbruce, post:33, topic:14682"]
Some of the voices of the community are mixed, some are short-sighted, and some do more harm than good
[/quote]

I don't want to come off the wrong way, but even assuming your opinion is the right one (not saying it isn't, just trying to make a point), don't you believe its unfair to complain about the WGs choice after it has already been agreed upon for more than month? Why hasn't this discussion happened during the WG?

-------------------------

timo | 2022-08-07 21:00:03 UTC | #37

Can someone summarize what these abbreviated ids (first and last N characters) are being used for?

For example, is it the wallet owners own accounts? Or is it accounts that the wallet owner has transacted with in the past? Or is it where a wallet owner is going to send money to?

I just want to make sure that we check if there is any unsafe usage going on where an attacker can somehow benefit from a collision in the displayed characters. We need to know what we’re designing for and have to make sure we don’t promote anything unsafe.

-------------------------

levi | 2022-08-07 21:27:53 UTC | #38

If the subaccount is on the right, then it is easier for a user to leave out some of the last characters of the subaccount. 
If the subaccount is on the left, then it must start with a `0x` so when a user copies the id we can be sure the subaccount-beginning is correct, and it is impossible to leave out the last characters of the subaccount when copying the id in one shot, because there must be a `.` in the id.

-------------------------

levi | 2022-08-16 18:02:25 UTC | #39

Hey People! @roman-kashitsyn mentions that we can make the textual-format of the icrc1-account as a principal(owner+subaccount) . This format is with the following benefits: 
 - It is with a checksum of the owner-principal and subaccount together - checksum(owner-principal+subaccount) - which makes it 100% copy-safe/error-resistant so that a user cannot send funds to an incorrectly copied account-id.
 - The main(default) account of an account-owner is the account-owner's-principal. A user's-principal is the account-id of the user's-main-account.

Do the people want the textual format of the icrc1-account-id that is 100% copy-safe, can hold subaccounts, and keeps the user's-principal as the id of the user's-main-account? 

Looks like a win-win-win.

-------------------------

lastmjs | 2022-08-18 13:02:45 UTC | #40

Oh wow, this looks very very promising. Let's explore it

-------------------------

timo | 2022-08-18 13:49:47 UTC | #41

Isn't that going to be highly confusing to users? Now they have two entirely different things that look like principals: an actual principal and an encoded account.

-------------------------

lastmjs | 2022-08-18 14:59:56 UTC | #42

Won't they all be essentially the same thing to the user relative to the application they're using (assuming a token wallet for example)? All principals will be encoded accounts that can be verified with the public key.

-------------------------

infu | 2022-08-18 17:06:32 UTC | #43

You will only need to display the Account in this format and nothing else needs to be visible to end-users.

-------------------------

b3hr4d | 2023-06-04 12:10:49 UTC | #44

Hello @levi ,

While exploring this concept, I was unable to locate a Rust implementation for the proposed account format (although one may already exist). Motivated by this, I endeavored to write my own. My primary focus was on a function that can decode account strings into an `Account` object. The function checks if the account string starts with "0x", and treats a subaccount comprised solely of zeroes (or simply "0x") as if no subaccount was provided.

Here is the function:

```rust
impl TryFrom<&str> for Account {
    type Error = AccountError;

    fn try_from(account: &str) -> Result<Self, Self::Error> {
        // Check if "0x" prefix exists and remove it
        let account = if account.starts_with("0x") {
            &account[2..]
        } else {
            return Err(AccountError::InvalidFormat);
        };

        let parts: Vec<&str> = account.split('.').collect();
        if parts.len() != 2 {
            return Err(AccountError::InvalidFormat);
        }

        // Check for "00.." and "" as None
        let subaccount = match parts[0] {
            s if s.chars().all(|c| c == '0') => None,
            s => {
                let mut bytes = hex::decode(s).map_err(|_| AccountError::InvalidSubaccount)?;
                bytes.resize(32, 0);

                Some(Subaccount(bytes))
            }
        };

        let owner = Principal::from_text(parts[1]).map_err(|e| AccountError::InvalidPrincipal(e))?;

        Ok(Self { owner, subaccount })
    }
}
```

**Example usage:**

```rust
// For a main-account (default subaccount)
let account_str1 = "0x.4kydj-ryaaa-aaaag-qaf7a-cai";
let account1 = Account::try_from(account_str1).unwrap();
println!("{:?}", account1); // Prints: Account { owner: PrincipalId { .. }, subaccount: None }

// For a main-account (default subaccount) with "00"
let account_str2 = "0x00.4kydj-ryaaa-aaaag-qaf7a-cai";
let account2 = Account::try_from(account_str2).unwrap();
println!("{:?}", account2); // Prints: Account { owner: PrincipalId { .. }, subaccount: None }

// For a short subaccount
let account_str3 = "0x0a.4kydj-ryaaa-aaaag-qaf7a-cai";
let account3 = Account::try_from(account_str3).unwrap();
println!("{:?}", account3); // Prints: Account { owner: PrincipalId { .. }, subaccount: Some([10]) }

// For a long subaccount
let account_str4 = "0xf2ca1bb6c7e907d06dafe4687e579fce76b37e4e93b7605022da52e6ccc26fd2.4kydj-ryaaa-aaaag-qaf7a-cai";
let account4 = Account::try_from(account_str4).unwrap();
println!("{:?}", account4); // Prints: Account { owner: PrincipalId { .. }, subaccount: Some([...]) }
```

The purpose of this function is to parse the account string into a structured format while simultaneously validating the account's integrity.

I've attempted to adhere closely to the proposed format and provide appropriate validation, but I would be grateful for any feedback or suggestions. Do you see any potential pitfalls or improvements in my implementation?

Any insights would be greatly appreciated!

---

-------------------------

levi | 2023-06-04 16:22:55 UTC | #45

Hi @b3hr4d, 
Since this conversation, the textual encoding for the ICRC-1 Account has changed. You can find the current spec here: https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/TextualEncoding.md. If you write an implementation for the current spec, I will check it and give feedback.

-------------------------

b3hr4d | 2023-06-04 18:56:46 UTC | #46

Nice, the spec is clear enough.

The updated `Display` implementation for `Account` is as follows:
```rust
impl fmt::Display for Account {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match &self.subaccount {
            None => write!(f, "{}", self.owner),
            Some(subaccount) => {
                if subaccount.is_default() {
                    write!(f, "{}", self.owner)
                } else {
                    let checksum = self.compute_base32_checksum();
                    let hex_str = hex::encode(&subaccount.as_slice())
                        .trim_start_matches('0')
                        .to_owned();
                    write!(f, "{}-{}.{}", self.owner, checksum, hex_str)
                }
            }
        }
    }
}
```
and test result

```rust
let account_1 = Account {
    owner: Principal::from_text(
        "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
    )
    .unwrap(),
    subaccount: None,
};
assert_eq!(
    account_1.to_string(),
    "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae"
);

let account_2 = Account {
    owner: Principal::from_text(
        "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
    )
    .unwrap(),
    subaccount: Some(Subaccount::from_slice(&[0u8; 32]).unwrap()),
};
assert_eq!(
    account_2.to_string(),
    "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae"
);

let account_3 = Account {
    owner: Principal::from_text(
        "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
    )
    .unwrap(),
    subaccount: Some(Subaccount::from_slice(&[1u8; 32]).unwrap()),
};
assert_eq!(
    account_3.to_string(),
    "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae-7s4rpcq.101010101010101010101010101010101010101010101010101010101010101"
);
```
I believe the results are correct as per the updated specification, but I would be grateful for any validation or feedback on this.

-------------------------

levi | 2023-06-06 07:40:24 UTC | #47

The results are correct for the ```impl fmt::Display for Account```, good work.

What about an ```impl TryFrom<&str> for Account``` with the current spec?

-------------------------

b3hr4d | 2023-06-06 10:44:59 UTC | #48

I want to make a library for the subaccount&account later.

```rust
impl FromStr for ICRCAccount {
    type Err = ICRCAccountError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let n = s.len();

        if n == 0 {
            return Err(ICRCAccountError::Malformed("empty".into()));
        }

        let last_dash = s.rfind('-');
        let dot = s.find('.');

        match last_dash {
            None => {
                return Err(ICRCAccountError::Malformed(
                    "expected at least one dash ('-') character".into(),
                ));
            }
            Some(last_dash) => {
                if let Some(dot) = dot {
                    // There is a subaccount
                    let num_subaccount_digits = n - dot - 1;

                    if num_subaccount_digits > 64 {
                        return Err(ICRCAccountError::Malformed(
                            "the subaccount is too long (expected at most 64 characters)".into(),
                        ));
                    };

                    if dot < last_dash {
                        return Err(ICRCAccountError::Malformed(
                            "the subaccount separator does not follow the checksum separator"
                                .into(),
                        ));
                    };

                    if dot - last_dash - 1 != 7 {
                        return Err(ICRCAccountError::BadChecksum);
                    };

                    // The encoding ends with a dot, the subaccount is empty.
                    if dot == n - 1 {
                        return Err(ICRCAccountError::NotCanonical);
                    };

                    // The first digit after the dot must not be a zero.
                    if s.chars().nth(dot + 1).unwrap() == '0' {
                        return Err(ICRCAccountError::NotCanonical);
                    };

                    let principal_text = &s[..last_dash];
                    let owner = Principal::from_text(principal_text)
                        .map_err(|e| ICRCAccountError::InvalidPrincipal(e.to_string()))?;

                    let hex_str = &s[dot + 1..];

                    // Check that the subaccount is not the default.
                    if hex_str.chars().all(|c| c == '0') {
                        return Err(ICRCAccountError::NotCanonical);
                    };

                    let subaccount = Subaccount::from_hex(&hex_str)
                        .map_err(|e| ICRCAccountError::InvalidSubaccount(e.to_string()))?;

                    // Check that the checksum matches the subaccount.
                    let checksum = &s[last_dash + 1..dot];
                    let expected_checksum = base32_encode(
                        &ICRCAccount {
                            owner,
                            subaccount: Some(subaccount.clone()),
                        }
                        .compute_checksum(),
                    );

                    if checksum != expected_checksum {
                        return Err(ICRCAccountError::BadChecksum);
                    };

                    Ok(ICRCAccount {
                        owner,
                        subaccount: Some(subaccount),
                    })
                } else {
                    // There is no subaccount, so it's just a Principal
                    let owner = Principal::from_text(s)
                        .map_err(|e| ICRCAccountError::InvalidPrincipal(e.to_string()))?;
                    Ok(ICRCAccount {
                        owner,
                        subaccount: None,
                    })
                }
            }
        }
    }
}
```
and test result 
```rust
let account_1 = ICRCAccount::from_text(
    "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
)
.unwrap();

let expected_1 = ICRCAccount {
    owner: Principal::from_text(
        "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
    )
    .unwrap(),
    subaccount: None,
};

assert_eq!(account_1, expected_1,);

let account_2 = "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae"
    .parse::<ICRCAccount>()
    .unwrap();

let expected_2 = ICRCAccount {
    owner: Principal::from_text(
        "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
    )
    .unwrap(),
    subaccount: Some(Subaccount([0u8; 32])),
};

assert_eq!(account_2, expected_2);

let account_3 = ICRCAccount::from_text(
    "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae-7s4rpcq.101010101010101010101010101010101010101010101010101010101010101"
).unwrap();

let expected_3 = ICRCAccount {
    owner: Principal::from_text(
        "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
    )
    .unwrap(),
    subaccount: Some(Subaccount([1u8; 32])),
};

assert_eq!(account_3, expected_3);

let mut slices = [0u8; 32];
slices[31] = 0x01;

let account_4 = ICRCAccount {
    owner: Principal::from_text(
        "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
    )
    .unwrap(),
    subaccount: Some(Subaccount(slices)),
};

assert_eq!(
    account_4,
    "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae-6cc627i.1"
        .parse::<ICRCAccount>()
        .unwrap()
);

let slices = [
    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c,
    0x1d, 0x1e, 0x1f, 0x20,
];

let account_5 = ICRCAccount {
    owner: Principal::from_text(
        "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae",
    )
    .unwrap(),
    subaccount: Some(Subaccount(slices)),
};

assert_eq!(
    account_5,
    "k2t6j-2nvnp-4zjm3-25dtz-6xhaa-c7boj-5gayf-oj3xs-i43lp-teztq-6ae-dfxgiyy.102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20"
        .parse::<ICRCAccount>()
        .unwrap()
);
`

-------------------------

benji | 2023-06-08 08:28:23 UTC | #49

Great work!

I think it would make sense to merge your contributions into icrc-ledger-types https://github.com/dfinity/ic/tree/master/packages/icrc-ledger-types

-------------------------

b3hr4d | 2023-06-08 08:57:37 UTC | #50

Yes, that would be perfect!
I'll do a pull request later then, also I have a small code for the subaccount:

```rust
impl Subaccount {
    pub fn new(nonce: u64) -> Self {
        let mut subaccount = [0; 32];
        // Convert the nonce into bytes in big-endian order
        let nonce_bytes = nonce.to_be_bytes();
        // Copy the nonce bytes into the subaccount array starting from the 25th byte
        // as the nonce in big-endian order with doing this we get the smallest ICRCAccount ids
        subaccount[24..].copy_from_slice(&nonce_bytes);

        Subaccount(subaccount)
    }

    pub fn nonce(&self) -> u64 {
        if self.0[0] == 29 {
            return 0;
        }

        let nonce_bytes = &self.0[24..];
        u64::from_be_bytes(nonce_bytes.try_into().unwrap())
    }

    pub fn is_default(&self) -> bool {
        self.0 == [0u8; 32]
    }

    pub fn as_slice(&self) -> &[u8] {
        &self.0
    }

    pub fn from_slice(slice: &[u8]) -> Result<Self, SubaccountError> {
        if slice.len() != 32 {
            return Err(SubaccountError::SliceError(
                "Slice must be 32 bytes long".to_string(),
            ));
        }

        let mut subaccount = [0; 32];
        subaccount.copy_from_slice(slice);

        Ok(Subaccount(subaccount))
    }

    pub fn to_vec(&self) -> Vec<u8> {
        self.0.to_vec()
    }

    pub fn to_hex(&self) -> String {
        hex::encode(&self.0)
    }

    pub fn from_hex(hex: &str) -> Result<Self, SubaccountError> {
        // add leading zeros if necessary
        let hex = if hex.len() < 64 {
            let mut hex = hex.to_string();
            hex.insert_str(0, &"0".repeat(64 - hex.len()));
            hex
        } else {
            hex.to_string()
        };

        let bytes = hex::decode(hex).map_err(|e| SubaccountError::HexError(e.to_string()))?;

        Subaccount::from_slice(&bytes)
    }

    pub fn from_base32(base32: &str) -> Result<Self, SubaccountError> {
        let bytes =
            base32_decode(base32).map_err(|e| SubaccountError::Base32Error(e.to_string()))?;
        Subaccount::from_slice(&bytes)
    }
}

impl Subaccount {
    pub fn account_identifier(&self, owner: CanisterId) -> AccountIdentifier {
        AccountIdentifier::new(owner, self.clone())
    }

    pub fn icrc_account(&self, owner: CanisterId) -> ICRCAccount {
        ICRCAccount::new(owner, Some(self.clone()))
    }
}
```
and some other "From" impl, should I add them or not?

-------------------------

skilesare | 2023-06-08 18:08:02 UTC | #51

Is the motoko version there up to date?

-------------------------

peterparker | 2023-06-08 18:32:10 UTC | #52

My Motoko is rusty (😉) but, at first sight the reference in the ICRC-1 repo seems to be up-to-date, agree?

https://github.com/dfinity/ICRC-1/blob/main/ref/Account.mo

-------------------------

b3hr4d | 2023-06-09 19:03:21 UTC | #53

Yes that is super smart, I did write the rust implementation based on your Motoko code, thank you :+1:

-------------------------

benji | 2023-06-13 09:23:20 UTC | #54

Please make 2 separate PRs as these are 2 different features.

-------------------------

NS01 | 2023-06-13 22:57:38 UTC | #55

I really like the idea of a single transaction address which merges principal and sub account. 

I got caught out thinking that ICRC sub accounts were unique (derived from the principal) like ICP accounts. Given both are 32 (64 hex) in length I think others might make this assumption. 

I'm glad there is discussion on this topic. I wasnt a fan of confusion caused by some projects using principals and some using accounts. 

What ever format is used to combine the principal + subaccount should be reversable... so that devs can extract both if needed.

-------------------------

b3hr4d | 2023-06-20 11:22:08 UTC | #56

[Implement Human Readable Account Format and Subaccount Driving Feature by b3hr4d · Pull Request #108 · dfinity/ic (github.com)](https://github.com/dfinity/ic/pull/108)

-------------------------

Zedonboy | 2024-08-10 12:27:24 UTC | #57

Exactly!!!. This Account urn is not it.

-------------------------

Zedonboy | 2024-08-10 12:36:46 UTC | #58

@bitbruce @mariop 

The issue is, this format is not really needed from business perspective.

My dapp generated a wallet(Canister Principal + SubAccount Identifier)
h5boe-vqaaa-aaaam-ac36q-cai-ckw43vy.6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce 

How do i direct my users to send token to this?

The Internet Computer Dashboard doesn't support this to be used to view balance 
The NNS doesn't support this to be used to do transfers and view balance 
Exchanges doesn't support 

The Original ICP AccountIdentifier is better, because my Dapp can simply instruct users to send token to the Account ID, they and easily view their balance. 

We should revert ICRC-1 account to accountidentifier Or ICRC ledgers should support account id.

My 2 cents

-------------------------

Zedonboy | 2024-08-10 13:09:31 UTC | #59

ICRC-1 should Use Account-ID

@bitbruce complained about this.

How can ICRC be different from the Base ICP token?

ethereum Address can be used for all ERC-20 transactions.

But ICP Account-ID can't be used for all ICRC-1 transactions.

-------------------------

bogwar | 2024-08-12 10:29:51 UTC | #60

The difference between the account formats is due to a fundamental choice regarding the privacy of the principal that controls an account.  For the ICP ledger the link between accounts & the principal that controls them is hidden: given an ICP ledger account identifier one cannot (in general) determine the principal that controls them and the corresponding subaccount because this would require reverting the hash function.  

For the ICRC ledger the choice made within the working group in charge of the design was to explicitly spell out the link.

Unifying the two is not really possible. The ICP ledger does have an ICRC transfer interface (but such transfers are recorded in the ICP ledgers as transfers between account identifiers where the principal & subaccount are hashed and not as ICRC-3 transactions). Furthermore, one cannot easily add a (legacy) ICP transfer interface to ICRC ledgers: when a legacy transfer is made, one should determine the principals & subaccounts involved which is not impossible, but highly non-trivial on ICRC ledgers.

-------------------------

Zedonboy | 2024-08-12 11:47:55 UTC | #61

The features you took out is what makes it interesting and valuable.

I am application developer, we are the ones that do the explanation and marketing to non-technical users.

I think the ICRC-1 account change is not solving a problem as @bitbruce pointed out.

2. Determination of Principal and Subaccount, was never a problem, its the job of Smart Contract Developer to figure it out.

The best people to have a voice in this ICRC spec, Is Application Developers for Wallet apps, Defi Apps.

Look at what  @quinto and @bitbruce said.

In Other chains e.g Ethereum.

1 address is used for all ERC-20 transactions.

In ICP 1 Account Identifier should be used in all ICRC Transactions, the End User don't care about the Principal/Subaccount Determination(imaginary problems)

Its halting development, Users are confused the ICRC-1 format cannot be used on any wallet, NNS or IC explorer, they can't even use it to view their balance publicly.

The best approach is to accept Account Identifier.

-------------------------

bogwar | 2024-08-12 12:41:07 UTC | #62

If you don't need to use subaccounts (which is a feature that leads to simpler and robust payment protocols e.g. you can segregate distinct usecase/purpose using these subaccounts), you can unify ICP & ICRC ledger transfers by using the principal and therefore the default subaccount everywhere. The ICP ledger does support the ICRC-1 standard which allows using the principal as an address. In this case you have to track the transfers using the corresponding default identifier.

-------------------------

timo | 2024-08-12 13:00:12 UTC | #63

[quote="Zedonboy, post:58, topic:14682"]
My dapp generated a wallet(Canister Principal + SubAccount Identifier)
h5boe-vqaaa-aaaam-ac36q-cai-ckw43vy.6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce

How do i direct my users to send token to this?

The Internet Computer Dashboard doesn’t support this to be used to view balance
The NNS doesn’t support this to be used to do transfers and view balance
Exchanges doesn’t support
[/quote]


Happy to help you with this. Can you provide some more information? I suppose you are doing something with the ICP token or is it for some other ICRC-1 token?

I am surprised to see that the dashboard indeed does not support searching for ICRC-1 account identifiers such as the one you provided: h5boe-vqaaa-aaaam-ac36q-cai-ckw43vy.6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce.
That is a shortcoming of the dashboard. However, ICP is the exception here. For all other tokens the dashboard supports searching for ICRC-1 account identifiers. So this is something that needs to be fixed in the dashboard.

I suppose the same is true for the NNS wallet. ICP is probably an exception when compared to all other ICRC-1 tokens. And this should be fixed as well.

[quote="Zedonboy, post:58, topic:14682"]
How do i direct my users to send token to this?
[/quote]

If this is indeed specifically about ICP tokens then you can convert the ICRC-1 account identifier to the legacy identifier (aka "original account id"). In your case h5boe-vqaaa-aaaam-ac36q-cai-ckw43vy.6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce converts to 4d986d218bf8eb0473e002caf8b6de660e2ce580834190c71bfc6d7f5e82b78d. Your frontend can convert it for the user.

But some wallets actually support the ICRC-1 account identifier even for ICP transfers. If the NNS wallet does not then it is a shortcoming and should be fixed. The wallet we developed [here](https://forum.dfinity.org/t/announcement-a-full-featured-open-source-icrc-1-wallet/23199/19) does support sending any token to ICRC-1 account identifiers including ICP.

-------------------------

timo | 2024-08-12 13:04:45 UTC | #64

[quote="bogwar, post:62, topic:14682"]
If you don’t need to use subaccounts
[/quote]

I suppose he does need subaccounts because his example ICRC-1 account of `h5boe-vqaaa-aaaam-ac36q-cai-ckw43vy.6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce` already included one.

[quote="bogwar, post:62, topic:14682"]
you can unify ICP & ICRC ledger transfers by using the principal
[/quote]

No, this will not help him. The dashboard for example does not support searching for ICP transactions based on principal either (even with default subaccount). It only supports searching for legacy account ids (for the ICP token, that is).

-------------------------

Zedonboy | 2024-08-12 15:12:33 UTC | #65

[quote="timo, post:63, topic:14682"]
Happy to help you with this. Can you provide some more information? I suppose you are doing something with the ICP token or is it for some other ICRC-1 token?
[/quote]

I am working on a app that leverages Chain Fusion. Where a user can use one Account Identifier to pay and receive in various token(ICP,SNS,ICRC)

In Ethereum, 1 generated address can be used for all ERC-20 transactions.

We are talking of UX here and easy of use.

Exchanges don't use Human format
NNS don't support it
IC explorer don't support it.

The group have created a Solution that has no Problem, they have single headed kicked themselves out from actual usage and adoption.

No exchange will support human format narrative.

Exchanges will not be like "Oh mate this is ICRC token transaction, ask the user for human format and if this is ICP itself ask for account identifier"

From Exchange perspective, they assume all ICP and its Derivatives should accept one Account Identifier.

The idea is Account Identifier should be used accross all ICRC tokens

The human format should be used for aesthetics only, the implementing wallet/app can convert to account identifier and query the token(icrc) directly.

From "dumb" user perspective they cannot differenciate ICP and Its Derivative Token(ICRC).

If this is impossible, then i think I and the community in support should create legacy ICRC  specifications ledger that uses account identifier(not human format) only like ICP.

-------------------------

neeboo | 2024-08-12 17:22:12 UTC | #66

I think we can build a resolving protocol to allow people custom his/her subaccounts. 

For example

`icrc://{human_readable_name}:{subaccount_identifier}@{canister_id}`

- `human_readable_name` is resolved as `Blob<29>` Principal Id, user can set it to his/her nickname string, for example **alice**
- `subaccount_identifier` is resolved to `Bytes32` as Subaccounts, people can set it to **default** or **hot_wallet** as `String`.
-  `canister_id` is the resolver canister with standard resolving and register function.
- `icrc` is the token standard.

then we might have:
`icrc://alice:coin_base@aaaa-aa`

-------------------------

timo | 2024-08-12 21:02:26 UTC | #67

I can provide a little bit of background here.

What I call "legacy account id" is the type of account identifier that has been used by the ICP ledger since the beginning. It looks like this `4d986d218bf8eb0473e002caf8b6de660e2ce580834190c71bfc6d7f5e82b78d`. It is the hash of the principal who controls it plus a subaccount identifier. The differences to an Ethereum address are:

- Ethereum addresses come from public keys without any subaccounts, so Ethereum addresses are more like principals than they are like legacy account ids
- Ethereum addresses are 20 bytes while legacy account ids are 32 bytes

A risk with these account identifiers is that you may lose access to your funds if you forget the subaccount that you used to create it. This is not a problem for short subaccount ids like 1,2,3,... but is for long subaccount ids. For example the account id `4d986d218bf8eb0473e002caf8b6de660e2ce580834190c71bfc6d7f5e82b78d` was created from principal `h5boe-vqaaa-aaaam-ac36q-cai` and subaccount id `6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce`. If you somehow forget the value `6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce`, even if you still have control of the principal `h5boe-vqaaa-aaaam-ac36q-cai` then you can't acces the funds on `4d986d218bf8eb0473e002caf8b6de660e2ce580834190c71bfc6d7f5e82b78d` anymore.

If Ethereum had subaccounts then I doubt they would hash the Ethereum address and the subaccount id together to produce something that looks again like an Ethereum address. They would probably just created an "extended Ethereum address" which is an Ethereum address plus a subaccount id.

What I call "ICRC-1 account identifier" is the one that looks like this `h5boe-vqaaa-aaaam-ac36q-cai-ckw43vy.6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce`. It contains a principal and a subaccount id. I think calling it "human readable" is a little bit misleading. It is true that we can identify the two components principal and subaccount, but no other information can be read from it. Like the hypothetical "extended Etherum address" I would call it an "extended principal". The analogy is really principal <-> Ethereum address and not legacy account id <-> Ethereum address.
 
All tokens on the IC are ICRC-1 tokens and support sending to ICRC-1 accounts, including the ICP token. The ICP token supports both, legacy account ids and ICRC-1 accounts. The same ICRC-1 account id can be used across all tokens on the IC. With one ICRC-1 account id the user can handle all tokens. That is a property that you wanted.

The ICRC-1 account id for the default account is equal to the principal. So principals can be used directly to hold all tokens on the IC. So here is the analogy with Ethereum that you wanted: Ethereum address = principal = single identifier which can be used across all tokens on the IC.

The fact that a principal looks different than an Ethereum address (`h5boe-vqaaa-aaaam-ac36q-cai` vs 20 bytes hex) should not have any impact on anything. Exchanges supoprt all kinds of tokens and certainly not all those tokens' account identifiers have the same format as an Ethereum key.

Exchanges don't care about what an "address" means. They care that there is a Rosetta node for the token. Currently, no token on the IC other than ICP is supported by centralized exchanges, or is it? But that doesn't have to be the fault of how the account identifiers look. The IC tokens other than ICP simply weren't interesting enough for the exchanges add. If a token had enough demand and provided a Rosetta node then they would probably support it regardless of how the account identifier looks.

The easiest path forward is probably to fix the holes that you have identified. If dashboard and NNS wallet don't support ICRC-1 account identifiers for ICP then that should be fixed.

It is unfortunate that ICP launched with a different identifier initially so now we have two kinds of identifiers for the ICP token. It is a source of confusion for sure.

-------------------------

quinto | 2024-08-14 10:23:36 UTC | #68

> A risk with these account identifiers is that you may lose access to your funds if you forget the subaccount that you used to create it.

This risk sounds very much superfluous. It is the same as using HD wallet to derive a publickey/address and later forgot the derivation path, which didn't seem to prevent HD wallet from getting adopted widely.

In fact, I would argue that a public account identifier in the form of "principal.subaccount" is a risk of exposing canister-held assets to the public and inviting attackers. Suppose there is a canister managing token assets, with "principal.subaccount" anyone is able to lookup and sum up all assets held by this canister, and it becomes public knowledge. But with a public identifier computed from "hash(principal, subaccount)" it is a lot more difficult to know if a canister holds high-value assets. I would not view this kind of protection the same as security-by-obscurity because one-way hash function is a sound cryptographic concept.

It was short-sighted to re-engineer the account id format when designing ICRC-1, and I don't recall any application developer asked for it (some did go ahead with principal id only, but it was too rigid to be considered a viable solution). It was a result of some committee postulating a superfluous risk.

-------------------------

Zedonboy | 2024-08-14 13:12:22 UTC | #69

I think i, @quinto and @bitbruce and other wallet developers, we should create another Token Specification.

DRC-20 (Dfinity Request Comment).

A token that mirrors ICP ledger itself. no added sugars, or comfort, no solutions for imaginary problems.

I think this ICRC group will not understand your point of view, because their application is not a User-facing Project, they are a Developer-Facing Projects

We that know, because we are the ones to market our apps to the end user. its up to us to create a standard.

We are on our own, as @infu  Said "The Ship has sailed"

-------------------------

skilesare | 2024-08-14 14:15:31 UTC | #70

[quote="Zedonboy, post:65, topic:14682"]
The group have created a Solution that has no Problem, they have single headed kicked themselves out from actual usage and adoption.
[/quote]

There is a huge problem on the canister development side. The subaccount is necessary for canisters to hold user assets in separate accounts for security and transparency reasons. Without the subaccount all assets were having to be held together which complicates contract development and opens it to an entire set of bugs where all assets can be drained much more easily.

There is an initiative to work on derived canister IDs that @frederikrothenberger has been looking into. If we had these then subaccounts would be much less necessary.

-------------------------

skilesare | 2024-08-14 14:17:29 UTC | #71

[quote="timo, post:67, topic:14682"]
Currently, no token on the IC other than ICP is supported by centralized exchanges, or is it?
[/quote]

A number of tokens including OGY are on centralized exchanges using the ICRC version of the rosetta node. Unfortunately, it still doesn't support ICRC3 ledgers so things like the cycle ledger or non-SNS ICRC tokens won't work with it. We would need to ask @mariop where that is slotted in order of importance.

-------------------------

Zedonboy | 2024-08-14 14:24:34 UTC | #72

Everything is Ok and perfect.

We just want Legacy id as Account Identifier.

We dont want to see Principal and Subaccount. We are ok with Hash of Principal + Subaccount

-------------------------

timo | 2024-08-14 20:10:26 UTC | #73

[quote="quinto, post:68, topic:14682"]
It was short-sighted to re-engineer the account id format when designing ICRC-1, and I don’t recall any application developer asked for it (some did go ahead with principal id only, but it was too rigid to be considered a viable solution). It was a result of some committee postulating a superfluous risk.
[/quote]

The risk about losing funds that I mentioned was to my knowledge not one of the reasons that the ICRC-1 initiative was started. The thing users and developers complained about was that it was confusing to have two different things as addresses, account ids and principals. And people liked to have only one. So the task was to design a standard that embeds principals into it, so that it is always possible to use a principal as a destination address. But that also allows the use of subaccount because they are needed. And that is what was done, ICRC-1 has principals as addresses and "extended principals" which are principals plus subaccount. To my knowledge, and we can figure this out by looking at the working group minutes, the reason ICRC-1 started was user demand and people were not happy with account ids. 

[quote="quinto, post:68, topic:14682"]
This risk sounds very much superfluous. It is the same as using HD wallet to derive a publickey/address and later forgot the derivation path, which didn’t seem to prevent HD wallet from getting adopted widely.
[/quote]

HD wallets like Ledger Live etc. operate in the following way. They let you use one specific path only, up to the last index. Meaning there is one path which is fixed except for the last index and only the last index can change. Then they first let you open your first subaccount only, meaning that last index has to be 0. Only after the wallet detects that you have received funds in that first account with index 0 does it let you open the subaccount 1. It does not even show you the public key or address of the index 1 account before you have received funds in index 0. That way the wallet can make sure it can always detect by looking at the on-chain history how many indices have been used. So the HD wallets are very much aware of the risk and take counter-measures. Hence, they could get adopted widely. The counter-measures are:

- make the subaccounts enumerable
- make sure there are no gaps in the enumeration

In our case we have an unenumerable subaccount space of 32 arbitrary bytes.

The risk is real, not superfluous, both for end users as well as for canisters.

The "privacy" aspect is a red herring. Using "hash(principal, subaccount)" hides the principal and subaccount for some time until the first time when you access those funds. The first time you transfer out of that account you have to reveal principal and subaccount. At least to everyone reading the network and to all node providers and boundary nodes. Privacy based on that should not be relied on.

[quote="Zedonboy, post:69, topic:14682"]
I think i, @quinto and @bitbruce and other wallet developers, we should create another Token Specification.
[/quote]

I would suggest instead that we work on fixing the problems you have identified. They seem to be a small list of fixable problems. You said some pieces of software don't support ICRC-1 account identifiers:

- the NNS wallet for the ICP token 
- the dashboard for the ICP token

The ICP ledger by the way fully supports the ICRC-1 standard. The ICP ledger also has an index canister compatible with the index canisters for all other ICRC-1 tokens. @skilesare said that some CEX already support ICRC-1 tokens and that there is an ICRC-1 Rosetta node. So exchange shouldn't be a problem. With ICRC-1 interface, index canister and Rosetta node I really don't see anything missing except that some app software pieces need to be updated. This is a much shorter path forward than coming up with a new standard. 

Is there anything else I am missing? I am happy to go through this list and fix pain points one by one. Could you elaborate for me one more time why exactly you want the legacy account ids back? I see you write

[quote="Zedonboy, post:72, topic:14682"]
We just want Legacy id as Account Identifier.

We dont want to see Principal and Subaccount. We are ok with Hash of Principal + Subaccount
[/quote]

But why exactly? Because principal.subaccount isn't supported in some places (-> can be fixed and should have been fixed a long time ago). Or you prefer the aesthetics of legacy account over principal.subaccount? Or the privacy issue?

I am working full time on user-facing DeFI products on the IC and it is my mission to remove as much friction as possible for the users.

-------------------------

Zedonboy | 2024-08-14 20:24:17 UTC | #74

Can ICRC support both?

If yes, then perfect.

If No, a new specification has to be created with same API with ICRC Specs but with different Implementation that uses Legacy Id(Account identifier)

I personally like the Legacy id

1. Because of its Aesthetics
2. Privacy
3. Ease of Use.

We Work in parallel lets give the community a choice. Lets see the adoption rate.

@bitbruce @quinto What do you think?

-------------------------

quinto | 2024-08-15 08:35:18 UTC | #75

[quote="timo, post:73, topic:14682"]
The first time you transfer out of that account you have to reveal principal and subaccount. At least to everyone reading the network and to all node providers and boundary nodes. Privacy based on that should not be relied on.
[/quote]

IC was appealing to me because it didn't make the assumption such data would always remain public. There are hopes that more work towards data privacy will fix the shortcoming you listed. At least that was the way such dreams (of data privacy) was sold to us initially by the IC marketing campaign. Designing for the future should be the principle. Revealing "principal.subaccount" in a public address wasn't adhering to such principles, and is just creating tech debt.

 [quote]
 The thing users and developers complained about was that it was confusing to have two different things as addresses, account ids and principals.
[/quote]

There was never such confusion until some people started designing their own token standards using principal only, and it was BAD idea and THE reason for confusion. Instead of fixing the root of the problem (i.e. get rid of those bad community standards), The ICRC standard erects it further more and now we have to live with such confusions forever! I don't see a chance that legacy AccountId ever being phased out.

-------------------------

quinto | 2024-08-15 08:33:48 UTC | #76

[quote="Zedonboy, post:74, topic:14682"]
We Work in parallel lets give the community a choice. Lets see the adoption rate.
[/quote]

I'm not optimistic about this. There were plenty community proposed token standards before ICRC-1. Whole thing was fragmented until the foundation finally did something with SNS and ICRC-1. Bad design decision in adopted standard was one thing, a dysfunctional community (due to fragmentation) was quite another. Not sure which one is "worse" :crazy_face:

-------------------------

quinto | 2024-08-15 08:48:08 UTC | #77

[quote="timo, post:73, topic:14682"]
But why exactly? Because principal.subaccount isn’t supported in some places (-> can be fixed and should have been fixed a long time ago). Or you prefer the aesthetics of legacy account over principal.subaccount? Or the privacy issue?
[/quote]

I can give you one more example on "why exactly", and this example is even DFINITY's own! I was looking at ckETH minter, and noticed it does not support minting directly to a canister's subaccount. Think it is an easy problem to fix? Better think again! If I'm not mistaken, it will require upgrading the minter's EVM contract (which is non-upgradable, duh!) to emit events with an additional field. All because "principal+subaccount" does not fit into 32 byte! Nice 32-byte long account ids are not just a "nice to have" or "convenient" feature, but it can also prevent months or even years of manpower from being wasted.

As more developers are making use of canisters to hold assets, they will start to notice and demand ckETH/ckERC20 minter to support subaccounts. Good luck! If it ever will be supported...

-------------------------

skilesare | 2024-08-15 13:49:15 UTC | #78

[quote="Zedonboy, post:74, topic:14682"]
Privacy
[/quote]

The privacy is fake.  The principal is known to the boundary nodes. That is one of the reasons it was moved away from.  Until we have some kind of zk transaction or secure enclave encryption you won't be able to keep the account identifier private.

If you don't like sub-accounts then build your app to not use them.  Just use the principal. As @timo mentioned, there are likely some infrastructure pieces to shore up to make principle IDs searchable as account ids, but that is really the only hurdle. If you never give a user a sub account then a principal operates the same way.

A decent first step would be for Plug, Bitfinity, NFTID, etc to move account id off of the main wallet interface and behind an advanced tab and push everyone toward using just principal ids and having Users just use default accounts.

The NNS should remove the account ID from the ICP tab as well and switch it to the ICRC1 human readable format.

If you really think you need a new standard for some reason I'd encourage you to explore a revised infrastructure set that uses ETH based addresses instead.

There is also the option that people don't like to speak about but is completely do able which is to incrementally fork the ICP ledger over time so that as funds move out of legacy ledger accounts they get moved to ICRC-1 accounts and the blockchain begins to accommodate both kinds of transactions.  Yes, this would require a good bit of effort, but may be worth it in the long run.  Unfortunately we can't just deprecate the legacy transfer functions or really ever get completely rid of the legacy account registry because of existing blackholed and non-maintained services, but we can move to a place where the ICRC-1 account is the dominant format used for go-forward transactions.

For example, the NNS client knows your sub-accounts, so it could, upon loading and asking permission from the user call and upgrade function and submit the mappings between accounts and neuron accounts to the ledger for an upgrade.

The ledger can serve up a get_upgraded_accounts(vec Account) -> async vec ICRC1.Account; that serves translated and upgraded accounts to front ends for swap out from the legacy ledger. Over time there will be fewer and fewer non-upgraded accounts.

-------------------------

timo | 2024-08-15 18:21:37 UTC | #79

[quote="quinto, post:77, topic:14682"]
I was looking at ckETH minter, and noticed it does not support minting directly to a canister’s subaccount.
[/quote]

Interesting point. Does the ckBTC minter support minting to subaccounts? Only the ckETH minter does not? I will have to look into this more.

[quote="quinto, post:77, topic:14682"]
All because “principal+subaccount” does not fit into 32 byte!
[/quote]

Principals are 29 bytes. So in 32 bytes you can encode a principal plus 16.7 million subaccounts. Not the whole subaccount space but still sufficiently many if you are ok with "the first" 16.7 million from the entire space. Canister principals are only 10 bytes.

[quote="Zedonboy, post:74, topic:14682"]
Can ICRC support both?

If yes, then perfect.
[/quote]

You can easily build a ledger that can support both if you design it like that from the beginning. On any legacy ledger implementation you can easily add an ICRC-1 interface on top of it, even when it already has state. Conversely, if you have code for a native ICRC-1 ledger then it will require some code changes to the legacy interface to it. And if it's an already running ICRC-1 ledger canister with state in it then will be hard to do, then you have to do what @skilesare described.

-------------------------

quinto | 2024-08-16 02:05:35 UTC | #80

[quote="timo, post:79, topic:14682"]
Does the ckBTC minter support minting to subaccounts? Only the ckETH minter does not?
[/quote]

Yes to both.

[quote="timo, post:79, topic:14682"]
Principals are 29 bytes. So in 32 bytes you can encode a principal plus 16.7 million subaccounts. Not the whole subaccount space but still sufficiently many if you are ok with “the first” 16.7 million from the entire space. Canister principals are only 10 bytes.
[/quote]

Unfortunately the ckETH/ckERC20 minter (or anything that wants to support deposit into ICRC-1 Account) can't do this trick because [the length of subaccount is specified as 32 bytes](https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/README.md).

-------------------------

quinto | 2024-08-16 02:25:41 UTC | #81

@skilesare I think you misunderstood @Zedonboy . We like the legacy 32-byte AccountId. We do not like the public token account address to be "principal" only, or "principal.subaccount".

None of you have made convincing argument that changing from 32-byte AccountId to "principal.subaccount" was a good idea. Besides, now very unfortunately we are forever stuck with both legacy AccountId and "principal.subaccount" when working with ICP.

I think pretty much we can all agree that changing AccountId to "principal" only was a bad idea, as was done by some previous token standards.

-------------------------

timo | 2024-08-16 08:14:51 UTC | #82

[quote="skilesare, post:78, topic:14682"]
If you really think you need a new standard for some reason I’d encourage you to explore a revised infrastructure set that uses ETH based addresses instead.
[/quote]

What would that be? You mean a ledger that accepts just plain ETH addresses, no subaccounts?

[quote="skilesare, post:78, topic:14682"]
There is also the option that people don’t like to speak about but is completely do able which is to incrementally fork the ICP ledger over time so that as funds move out of legacy ledger accounts they get moved to ICRC-1 accounts and the blockchain begins to accommodate both kinds of transactions.
[/quote]

Why would you do that? Why not leave everything in the legacy accounts and have the ICRC-1 interface on top of it, mapping to the legacy accounts, as is the state of the ICP ledger now? The ICP ledger already accommodates both kinds of address.

-------------------------

timo | 2024-08-16 08:19:17 UTC | #83

[quote="Zedonboy, post:74, topic:14682"]
We Work in parallel lets give the community a choice. Lets see the adoption rate.
[/quote]

You could define an extension to ICRC-1 which is an interface that accepts the legacy addresses. Even an already running ICRC-1 ledger can support this extension by migrating its internal database in a one-time migration event. Offering both interfaces in the same ledger is the best way to see adoption rate.

-------------------------

skilesare | 2024-08-16 15:29:00 UTC | #84

[quote="timo, post:82, topic:14682"]
What would that be? You mean a ledger that accepts just plain ETH addresses, no subaccounts?
[/quote]

I've only poked around it and drawn some mental pictures in my mind, but the idea would be to maintain a map of ETH addresses to internal accounts and have a standard RPC API endpoint on your canister that would allow access to those funds from standard metamask/evm wallets. It is on the list of things to explore at some point.

>Why would you do that? Why not leave everything in the legacy accounts and have the ICRC-1 interface on top of it, mapping to the legacy accounts, as is the state of the ICP ledger now? The ICP ledger already accommodates both kinds of address.

The current ICP ledger has both interfaces, but back-end storage causes problems. There are two kinds of storage 1. The Blockchain and 2. The account tree keyed by the legacy account id.  The purpose of migration for the back end would be to eventually remove the false layer of privacy that is there and have things accessible and identifiable by principal.  See the current issue we're having with ICRC2 where on ICP you can't find your approvals via either the blockchain or via an endpoint so there is a security risk for anyone purchasing a principal that may have 'ghost approvals' that you don't know about.  I'm not necessarily suggesting we do this as I think there are plenty of client-side ways to handle this different kind of account structure problem, but it could be done.

-------------------------

skilesare | 2024-08-16 15:41:10 UTC | #85

[quote="quinto, post:81, topic:14682"]
None of you have made convincing argument that changing from 32-byte AccountId to “principal.subaccount” was a good idea. Besides, now very unfortunately we are forever stuck with both legacy AccountId and “principal.subaccount” when working with ICP.
[/quote]

The logic of this was discussed extensively during the design of ICRC1.  There were plenty of reasons, including your argument that it would be much easier if we only had one number. It is a bummer that the ICP ledger launched with the account id as a one-way hashed version.  It is an even bigger bummer that ETH style addresses were not used as they both use ecdsa signatures and the ETH standard was very well established at the time.

The consensus at the time was that a large mistake had been made with legacy account ids and that since almost all tokens that were going to be created were in the future, it made sense at this time to correct the mistake.

One can, and most will be able to use 'just principal' and never have to bother with account ids.  Wallets should adjust and prioritize the principle at this point.  Just for get that account id ever existed and build your applications and wallets that way. Developers that are building canisters that need to look up information in sub-accounts on ICP will still have to jump through some hoops, but libraries exist for that.

-------------------------

quinto | 2024-08-17 13:45:36 UTC | #86

[quote="skilesare, post:85, topic:14682"]
It is an even bigger bummer that ETH style addresses were not used as they both use ecdsa signatures
[/quote]

You seem to be completely ignoring canister side of things. Using only principal ids as account address is a very bad idea.

Say I am making a canister that automatically takes user's USDC deposit and turns them into ckUSDC managed by the canister on the user's behalf. Inevitably I'll have to let canister call the ckERC20 minter. Alas! This minter only supports minting to principal ids (one ID as you wished for) but not principal id + subaccount! Seems I'm completely stuck and have to abandon this idea of managing the USDC -> ckUSDC workflow on user's behalf. I'm all ears if you have a practical solution.

> The consensus at the time was that a large mistake had been made with legacy account ids 

Maybe it was a consensus among the committee creating ICRC-1, definitely you don't have consensus among all developers, including some prominent ones (e.g. AstroX or Deland Labs).

You still haven't made convincing argument why legacy account ids were bad. I just gave you a reasonable example why principal id only was bad.

-------------------------

quinto | 2024-08-17 14:04:56 UTC | #87

As for why switching legacy account id to principal.subaccount account id was a bad idea:

* Maybe devs didn't have to deal with two forms of account ids for ICP (which dominates all token transfers being made on the IC network, even today)?
* Maybe devs didn't have to wait a year and half before getting ICRC-1 support for rosetta client?
* Maybe the foundation's engineers wouldn't make the mistake of not supporting subaccount for ckETH/ckERC20 minter? (and blocking devs who need this feature by another year or more?)
* Maybe IDs can fit into existing conventions a bit more easily? (E.g. Most zkCircuits use data of 256-bit long, and one would have to modify existing circuits if they need to support a two part ID like principal + subaccount).

I'll save the privacy argument for another day. But anecdotally, it was obvious that this change was quite costly with no clear benefit.

-------------------------

timo | 2024-08-17 20:40:26 UTC | #88

I tried to find evidence from the old forum thread, working group minutes and other material as to how the switch from account ids to principal.subaccount pairs came to be. Unfortunately, I couldn't find the transition point. At some point in May 2022 the topic of which one to use is still completely open between the two options. Then the discussion switched to a Discord channel to which I have no access or which may not exist anymore. And at some point in June it had been decided that the principal.subaccount pairs are being used and the discussion from thereon is about other aspects. I can't tell which argument was responsible for the shift.

Comparing the two options and looking for advantages of each we should should look at only the bare standard which ends at the ledger interface. We should ignore the encoding of the account identifier which is really just an exchange format for sending a payment destination to another user. For example, to illustrate the difference: one could have defined the textual representation that we now have for ICRC-1 accounts, which looks like this `h5boe-vqaaa-aaaam-ac36q-cai-ckw43vy.6867bf53ffcaa0cd11f3bb59be8e4d9e71b20d096cc822a5dffecc7561b026ce`, as an exchange format, not requiring any new ledger standard, and could have used it for making payments on the original account id based ledger.

So if we focus on the differences between the two standards, ending at the ledger interface, then we see:
- account ids are shorter, 32 bytes (or without checksum 28 bytes)
- principal.subaccount pairs are longer but contain more information, most importantly the principal who controls the account

The first difference is important because 32 bytes is often an important barrier, so ICRC-1 gives something up here and account ids have an advantage.

Let's leave the privacy issue out of the discussion and leave it for another day.

Slight advantage of the principal.subaccount pair at this point is that it requires less tooling/dependencies on the client side because you don't need to have the code to calculate the hash correctly.

What other advantage can principal.subaccount have, if any? It depends on what the ledger does with that information. For example, does it need the information because it's internal balance database requires it? Or does it need it to write the information into the generated blockchain?

Let's discuss the database first. In a single-canister implementation the internal database layout is irrelevant. Whether it is keyed on account ids or keyed on the explicit principal.subaccount pair, or keyed in a hierarchical way on principal first, then subaccount, makes no difference. All ways are possible to get a functional ICRC-1 compliant ledger. In a sharded ledger on the other hand, there could be some advantage to keeping accounts that belong to the same principal on the same shard. But I somehow doubt that sharding was a consideration in the discussion. 

Writing the information to the blockchain is the only reason left and that was for sure a goal of ICRC-1. It wanted the explicit principal.subaccount pairs in the blockchain. And it wanted _all_ of them in the blockchain, not only some on an opt-in basis. Because for the opt-in basis the solution would have been to keep the account id interface in place and to extend it with another interface that users who opt-in can use. The reason must have been transparency.

That's basically the entire trade off here: giving up the <= 32 byte length for transparency and slightly simpler client code.

The weird thing is that ICRC-1 specification does not mention the blockchain and the fact that the full principal.subaccount information is to be written into it. So the real intention of the standard is not mentioned in its specification. I have been critical in the past of the ICRC-1 spec as being underspecified in the sense that it does not talk about semantics, only about the interface. A standard has to include semantics or it's not a standard. This is another example of this fact. The spec should say that the ledger MUST maintain a blockchain and MUST write the principal.subaccount pair of every transaction into it. For, if it wasn't like that, then we could have just used the account id based ledger and defined principal.subaccount pairs as an exchange format.

Regarding the trade-off mentioned above, I can understand the trade-off because I can make a lot of arguments for transparency and find that feature very useful. Whether if it is was really worth making a new standard for it after the account ids were already out in the wild is another question.

-------------------------

timo | 2024-08-17 20:47:38 UTC | #89

[quote="quinto, post:80, topic:14682"]
Unfortunately the ckETH/ckERC20 minter (or anything that wants to support deposit into ICRC-1 Account) can’t do this trick because [the length of subaccount is specified as 32 bytes](https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-1/README.md)
[/quote]

I meant the ckETH minter could support deposits into 16.7 million subaccounts per principal, those subaccounts that consist of 29 zero bytes and 3 free bytes. For some applications that is enough.

On another note, why is it important that the ETH smart contracts isn't upgradable? Can't an upgraded version of the ckETH minter canister not use a second ETH smart contract? Maybe that second ETH smart contract can then emit two events instead of one to get 64 bytes of data instead of 32 bytes, does that work?

-------------------------

quinto | 2024-08-18 08:34:14 UTC | #90

[quote="timo, post:89, topic:14682"]
Can’t an upgraded version of the ckETH minter canister not use a second ETH smart contract?
[/quote]

Yes, that could be a solution. Though the previous ETH smart contract will still need to be supported for a long time to come (until all existing frontends switch to the new smart contract). My point is not it is difficult to fix this, but how long it will take, given the foundation seems to have a million other priorities.

-------------------------

skilesare | 2024-08-18 15:50:12 UTC | #91

[quote="quinto, post:86, topic:14682"]
You seem to be completely ignoring canister side of things. Using only principal ids as account address is a very bad idea.
[/quote]

I'm absolutely not ignoring it. I've been one of the largest proponents of derived canister IDs as a resolution to this problem since the discussions started.

I had a call with Psycadelic who was one of the biggest dissenters from the direction that ICRC-1 was going and had been a principal-only advocate since day 1 on July 26th 2022 where I explained the exact problem you are mentioning. Custody of funds should be kept by canisters in distinct accounts.  Together we identified that there was an existing derived canister id pathway in the specification that could give a canister multiple principals. They presented the thread here:  https://forum.dfinity.org/t/dip20-community-proposal-psychedelicdao/14611

Soon after they left the ecosystem and there was not enough follow up.  In an ideal world we would have implemented derived canister ids and ICRC1 would not have needed a subaccount.  The principals of a canister would have been derivable via a standard BIPXX like interface and users would have been left with a simple principal-only interface.

I've tried bringing these back up multiple times such as here: https://forum.dfinity.org/t/derived-canister-ids/17434

[quote="quinto, post:86, topic:14682"]
Maybe it was a consensus among the committee creating ICRC-1, definitely you don’t have consensus among all developers, including some prominent ones (e.g. AstroX or Deland Labs).

You still haven’t made a convincing argument why legacy account ids were bad. I just gave you a reasonable example of why principal id only was bad.
[/quote]

The meetings were open and all were invited to participate. Those who didn't participate forfeited their voice.  The discussions took place over months and all the steps along the way were published. Attempting to backtrack two years after the general consensus of those who cared enough to show up is counterproductive.

Here is why account ids are bad:  You can't get rid of the concept of principals due to canisters needing them therefore you end up with two identifiers(accountId for something, principals for others). No one wanted two identifiers. It was confusing to developers, wallet creators, and users.  There was an absolute consensus on making sure we only had one kind of identifier and unless we had derived canister IDs it was going to have to be principal + subaccount if we wanted canisters to hold funds in separate custodial accounts(as you have just mentioned).  We also couldn't revert to only account ID because it is a one-way hash and we would have had to keep a dictionary of all one-way hashes on all replicas(at the replica routing level) and that was seen as an exponential and untenable solution.

Sending tokens to a canister that you know as a principal at a different account id is confusing.  No one wanted that anymore. It was ubiquitous and complete agreement.

If you can come up with a way to use account ids in place of canister id/principals and solve the problem of needing a translation table for routing at the replica level then please present it.

Other wise you're just asking to perpetuate a system that everyone seemingly agrees is confusing by having both account ids and principals.

@timo: I've tried to copy/paste the discord history here:  https://docs.google.com/document/d/1V3DzYIlucX2xXVtmVP5BXDQlu_XNryaHgcS6Ai8CS0c/edit?usp=sharing

It doesn't do a good job with images, but most of the discussion is there.

[quote="timo, post:88, topic:14682"]
The weird thing is that ICRC-1 specification does not mention the blockchain and the fact that the full principal.subaccount information is to be written into it. So the real intention of the standard is not mentioned in its specification. I have been critical in the past of the ICRC-1 spec as being underspecified in the sense that it does not talk about semantics, only about the interface. A standard has to include semantics or it’s not a standard.
[/quote]

This is an artifact of needing to get something out of the door. The basics of ICRC-3 that specify that had been discussed but it was agreed to move it to a different document as to not slow down the release of the initial ICRC-1 standard as DFINITY was waiting on the standard to release the SNS.

-------------------------

sea-snake | 2024-08-18 19:58:58 UTC | #92

Thanks for posting this in-depth comment, reading about the consensus to not want two ids makes a lot of sense.

I also agree that backtracking the last years of discussion isn't viable and also that the risk taken at the time to make the switch seems to be worth it in the long run.

Even though it will take a while for the switch to ICRC-1 to appear outside the IC ecosystem (e.g. centralized exchanges). In practice all major ledgers support the ICRC-1 standard. 

The remaining issue is with existing tooling that hasn't updated yet. Though some of this tooling hasn't been updated and maintained for a long while in the first place 😅

I'm aware from fellow devs that there is a large push from existing tooling and new upcoming tooling to implement and support the ICRC standards, but development takes time, so right now we're a bit in an inbetween phase of tooling.

-------------------------

quinto | 2024-08-19 01:09:39 UTC | #93

[quote="skilesare, post:91, topic:14682"]
Together we identified that there was an existing derived canister id pathway in the specification that could give a canister multiple principals.
[/quote]

I for one, would not go down this path. It will confuse the hell out of developers from being able to tell two canisters apart. 

For me and most developers, the distinction between sending tokens to a canister and sending a message (with attached cycles) to a canister is very clear. They do not require the same type of address. Confounding the two would be a dangerous path to take. Besides, the former (i.e. sending token to canister) is only a conceptual thing, and the real message is sent to the token ledger, not the target canister.

[quote="skilesare, post:91, topic:14682"]
Here is why account ids are bad: You can’t get rid of the concept of principals due to canisters needing them therefore you end up with two identifiers(accountId for something, principals for others). No one wanted two identifiers. It was confusing to developers, wallet creators, and users. 
[/quote]

I beg to differ. AccountId was never confusing to end users in the first place. End users would not need to deal with or even know about principal ids (had canister ids not appear in the URL that is. With custom domains, this is no longer a problem).

Nor are they confusing to wallet creators. It was actually beneficial not to confuse a token address with an account id in developing or using a wallet.

If I'm not mistaken, the so-called "confusion of two identifiers" only started when some misguided devs put out NFT standards that used principals as addresses. And instead of fixing that mistake, the ICRC standards further solidified it. There is no chance that legacy AccountIds will be phased out, ever (for this reason, I think we should stop calling it "legacy").

I'd say an additional confusion users often had was that they cannot accept NFTs using their NNS wallet address. Maybe those NFT standards purposely used principal ids to prevent people from mistakenly sending NFTs to AccoutIds? I am not sure. Unfortunately it didn't help much either.

-------------------------

sea-snake | 2024-08-19 10:23:48 UTC | #94

[quote="quinto, post:93, topic:14682"]
the real message is sent to the token ledger, not the target canister.
[/quote]
A wallet identity has a principal and can make calls with that principal the same as a canister can, there's no difference there. 

From the perspective of the ledger the principal of the incoming call could be either from a canister or a wallet (frontend created keypair), there's really no difference here whatsoever.

The additional hashing layer added on top of the principal does not hide this incoming principal from the call that the ledger receives. It's anonymity by obscurity, in reality this your wallet principal is publicly broadcasted across the IC nodes and also received by the ledger.

So the old account hash format is only a layer added on top of what's already there in the core IC implementation for both canisters and wallets.

The only valid argument for wanting the old account format would be concerns regarding the migration from one format to another. 

The old format never did really give you any form of anonymity. If you want you want separate anonymous accounts, you must create different/derived keypairs that result in different principals. This is basically the same as any other chain.

-------------------------

quinto | 2024-08-19 13:18:41 UTC | #95

[quote="sea-snake, post:94, topic:14682"]
The additional hashing layer added on top of the principal does not hide this incoming principal from the call that the ledger receives. It’s anonymity by obscurity, in reality this your wallet principal is publicly broadcasted across the IC nodes and also received by the ledger.
[/quote]

I'll just quote myself from an early reply to Timo

[quote="quinto, post:75, topic:14682"]
IC was appealing to me because it didn’t make the assumption such data would always remain public. There are hopes that more work towards data privacy will fix the shortcoming you listed. At least that was the way such dreams (of data privacy) was sold to us initially by the IC marketing campaign. Designing for the future should be the principle. Revealing “principal.subaccount” in a public address wasn’t adhering to such principles, and is just creating tech debt.
[/quote]

To sum it up, I think ICP made a lot of right assumptions from the start, including challenging the "public by default" norm taken for granted by other chains. Not designing things assuming "public by default" is very different than designing things assuming "private by default". Your criticism was on the latter. But no, people who prefer AccountId are not delusional in thinking we already have perfect data privacy; we merely are asking please do not design things by assuming "public by default" will always be the case.

-------------------------


dieter.sommer | 2021-12-15 08:53:06 UTC | #1

**Summary**

Smart contracts on the Internet Computer, like on any other blockchain, cannot communicate with external servers per se, e.g., via making HTTP(S) requests. Enabling canisters to make HTTP(S) requests will help integrate the Internet Computer with the Web 2.0 world. This allows for a plurality of new use cases, e.g., obtaining exchange rate data from external servers for DeFi applications, obtaining weather data for decentralized insurance services, or sending notifications to users via traditional communications channels. The first version of this feature will cover a subset of the functionalities that are typically provided by oracle services, but will do so in a trustless manner.

**Status**

Discussing

**Key people involved**

Yotam Harchol, Ivan Malison, Islam El-Ashi, Manu Drijvers, Thomas Locher, Akhi Singhania, Alexa Smith, Dieter Sommer

**Description**

It is not possible for canisters currently to make HTTP(S) requests to servers outside the Internet Computer. This limits what canisters can do as it lacks an integration with the Web 2.0 world. The reason that it is not easy to let canisters make HTTP(S) requests to any external system is that this is a non-deterministic process and all replicas in a subnet need to operate in a completely deterministic manner. A subset of the HTTP(S) scenarios can be captured with an approach of every replica making the same request and then achieving consensus on the response. This is not straightforward as responses for the same call, e.g., to a price API, may differ in some parts, e.g., identifiers or timestamps. Doing a transformation on the HTTP(S) responses before feeding them into consensus can solve this problem.

According to the current thinking, the first MVP for this feature should comprise the ability to make HTTP(S) GET requests, specify a transformation to be applied to the responses by each replica, and then running consensus over the responses. This will already allow for a large set of use cases.
State-changing requests to standard services are problematic in this model as the request is executed by every replica. If the external service, or a fronting service built for the IC interaction, is aware of this model, state-changing calls can be done as well once POST/PUT calls are available.

Later extensions may comprise, among other things, the following:
* POST/PUT requests: enables updates to the outside world if the call model of every replica making the request is accounted for.
* Customizable quorum ("unsafe mode"), where only one replica or a specified number of replicas make(s) the request, with the inherent reduction in security. This maybe useful for less critical interactions and will easily allow for making state changing requests to the outside world in the case of a single replica making the request.
* Allowing for slightly different numerical values in responses, e.g., relevant for fast-changing data that are to be queried.
* Persistent connections (for better performance for periodically executed queries)

**Context**

Enabling canisters to make HTTP(S) requests is one of the topics of the larger long-term R&D motion proposal on General Integrations (see https://forum.dfinity.org/t/long-term-r-d-general-integration-proposal/9383). It has also been picked up by the community in another topic in the dev part of the forum (https://forum.dfinity.org/t/ic-530-canister-can-make-http-requests/6989) after it has been "leaked" as part of an Inside DFINITY episode (see https://forum.dfinity.org/t/direct-integration-with-bitcoin/6147/70, https://forum.dfinity.org/t/idempotent-egress-messages-e-g-send-an-email/6998/2) where it has already been discussed in an internal DFINITY meeting in the context of the Bitcoin integration feature because of possible architecture synergies.
Some other related discussion has already been ongoing in multiple other places in the forum.
* https://forum.dfinity.org/t/idempotent-egress-messages-e-g-send-an-email/6998
* https://forum.dfinity.org/t/make-external-non-ic-http-request-from-backend-canister/2366

This is a cross-cutting feature requiring work in the networking, consensus, message routing, and execution layers. Engineers from each of the teams will join the discussion here so we can answer any question that comes up.

-------------------------

Maxfinity | 2021-12-14 19:36:43 UTC | #2

Would love to see this up and running. Would make trustless bridges possible between the IC and many chains.

-------------------------

diegop | 2021-12-14 21:34:33 UTC | #3

I think is this is an extremely powerful feature and key to hosting more of the worlds critical software via smart contracts

-------------------------

Tbd | 2021-12-14 22:34:35 UTC | #4

Very nice

[quote="dieter.sommer, post:1, topic:9670"]
The first version of this feature will cover a subset of the functionalities that are typically provided by oracle services, but will do so in a trustless manner.
[/quote]
Would it truly be trustless? From my limited understanding the symmetric encryption in TLS causes problems. Some workarounds are https://www.deco.works/ and https://tlsnotary.org/

Interested to know how this would work

-------------------------

jzxchiang | 2021-12-15 03:18:15 UTC | #5

Maybe an easier first step is to enable "fire-and-forget" requests where you don't care about the response, e.g. push notifications. See [this](https://forum.dfinity.org/t/long-term-r-d-general-integration-proposal/9383/6?u=jzxchiang) related thread.

Also, how does the BTC solve this? Apologies if this has been answered before.

-------------------------

dieter.sommer | 2021-12-15 08:54:03 UTC | #6

[quote="jzxchiang, post:5, topic:9670, full:true"]
Maybe an easier first step is to enable “fire-and-forget” requests where you don’t care about the response, e.g. push notifications. See [this ](https://forum.dfinity.org/t/long-term-r-d-general-integration-proposal/9383/6) related thread.

Also, how does the BTC solve this? Apologies if this has been answered before.
[/quote]

Regarding what we currently have in mind for a first MVP, please see the edit of the topmost post with additional details.

The Bitcoin integration feature solves this by having a more specialized implementation targeted at Bitcoin in which each replica essentially acts like a lightweight Bitcoin client that has some state regarding the Bitcoin network, synchronizes with the Bitcoin network and feeds blocks into consensus.

The consensus integration is quite different, though:
* Bitcoin blocks are what we call "self-validating payloads" as they can be validated, e.g., based on the hashwork that has been used to mine the block. That is, we do not need to achieve consensus of what each replica sees, but blocks can be handled much like ingress messages with some additional checks regarding the validation.
* HTTP(S) responses, on the other hand, are non-self-validating payloads, i.e., we need to have agreement between the replicas on what the correct response is. That is, we require a more complex integration with consensus that is at the core of this feature.

Hope this answers your question, otherwise feel free to ask again. :slight_smile:

-------------------------

skilesare | 2021-12-15 20:05:21 UTC | #7

I don't see this as a priority and would much rather see services pop up that handle this in a more secure, auditable, and deterministic manner.

This feature would never be useable by enterprise applications since the receipt of the HTTP response would never be guaranteed to reach a consensus.  The handling of this seems like a nightmare inside IC code.  It seems much more straightforward to have trusted applications that watch the IC, respond to events, and then put the desired response back into the IC.

Further, because most web 2 systems are not written with multiple responses coming in that need to match 100% this seems like a massive foot gun for onboarding devs that want to use this feature and just can't get it to work because twitter has a timestamp it injects into each response that makes get requests never match.

-------------------------

Tbd | 2021-12-15 22:42:45 UTC | #8

[quote="skilesare, post:7, topic:9670"]
I don’t see this as a priority and would much rather see services pop up that handle this in a more secure, auditable, and deterministic manner.
[/quote]

Yeah agree if we're just gonna be recreating chainlink.

One option I've been looking at is Mina: https://medium.com/minaprotocol/https-and-snapps-bridging-cryptocurrency-and-the-real-world-962beb21cf2b

A SNARK is created that checks the https response signature and whatever is inside the body.
There's not much details out (supposedly coming early 2022), but from what I gathered its similar to [deco](https://deco.works). i.e. you need some third party participating in the handshake (their snapp operators) or else it could be forged.

The benefit is you only need 1 request so no consensus needed, and anyone could do the request from their own PC and create a proof that checks private information (like bank account balance) without revealing that info.

-------------------------

Maxfinity | 2021-12-16 10:51:41 UTC | #9

I think it would be great to have "Chain-Link" on the IC, the consensus mechanism would be more secure. We are really moving to a multi-chain world and this would blow most other blockchains out of the water.

-------------------------

dieter.sommer | 2021-12-16 11:11:48 UTC | #10

Hi Max!

We have a motion proposal about "General Integration" (https://forum.dfinity.org/t/long-term-r-d-general-integration-proposal/9383) which will comprise, among other topics, integrations with other blockchains and oracle providers. Chainlink integration, also with their upcoming Cross-Chain Interoperability Protocol (CCIP; https://chain.link/cross-chain), is something of relevance there. Also things like an integration with Polkadot as mentioned in one of the threads should be discussed as one option to integrate with existing integration layers.

-------------------------

dieter.sommer | 2021-12-16 13:03:40 UTC | #11

[quote="skilesare, post:7, topic:9670, full:true"]

This feature would never be useable by enterprise applications since the receipt of the HTTP response would never be guaranteed to reach a consensus. The handling of this seems like a nightmare inside IC code. It seems much more straightforward to have trusted applications that watch the IC, respond to events, and then put the desired response back into the IC.

Further, because most web 2 systems are not written with multiple responses coming in that need to match 100% this seems like a massive foot gun for onboarding devs that want to use this feature and just can’t get it to work because twitter has a timestamp it injects into each response that makes get requests never match.
[/quote]

Let me try to clarify a little what we have in mind. From what you write it seems you are assuming that the canister making an HTTP(S) call will need to deal with all the (slightly) different responses from all replicas of the subnet. However, this will be done by the IC, the canister gets back a single response. The only additional thing the canister needs to care for is to define a transformation function that is applied to the response by each replica to "cut out" varying information, such as timestamps of request-specific ids or just return a single number of interest, e.g., a price of an asset. The IC replicas then apply this transformation on their respective HTTP(S) response and thereby we have the same consolidated / transformed response to account for variable bits and pieces in the response on each replica that will be fed to consensus. A single consolidated response will reach the canister like in a traditional Web 2.0 application. Thus, querying will work really nicely with this approach, for HTTP(S) endpoints that return predictable responses, e.g., various API endpoints. There is no need for external trusted parties and thus additional trust assumptions. It's essentially a direct integration of oracle-like functionality into the IC protocol stack. This is hard to beat and no other blockchain would have this feature. Also request cost would be much lower than when using oracle services.

Quoting Max:

[quote="Maxfinity, post:9, topic:9670, full:true"]
I think it would be great to have “Chain-Link” on the IC, the consensus mechanism would be more secure. We are really moving to a multi-chain world and this would blow most other blockchains out of the water.
[/quote]

The more difficult problem is when updating state in external services. Either the service can handle the same state-changing call arriving multiple times, which is easily doable when building such a service with blockchain clients in mind, but current standard services do not account for this. Building a proxy towards external services that handle those multiple update calls is simple, but again introduces a trusted party. This requires definitely further discussion.

[quote="skilesare, post:7, topic:9670"]
I don’t see this as a priority and would much rather see services pop up that handle this in a more secure, auditable, and deterministic manner.
[/quote]

External services that pop up would always add additional trust assumptions and thereby make it less secure. In the ideal case, we lose little to no security, but that's already hard to achieve in practice when introducing those additional trust assumptions.

I think that the external services you mention could coexist in the larger integration landscape and provide additional value for specific integrations. When you speak about enterprise applications, what exactly do you mean? Maybe that's a specific use case.

-------------------------

dieter.sommer | 2021-12-16 13:07:51 UTC | #12

[quote="dieter.sommer, post:1, topic:9670"]
Customizable quorum (“unsafe mode”)
[/quote]

Quoting myself above, let me also talk a little bit more about this as it touches the problems that @skilesare and @Tbd have voiced. The functionality of a customizable quorum would be an extension that allows the calling canister to define how many replicas should do the call, e.g., this could be 1, thereby allowing for a trade-off between security on the one side and performance, simplicity, and cycles cost on the other side. When doing a request with 1 replica only, we would give up some security which may be fine for many use cases. Also update calls to external systems would be trivial, with the same reduction in security. It may be good enough for things like many user notification scenarios etc.

-------------------------

dieter.sommer | 2021-12-16 13:11:29 UTC | #13

[quote="Tbd, post:8, topic:9670"]
One option I’ve been looking at is Mina: [HTTPS and Snapps: Bridging cryptocurrency and the real world | by Mina Protocol | MinaProtocol | Medium](https://medium.com/minaprotocol/https-and-snapps-bridging-cryptocurrency-and-the-real-world-962beb21cf2b)
[/quote]

Thanks for sharing those links to other integration approaches!
This looks pretty interesting after a quick glance over it. I would be interested in seeing more details on how this is actually done, maybe next year, once they have released it. :-)
However, one drawback seems to be that there is again the need for additional trusted parties that take part in the TLS handshakes.

-------------------------

dieter.sommer | 2021-12-16 13:21:57 UTC | #14

[quote="Maxfinity, post:9, topic:9670, full:true"]
I think it would be great to have “Chain-Link” on the IC, the consensus mechanism would be more secure. We are really moving to a multi-chain world and this would blow most other blockchains out of the water.
[/quote]

Indeed, with the additional extra functionality we have listed, we would get close to what Chainlink can offer. Our approach would likely be massively cheaper per call, more flexible for users, and provide better security than a single oracle query. Doing multiple oracle queries in chainlink then again costs even more and puts additional burden on the canister to do a "poor man's consensus" on the individual results on the application level. Our proposal would move most of the complexity into the IC protocol stack, at the cost of the implementation effort we have.

I greatly appreciate the discussion and alternatives that are being proposed and think that we will likely need a broader landscape of features and services to achieve all that we want to achieve. We learn more about what our community thinks is the right approach to go forward with with every blog post! Those discussions will help us in prioritizing our efforts toward maximizing the value we create.

-------------------------

jzxchiang | 2021-12-16 21:31:28 UTC | #15

> It’s essentially a direct integration of oracle-like functionality into the IC protocol stack. This is hard to beat and no other blockchain would have this feature. Also request cost would be much lower than when using oracle services.

I wonder why other blockchains don't do a direct integration like this. Is it just too much effort to implement? Or are there deeper technical requirements to this that are only met by the IC?

-------------------------

Maxfinity | 2021-12-16 22:05:42 UTC | #16

[quote="dieter.sommer, post:13, topic:9670"]
However, one drawback seems to be that there is again the need for additional trusted parties that take part in the TLS handshakes.
[/quote]

I think Chainlink also has done some work on TLS handshakes but it's not completely trustless, still needs a consensus engine to run on top.

-------------------------

dieter.sommer | 2021-12-23 15:54:30 UTC | #17

[quote="Maxfinity, post:16, topic:9670"]
I think Chainlink also has done some work on TLS handshakes but it’s not completely trustless, still needs a consensus engine to run on top.
[/quote]

This TLS handshake-based approaches are definitely worthwhile looking at in more detail!

-------------------------

Tbd | 2021-12-23 18:00:57 UTC | #18

[deco](https://deco.works) is the one that was acquired by chainlink :smiley: recommend checking out their paper
they also acquired https://www.town-crier.org/ Lol, but it uses secure enclaves

-------------------------

dieter.sommer | 2021-12-23 18:59:55 UTC | #19

[quote="jzxchiang, post:15, topic:9670"]
I wonder why other blockchains don’t do a direct integration like this. Is it just too much effort to implement? Or are there deeper technical requirements to this that are only met by the IC?
[/quote]

Two potential reasons:
* Thanks to the subnet-based architecture of the IC, only the replicas of one subnet handle an HTTP(S) request, and not all replicas of the blockchain. This is definitely a big advantage in terms of scalability.
* Our consensus implementation is rather flexible in terms of handling different kinds of payload that require different processing. E.g., ingress messages, Xnet messages, DKG-related and soon also threshold-ECDSA-related messages and HTTP(S) messages. Not sure, whether the consensus layer of every blockchain provides that much flexibility. Any experience here?

That's the things that come to my mind, but maybe there are more. Any other thoughts on this?

-------------------------

QiuYeDx | 2022-01-04 08:46:49 UTC | #20

sounds great!!!
followed~
 :star_struck:

-------------------------

dieter.sommer | 2022-01-17 14:53:39 UTC | #21

We are thinking of how a system API in the Management Canister could look like for a first MVP implementation of the feature. In such first iteration, we are thinking of just allowing for HTTP GET calls. If responses may differ, the canister can provide a method to transform it. This is useful to, e.g., account for timestamps, transaction ids, and the like, as commonly found in API calls. This transformation happens on every replica of the subnet to account for different responses received by each replica. Post transformation, all responses should be the same and can go into consensus.

This MVP would already be pretty useful for lots of applications.

```
type HttpHeader = record { 0: text; 1: text };

type HttpResponse = record {
  status: nat;
  headers: vec HttpHeader;
  body: blob;
};

type Error = variant {  
  no_consensus;
  timeout;
  bad_tls;
};

service ic : {
  // A new method to be added to the IC management canister.
  http_request : (record {
    url : text;

    // Support for other methods like post/put would be added here.
    method : variant { get };

    headers: vec HttpHeader;

    body : opt blob;

    transform : opt variant {
      // The name of a wasm method to transform the response.
      // The method signature must be: `(HttpResponse) -> (HttpResponse)`
      // and must be exported by the canister.
      wasm_export: text
    };
  }) -> (variant { Ok : HttpResponse; Err: opt Error });
}
```

Feedback welcome!

-------------------------

mparikh | 2022-01-17 15:38:48 UTC | #22

Not sure about the semantics(and/or correctness) of such transformations. imagine a simple thing like time in replicas.

For example: If the time is stored internally through a system call made within the replica at the time of a update, any transformation that goes through reasoning abou time (i.e. all records within a time range) may report inconsistent results across replicas. Thoughts?

The answer/pattern here is pretty important even for things outside of this specific topic. For example, in my file-system on top of stable memory there is no concept of time as being local to replica.

-------------------------

nomeata | 2022-01-17 19:47:26 UTC | #23

The `transform` field might be a _great_ application for Candid’s support to reference functions, so if you put in 
```
transform : opt (func (HttpResponse) -> (HttpResponse) query)
```
you get type checking there and the guarantee (kinda) that the exported function is a query.

This would allow referencing other canister’s query functions, which may seem a bit odd, but is actually nice from a decoupling and composition point of view. And performing a possibly remove query shouldn’t be too hard (or you just fail in that case, if you don’t want to deal with that).

If Candid already had [Generic data](https://github.com/dfinity/candid/issues/245), then something like this would be even better:
```
service ic : {
  http_request : <T>(record {
    url : text;
    method : variant { get };
    headers: vec HttpHeader;
    body : opt blob;
    transform : func (HttpResponse) -> (T) query
    };
  }) -> (variant { Ok : T; Err: opt Error });
}
```
After all, there is no reason why the transform function needs to return a `HttpResponse`, and not already something that has been parsed into application logic.

@rossberg can probably comment on these composition and function reference issues.

-------------------------

dieter.sommer | 2022-01-17 21:11:05 UTC | #24

@nomeata : Thanks for your suggestions on the API, Joachim!

[quote="mparikh, post:22, topic:9670"]
Not sure about the semantics(and/or correctness) of such transformations. imagine a simple thing like time in replicas.
[/quote]

My text did actually not provide enough detail here. So, let me give some more information now: The idea of the transformation function is that is must result in the same response on each replica in order to allow for consensus. The common cases we have in mind is that we know the structure of the response, e.g., a JSON object from an API call and implement the function in a way that "cuts out" some parts of the JSON, e.g, time stamps, ids etc. from the response that may differ between different responses to obtain the transformed response. Such transformations are simple structural transformations based on a priori knowledge of the structure of the response. Particularly, such transformations would not need to reason about time in any way in the replica, as doing so would clearly be very reliable source of non-determinism.

I don't know whether I am missing a specific class of use cases you have in mind here, but we think that a key use case for the transformation is to remove fields that are known to differ between different responses of the same call. Think of exchange rate APIs as one example of this.

If you want all records within a time range, as you mention in your post, and different responses may contain different records, we would need to provide the time bounds as input to the transformation. Would such additional parameters something we should consider? If so, we would need to somehow provide parameters in a generic manner.

-------------------------

nomeata | 2022-01-17 22:23:14 UTC | #25

[quote="dieter.sommer, post:24, topic:9670"]
Would such additional parameters something we should consider? If so, we would need to somehow provide parameters in a generic manner.
[/quote]

This would be transparently and generally possible, with the simple interface that I provided above, if and when Candid (and the platform) supported closures: https://github.com/dfinity/candid/pull/291

It may be tempting to come up with ad-hoc solution for this instance of the problem of higer-order function composition, but then the next API has to solve them again. It may be better to solve generic issues once and for all at a lower level.

(If only we had been bold and relentless on the level of the programming model back then, then we might have closures on the system level now already - right @PaulLiu?)

-------------------------

ielashi | 2022-01-20 14:51:04 UTC | #26

@nomeata Thanks for the suggestion. It's not clear to me how how reference functions would be used in, say, Rust. What would the caller pass in the payload? The function index?

-------------------------

bazmoz | 2022-01-20 21:01:16 UTC | #27

> The more difficult problem is when updating state in external services. Either the service can handle the same state-changing call arriving multiple times, which is easily doable when building such a service with blockchain clients in mind, but current standard services do not account for this

Couldn't consensus elect one replica to send post/update requests and have measures to make sure it can only send content signed by all the replicas.

-------------------------

nomeata | 2022-01-21 09:51:06 UTC | #28

[quote="ielashi, post:26, topic:9670"]
It’s not clear to me how how reference functions would be used in, say, Rust. What would the caller pass in the payload? The function index?
[/quote]

The value representation of `func … → …` is the principal of the canister to call and the name of the method – see https://docs.rs/candid/latest/candid/types/reference/struct.Func.html

So operationally not much difference, but the interface describes more of the intent, and you get some type checking (how much type checking depends on your CDK)

-------------------------

dieter.sommer | 2022-01-28 08:21:17 UTC | #29

[quote="bazmoz, post:27, topic:9670"]
Couldn’t consensus elect one replica to send post/update requests and have measures to make sure it can only send content signed by all the replicas.
[/quote]

There are options on how you can do state-changing POST calls to external services. A future extension of the feature would be to allow to select to have a reduced quorum, e.g., only a single replica make a call, with the implications on security. This can be followed by a GET request to validate that the POST has had the desired effect. This is not a 100% generic solution as updates might not be straightforward to validate, but can solve lots of practical use cases.
Another option is that the external service is aware that requests can be made from a blockchain with its trust assumptions and that there are multiple calls for the same request and only process the request once and only if sufficiently many replicas have sent it. This does not work with standard HTTP services, though.
The problem with one replica is that you have no control whatsoever what this replica does, so it seems hard to achieve something that is secure on the one hand and has only one replica sending something on the other hand. A post-update validation seems to be a somewhat clean approach.
Do you have some more concrete idea in mind how the approach you sketched could work? Would be interested to hear about it!

-------------------------

bazmoz | 2022-01-28 13:12:39 UTC | #30

I didn't have a concrete idea as the internal way the replicas communicate, I havent looked at and so maybe this is not feasible. But the general idea was something like:
- Canister in every replica will do the post request. This will be caught by the IC system.
- Having POST requests from all the replicas, the system will come to a conclusion through consensus on what is the right post request to send and which replica will actually send the post request.
- The selected replica will send the request. All of these happening at the system level and I was hoping there is no way, the replica can change the request at this point. But as you say, we may not have any control what the replica does and the replica could change the request right before sending.
- On receiving the response the selected replica will again send the response back to all the replicas

Basically, in overview the idea was that subnet decides what is the right post request to send through consensus and chooses one replica to send it. There is overhead of consensus ..etc and so its not efficient compared to the other solution.

-------------------------

dieter.sommer | 2022-02-11 13:02:38 UTC | #31

[quote="bazmoz, post:30, topic:9670"]
Basically, in overview the idea was that subnet decides what is the right post request to send through consensus and chooses one replica to send it. There is overhead of consensus …etc and so its not efficient compared to the other solution.
[/quote]

The overhead we would have would not be the problem. The main problem with this approach would still be that there is no way to know whether the replica designated for sending out the request does the right thing, e.g., it could send a modified request or not send a request at all. A compromised replica could do anything it wishes.

The easiest approach for making a state-changing post call would be to simple select one replica to make it and then make a full-quorum call by all replicas to validate that the server's state has been changed accordingly as outlined further above. This requires that this kind of verification is possible, but, if it is, this is a viable way to do posts with those HTTP servers nicely. Note that, though, the feature of only one replica sending a request is a future extension and will not be readily available. However, it seems to be something we should prioritize as it can help solve quite some use cases.

-------------------------

RikusWiehahn | 2022-02-14 05:33:36 UTC | #33

Firstly, this feature is a game-changer that I can't wait to use.

To solve an immediate need I hacked together a proof of concept/workaround that uses a "Web2 Bridge" canister to receive HTTP requests and a node.js server that polls, processes, and returns the results. (I've only tested it on the local replica so far). Sharing here in case anyone else is in the same situation.

https://github.com/RikusWiehahn/internet-computer-web-2-bridge

Also, Is there an IC equivalent to `thread::sleep`? I'm using an iterating counter that goes up to 2 Billion as a delay hack and it feels very wrong indeed 🚩🚩🚩

-------------------------

JaMarco | 2022-02-14 18:16:41 UTC | #34

[quote="dieter.sommer, post:31, topic:9670"]
The overhead we would have would not be the problem. The main problem with this approach would still be that there is no way to know whether the replica designated for sending out the request does the right thing, e.g., it could send a modified request or not send a request at all. A compromised replica could do anything it wishes.
[/quote]

Don’t query calls on read data from 1 replica? How is it verified for query calls that 1 replica returned the correct data?

-------------------------

diegop | 2022-02-14 18:43:12 UTC | #35

[quote="JaMarco, post:34, topic:9670"]
Don’t query calls on read data from 1 replica?
[/quote]

Correct. If one wants a higher level of security or guarantee, one should use Update calls (since they go through consensus).

A common pattern devs have been using on front-ends is:

1. Fire off a query call on the frontend for quick answer
2. Simultaneously fire off an update call for higher security
3. Use frontend code to reconcile if #1 and #2 are different

-------------------------

nomeata | 2022-02-14 19:28:30 UTC | #36

[quote="diegop, post:35, topic:9670"]
Correct. If one wants a higher level of security or guarantee, one should use Update calls (since they go through consensus).
[/quote]

… or use certified variables to allow the client to check the response of the query call.

-------------------------

diegop | 2022-02-22 20:01:51 UTC | #37

## Summary

**This is a draft/preview of a motion proposal for "HTTP Requests from Canisters" which we will submit tomorrow (February 23, 2022) for the community to vote on.**

Once proposal is live, I will update the forum.

# Background

Canister smart contracts cannot make requests to HTTP/HTTPS services on the Internet by default. Doing so is a challenge on any blockchain caused by the fact that different replicas / nodes can (and will) receive different responses for the same call, be it, for example, for timestamps or ids contained in the response. Such different responses received by different replicas and further processing being based on those different responses on each replica would lead to a divergence of state on the different replicas and thus destroy the determinism property of the computation with the result that no consensus could be achieved. Thus, replicas cannot just make HTTP/HTTPS requests to outside services without creating a major problem for the subnet.

However, it is technically possible to enable canisters on the IC to safely make HTTP/HTTPS (henceforth just "HTTP") requests with an extension of the Internet Computer protocol. This feature discusses such extension to the Internet Computer protocol. We think that this is a crucial step towards better integrating the Internet Computer with the public Internet and thus breaking down so-far inherent borders that blockchains face. We think that opening up the Internet Computer to interface it with HTTP services on the Internet is a major step towards the future of the Internet Computer as a platform that can run general-purpose workloads and also for a more open, integrative, blockchain world at large.

Today, obtaining data from the outside world requires, as on any blockchain, the use of blockchain oracles, or oracles. However, oracles lead to a more complicated programming model, charge substantial fees, add complexity and indirections, and require additional trust assumptions to be made. Allowing canister code to directly make HTTP requests would remove the dependence on oracles and its disadvantages. Of course, oracles may still be useful for certain use cases when we have HTTP calling capabilities, but many use cases could be covered with direct HTTP calls.

Allowing canisters to make HTTP calls to services on the public Internet has long been a community-requested feature for the Internet Computer. It will give smart contract canisters the ability to autonomously connect to services on the Internet to retrieve or submit data and will thus enable a large range of additional or enhanced use cases, e.g., obtaining exchange rate data from external servers for DeFi applications, obtaining weather data for decentralized insurance services, or sending notifications to users via traditional communications channels, all without using oracles. HTTP support for canisters is one of the features on our strategic R&D initiative on "General Integration" (see https://forum.dfinity.org/t/long-term-r-d-general-integration-proposal/9383/4), thus we want to now proceed with launching a motion proposal for this feature and ask for community approval w.r.t. going forward. If accepted, a launch in the Q1 Chromium release is planned, meaning an aggressive timeline for our engineering teams.


# Goals and Requirements

This feature should enable canisters to directly make requests to HTTP URLs, using the GET method initially, and receive the corresponding response back into the canister’s state in a deterministic fashion. The functionality should be realized in a direct, trustless, way. Direct, trustless, integration is a common theme in other integrations of the IC, e.g., the Bitcoin integration that is to launch on mainnet in the near future. Direct integration means that we do not need to make any additional trust assumptions or involve any additional parties to realize the functionality.

For the first version, all replicas in the subnet will send out the request and return a response that goes through the IC Consensus mechanism. In the future, we may present an option for canister developers to reduce the size of the required quorum, so that even only one replica may make the request, if desired, but the guarantees on such request would be accordingly lower. Another future envisioned extension are POST requests. In combination with the reduced quorum, those can be of tremendous utility for many use cases where reliability of the calls is less important than compatibility with APIs out there.


# Proposed Design

We next outline the proposed design at a high level.


## System API (Management Canister)

We implement a system API in the Management Canister that provides a method for making an HTTP/HTTPS call to an outside service and receiving back a response. See below for the original proposal w.r.t. the API and note that not all community feedback from the discussions in this forum topic have not been included here yet.


```
type http_header = record { 0: text; 1: text };

type http_response = record {
  status: nat;
  headers: vec http_header;
  body: blob;
};


type http_request_error = variant {
  no_consensus;
  timeout;
  bad_tls;
  invalid_url;
  transform_error;
  dns_error;
  unreachable;
  conn_timeout;
};
```

**New method in ic0:**


```
  http_request : (record {
    url : text;
    method : variant { get };
    headers: vec http_header;
    body : opt blob;
    transform : opt variant {
      function: func (http_response) -> (http_response) query
    };
  }) -> (variant { Ok : http_response; Err: opt http_request_error });
```

See the (draft) PR on the interface specification repository, which is now public, for details regarding the proposed API and related discussions: https://github.com/dfinity/interface-spec/pull/7/files.


## High-Level Request and Response Flow

Calling this API will store the request in a specific area of replicated state that is periodically read by a component at the networking / consensus layer. This component, once it sees a new request, provides this request to an HTTP Adapter at the networking layer which performs the actual request and provides a response in return.

Responses are put into a new HTTP Artifact Pool, are signed by the replica to endorse the response, and the signature is gossiped to all replicas in the subnet. Once a request has support by at least 2/3 of the replicas of the subnet in the view of the current block making replica, it adds this endorsed response to an IC block that is going through Consensus. Because at least 2/3 of the replicas of the subnet have supported the response, it is ensured that the subnet can achieve consensus on it.

Once the IC block with the HTTP response has made it through the IC consensus layer, it is routed back to the system API and is provided back to the calling canister, which concludes the original API call for making an HTTP request.

We do not go into the details of the error handling. In short, it is possible, as error scenarios, that requests time out or cannot be consented on, in which case a corresponding error response is generated and returned in response to the request.

## Handling Differences in Responses

Many HTTP-based services like API providers include fine-granular timestamps or unique ids into their responses, implying that it would not be possible to achieve consensus on the responses received by the different replicas in the subnet. This can be addressed by allowing the caller to specify a response processing function to be performed on the responses before they are provided to the consensus layer. This allows for a much broader field of application for the feature by allowing a broader class of responses to obtain consensus on.

The canister may specify a response processing method that, when a response is received by each replica, is applied on the response on each replica to transform it accordingly into a response that is intended to be the same on each replica and thereby will be accepted by the IC consensus mechanism.
The transformation may, for example, only keep specific fields from the responses, while removing other values that might differ across responses, such as timestamps or unique identifiers. The transformation can also just retain a single value of interest from the whole response, e.g., an exchange rate value, which would substantially reduce the required IC "block bandwidth".

The design choice to expose a canister method to perform the transformation and not do the transformation directly in replica code has multiple reasons behind it:
* The computational effort for the transformation can be directly accounted for through consuming the canister's cycles. Thereby certain kinds of denial of service attacks that would be possible and would need to be addressed for a replica implementation are not possible.
* It is fully flexible in terms of which transformations can be implemented. Implementations in replica code would use a specific approach, e.g., a templating language, for defining the transformation.
A drawback of the approach of exposing a canister method for the transformation instead of an alternative considered design of allowing for a set of transformation types parameterized by a template as input to the method call is that it may be slightly more effort on the side of the canister author to implement the canister method. However, the tradeoffs have been considered substantially in favour of the approach of exposing a canister method, as in the other approach it would be difficult to charge for the transformation effort and to prevent DoS attacks using long-running transformations.


# Roadmap

We plan, assuming a supportive community vote, to build the feature to be ready for a release around the end of Q1 / 2022. We propose a design and scope that is reasonable to implement for a first MVP as outlined in this motion proposal to trigger further discussions and support a community vote.
The implementation cuts through all the layers of the IC protocol stack and thus requires tight collaboration between the core IC engineering teams. Most engineering effort is expected on the consensus layer, next are networking, execution, and message routing in descending order of effort. In order to meet the tight timeline to a Q1 release, the different teams will work in parallel as far as reasonably possible.

In order to ensure the high quality of the feature, we will perform extensive automated testing in our system testing environment and a security review.


# Extensions

The envisioned feature implementation is a first MVP that provides the core functionality of allowing canisters to make HTTP requests. We have already identified some enhancements that have been decided to not be implemented as part of the first release, but that we can realize as separate features in the future.
* **POST/PUT requests:** Those would be pretty similar in terms of implementation assuming idempotency of the requests. Not assuming this inherently requires us to use a reduced quorum of size 1 to emulate traditional POST/PUT calls or to extend the called API such that it can handle multiple requests for the same POST/PUT to be done and execute them only once.
* **Customizable quorum (unsafe requests):** This allows the canister to specify the quorum size to make a tradeoff between performance, resource consumption, and compatibility with traditional HTTP-based servers on the one hand and security on the other hand. The most relevant reduced quorum size in practice will be quorum size 1. This extension, together with the possibility of making POST/PUT requests will enable another large array of use cases without making changes to external services.
* **Persistent connections:** This is an extension purely for better performance, and thus left as an extension instead of implementing it already as part of the MVP.
* **Different numerical response values:** Some APIs will result in slightly different response values if called at slightly different times. The latter is typically the case in the setting of all replicas making the same call to a service. A further extension to the feature can allow for such different received numerical response values to be consented on and being returned in appropriate form, e.g., their median or all values are returned so that the calling canister can directly receive or apply an appropriate function to determine the "actual" response value.

-------------------------

weedpatch2 | 2022-02-23 02:03:17 UTC | #38

At first blush, this is a clean solution. I do have a question, though.

What would be the scope/namespace and capabilities of the pre-consensus hook function? That function is SUPER cool, but seems like it could be abused.

-------------------------

dieter.sommer | 2022-02-24 08:20:09 UTC | #39

What kind of ways of abuse of the function are you envisioning? It's a function that can only be executed as a query.

**Update:**
On a first glance, I do not see any major means of abusing this. It essentially behaves like a pure function, so no state of the canister can be changed.
It should be similar in terms of abuse potential to any query call that a canister offers.

-------------------------

diegop | 2022-02-23 18:49:55 UTC | #40

Proposal is live: https://dashboard.internetcomputer.org/proposal/46519

-------------------------

lastmjs | 2022-02-23 19:01:41 UTC | #41

I foresee the need to make http requests from query calls.

-------------------------

jzxchiang | 2022-02-24 06:40:23 UTC | #42

> Responses are put into a new HTTP Artifact Pool, are signed by the replica to endorse the response, and the signature is gossiped to all replicas in the subnet. Once a request has support by at least 2/3 of the replicas of the subnet in the view of the current block making replica, it adds this endorsed response to an IC block that is going through Consensus. Because at least 2/3 of the replicas of the subnet have supported the response, it is ensured that the subnet can achieve consensus on it.

> **Once a request has support** by at least 2/3 of the replicas of the subnet in the view of the current block making replica, it adds this endorsed response to an IC block that is going through Consensus.

Did you mean "Once a response has support..."?

-------------------------

jzxchiang | 2022-02-24 06:56:29 UTC | #43

A couple of questions inspired by [this](https://gist.github.com/v-kolesnikov/8e5e4bc72726b8c190ca487ed213365e):

* Will this integration support HTTP/2?
* What happens if the HTTP response is large, much larger than 2 MB?
* Will this integration support compression, i.e. `Content-Encoding`?
* Will this integration support streaming large responses via methods like HTTP/1.1 chunked transfer encoding?
* Will this integration support range requests?

This is exciting stuff! Easy yes vote.

-------------------------

dieter.sommer | 2022-02-24 08:14:42 UTC | #44

[quote="lastmjs, post:41, topic:9670, full:true"]
I foresee the need to make http requests from query calls.
[/quote]

Do you have specific use cases in mind for HTTP requests from query calls?

Technically, it would be completely different to what we are implementing now. In many ways, one could realize HTTP requests for query calls by simply the replica making the HTTP request without any Consensus involvement as the replica is either honest or not and depending on this the query result is trustworthy or less so.
The biggest conceptual problem I can see here is that query calls are synchronous  and are done within fractions of a second and making an HTTP request might take a relatively long time, being an asynchronous operation with an entity in the outside world. This might be a large enough mismatch making your request potentially very hard to realize. Also, to make it clear, this is wild thinking in response to your request and currently not planned to be implemented.

Other opinions on HTTP requests for query calls?

-------------------------

lastmjs | 2022-02-24 13:55:58 UTC | #45

Just as there is currently a great want for Inter-Canister Query Calls, there will be a similar desire for http requests from query calls. Both of these features presume a developer wants to request data from somewhere outside of their own canister on the IC or off of the IC, and do it quickly. There will be many uses for this, I can't foresee them all.

Specifically for me I want to use a canister as a proxy for podcast downloads. Currently podcasts require a server proxy in many cases to download audio files to a web client, because the web clients have CORS restrictions that servers simply ignore. To create an entirely on-chain podcast ecosystem we'll need canisters to act as proxies (or boundary nodes, but something needs to do this).

A web app served from the IC might want to perform an http get request to a canister that quickly aggregates information from two other canisters and three http endpoints in the legacy world.

If the IC is going to replace traditional cloud then it needs to allow what traditional cloud allows. Coming from Node.js, I feel very strongly that flexible http request functionality is essential to achieving this vision. And I can foresee many asking for this feature in the future.

-------------------------

dieter.sommer | 2022-02-24 17:49:06 UTC | #46

[quote="jzxchiang, post:42, topic:9670"]
> **Once a request has support** by at least 2/3 of the replicas of the subnet in the view of the current block making replica, it adds this endorsed response to an IC block that is going through Consensus.

Did you mean “Once a response has support…”?
[/quote]

Yes, indeed I meant to say “Once a response has support…” in the proposal text. Those things happen...
Nice to see that people read our texts so carefully! :-)

-------------------------

dieter.sommer | 2022-02-24 17:56:51 UTC | #47

[quote="RikusWiehahn, post:33, topic:9670"]
Also, Is there an IC equivalent to `thread::sleep` ? I’m using an iterating counter that goes up to 2 Billion as a delay hack and it feels very wrong indeed :triangular_flag_on_post::triangular_flag_on_post::triangular_flag_on_post:
[/quote]

You may not get a response to this unrelated question in this topic. If you re-post it in a better-suited topic I am pretty sure you will quickly get help on this.

-------------------------

dieter.sommer | 2022-02-24 18:02:28 UTC | #48

[quote="lastmjs, post:45, topic:9670"]
A web app served from the IC might want to perform an http get request to a canister that quickly aggregates information from two other canisters and three http endpoints in the legacy world.

If the IC is going to replace traditional cloud then it needs to allow what traditional cloud allows. Coming from Node.js, I feel very strongly that flexible http request functionality is essential to achieving this vision. And I can foresee many asking for this feature in the future.
[/quote]

Good points! We will discuss this internally. The main issue I can see, as already mentioned further above, is the unpredictable time the http requests take and the effects this has for the synchronous query calls. It might clash with the general architecture behind query calls.
Good points to discuss, however. Thanks for the inputs!

-------------------------

yotam | 2022-02-24 18:37:58 UTC | #49

[quote="jzxchiang, post:43, topic:9670, full:true"]
A couple of questions inspired by [this](https://gist.github.com/v-kolesnikov/8e5e4bc72726b8c190ca487ed213365e):

* Will this integration support HTTP/2?
* What happens if the HTTP response is large, much larger than 2 MB?
* Will this integration support compression, i.e. `Content-Encoding`?
* Will this integration support streaming large responses via methods like HTTP/1.1 chunked transfer encoding?
* Will this integration support range requests?

This is exciting stuff! Easy yes vote.
[/quote]

As a first MVP we plan to only support HTTP/1.0 or 1.1. It would be quite straightforward to add HTTP/2 support for simple requests.

There must be some size limit on the response, and for now we have set it to 2MB as it is the maximum size for payload in a block.we could allow bigger responses given that the transform function can then reduce them below 2MB but we would still want to have some upper bound so the feature is not abused. For starter, we’ll just have it at 2MB.

For MVP we do not plan to support more than one response per request or content encoding. Decoding compression would be easy to implement at the adapter level so we might do that, but it could then violate size limits. Let me discuss that with the team.

I am not sure what you mean by “range requests”.

-------------------------

jzxchiang | 2022-02-25 01:43:45 UTC | #50

Thanks, this makes sense.

When this integration eventually supports query calls as @lastmjs suggested, I foresee a use case where a canister may want to stream and serve a large media file. Why? I'm not entirely sure at the moment, but I can see some wanting it.

By [range requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests), I mean the case where a server returns an `Accept-Ranges` header and a client requests portions of a large blob using the `Range` header.

-------------------------

icme | 2022-02-25 05:19:15 UTC | #51

Totally see how this would be useful, but right now if you're aggregating data it might be best to set up a cron-job to pre-fetch what you might need and have it ready on your canister(s). 

If you're setting up a download, what about setting up some sort of a WebRTC streaming solution? I haven't done this myself, but was listening to the [OpenChat episode of the Internet Computer Weekly podcast](https://podcasts.apple.com/gb/podcast/openchat-deep-dive/id1569570770?i=1000542203349) where Matt Grogan talks about using WebRTC to make the chat experience feel instant while processing the update calls simultaneously. It seems like a pretty sweet solution if they're actually doing that and not just blowing smoke.

-------------------------

yotam | 2022-02-25 11:04:46 UTC | #52

[quote="jzxchiang, post:50, topic:9670, full:true"]
Thanks, this makes sense.

When this integration eventually supports query calls as @lastmjs suggested, I foresee a use case where a canister may want to stream and serve a large media file. Why? I'm not entirely sure at the moment, but I can see some wanting it.

By [range requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests), I mean the case where a server returns an `Accept-Ranges` header and a client requests portions of a large blob using the `Range` header.
[/quote]

It would be very problematic to make HTTP requests from query calls. It would require a completely different design than the one we have for this feature. The reason is that in the current design, requests are stored into the replicated state so that both the execution and consensus components can track the request status and deliver back the response. Even with “fire-and-forget” style of requests we would still need a very different mechanism than we currently have in place. That being said, I don’t think it is impossible.

W.r.t HTTP response ranges, that should not be a problem. It is up to the server to support that and the canister can then specify the appropriate header fields in the request in order to use this feature.

-------------------------

lastmjs | 2022-02-25 13:35:18 UTC | #53

The download issue I'm referring to is a CORS issue. The browser cannot download audio from servers that do not return the appropriate CORS response headers. Many servers hosting podcasts do not return the headers for some reason. Thus a server proxy is used, which returns the appropriate headers, and streams the audio from the origin server (since servers don't care about CORS, only browsers), through the proxy, to the browser.

It's just a workaround for CORS, I don't see how WebRTC could help with that unfortunately.

-------------------------

dieter.sommer | 2022-02-28 18:16:53 UTC | #54

The motion proposal for this feature has been accepted!
https://dashboard.internetcomputer.org/proposal/46519

-------------------------

dieter.sommer | 2022-04-04 07:26:40 UTC | #55

**Status update:**
We have been working on this feature with a small team for some time now and made quite some progress in all the affected layers: Execution, Consensus, and Networking. Due to a partial overlap of the team with the Bitcoin engineering team, we will likely experience some delays here as Bitcoin has higher priority. A rough estimation for the HTTP feature to be finalized is some time in June.

-------------------------

lastmjs | 2022-04-14 23:09:11 UTC | #56

Thanks for the update! I am extremely excited for this functionality, and especially to be able to build IC-native oracles with Azle. I really think oracles on the IC could be a huge opportunity.

-------------------------

tonynguyen | 2022-05-05 09:18:28 UTC | #57

sorry, this feature release yet? I need this to call Apis.

-------------------------

dieter.sommer | 2022-05-05 10:57:04 UTC | #58

The feature is still being developed and we think it may be finalized some time in June.

-------------------------

tonynguyen | 2022-05-05 23:17:35 UTC | #59

so currently, there is no way to call outside apis?

-------------------------

diegop | 2022-05-05 23:47:38 UTC | #60

Correct. This is not unique to blockchains. No blockchain can natively call outside APIs (that is why oracle networks exist alongside blockchains).

-------------------------

tonynguyen | 2022-05-06 04:06:23 UTC | #61

Thank you for clarifying. I will wait for this feature.

-------------------------

diegop | 2022-05-06 04:08:42 UTC | #62

You are very much welcome!

And I am also eagerly waiting for it

-------------------------

dieter.sommer | 2022-05-06 09:01:10 UTC | #63

[quote="diegop, post:60, topic:9670, full:true"]
Correct. This is not unique to blockchains. No blockchain can natively call outside APIs (that is why oracle networks exist alongside blockchains).
[/quote]

Indeed! Just to add another dimension to what Diego was saying: What you could do for now, however, is to build an outside service that periodically queries your canister for API calls that should be made, if a call is available, you fetch it with an update call, then make the API call with the outside service, and return it to the canister with an update call. That would be similar to how an oracle would work to connect to the outside world and would allow you to make API calls already now before this feature is available, but with less decentralization (and coolness). You can probably put an oracle like this together quickly and get going already now with your ideas. Later you can switch over to this feature.

-------------------------

Iceypee | 2022-05-07 22:38:55 UTC | #65

What is this in the documentation for management canister? It says it has http_request in the docs, when it was recently updated a few days ago. [ https://smartcontracts.org/docs/current/references/ic-interface-spec/#icmethod-http_request]( https://smartcontracts.org/docs/current/references/ic-interface-spec/#icmethod-http_request) . Is this supposed to just be a preview and not actually available?

And also, it seems like the ledger has an http request, (albeit the one that is used to deploy the icp ledger itself, and not the interface you use to interact with the icp leger) has an inbuilt http request. https://preview.ic.rocks/interfaces/nns/ledger.did
Is this somehow like an early version thats already enabled?

-------------------------

skilesare | 2022-05-07 22:49:12 UTC | #66

http_request handles incoming requests.

-------------------------

Iceypee | 2022-05-07 22:56:52 UTC | #68

Oh wait why is there a url field in it? Otherwise if it was to take http request to itself, the url would be the canister ledger/management canister itself no? And you wouldnt need to specify then.

-------------------------

skilesare | 2022-05-07 23:21:35 UTC | #69

See this: it is there for parsing the url: https://forum.dfinity.org/t/icdevs-org-bounty-8-httprequest-parser/10219

-------------------------

Iceypee | 2022-05-07 23:43:13 UTC | #70

Oh that makes sense. Thanks

-------------------------

tonynguyen | 2022-05-09 09:40:52 UTC | #72

Yes, I intended that will do like that.
Many thanks

-------------------------

ovictor | 2022-05-22 16:05:36 UTC | #73

I have tried using the API, but I received this error running it locally:

Call was rejected:
Request ID: 642a845ac4a960ad87233acb8f75fad6daecb1193ec1b3a694a97561f10ca0ea
Reject code: 
Reject text: This API is not enabled on this subnet

Can I enable it?

-------------------------

skilesare | 2022-05-22 16:56:30 UTC | #74

Can you show your code?  This may be related to the new dfx 10, but that seems very odd.

-------------------------

ovictor | 2022-05-22 18:13:44 UTC | #75

Thanks for the reply, just a small snippet to test the function:

```
import Nat "mo:base/Nat";
import Text "mo:base/Text";
import Debug "mo:base/Debug";


actor {

type HttpHeader = { name: Text; value: Text };

type HttpResponse =  {
  status: Nat;
  headers: [HttpHeader];
  body: Blob;
};

type HeaderField = (Text, Text);

type HttpRequest = {
  url : Text;
  method : { #get };
  headers : [HeaderField];
  body : Blob;
  };

 let IC = actor "aaaaa-aa" : actor {
 http_request : (HttpRequest) -> async (HttpResponse);
 };

  public func req(url:Text) : async () {
    Debug.print("URL: " # url);
      var myReq : HttpRequest = {
      url= url;
      method = #get;
      headers= [  ("content-type", "text/plain") ];
      body = Text.encodeUtf8("Counter");
    };

    var res = await IC.http_request(myReq);
    Debug.print("Response Code " # Nat.toText(res.status));
  };

};
```

-------------------------

skilesare | 2022-05-22 19:07:39 UTC | #76

You are asking the ic root canister for its http_request function. I don’t think it has one.

Let is not how you use that API. Typically you don’t call that from other canister. You can implement that function so web browser can call and ask for information from your canister, but it is not an outgoing httprequest.

-------------------------

ovictor | 2022-05-22 19:15:53 UTC | #77

I thougth it could be used to do outgoing HTTP request when I read the doc: https://smartcontracts.org/docs/current/references/ic-interface-spec#ic-http_request , but maybe it can be done from one canister to another, I guess...

I succesfully received http requests from www to my canister, but I need to make a request from my canister to web2 to create integration with payment methods ( Like stripe) for exemple.

-------------------------

skilesare | 2022-05-22 21:24:29 UTC | #78

That is “coming soon” but I think will only be one shot get requests. I don’t think your canister will be able to process the response. There was some talk of trying to get this to work, but it seems like a vile sin against determinism. 🤷‍♂️  Plus, who is going to put their stripe key on 8 servers they don’t own? My guess is, best case in the medium term is you can ping a service that does some work and  pushes the data you need on to the IC. You can do the same right now by polling.

-------------------------

Maxfinity | 2022-05-22 21:40:44 UTC | #79

How can we do anything with the data returned if it's one-shot? I sincerely hope the request enables us to use the data. What the IC really needs is a time-out.

-------------------------

skilesare | 2022-05-22 21:51:48 UTC | #80

It has always seemed like outgoing requests would break determinism for me. You can trust one node to execute the task and trust them, but that is a recipe for disaster. Having n number call the same web 2 post will never provide sufficient responses to reach consensus. Imagine 8 servers all hitting the same submit_payment stripe api at the same time. A bunch are going to get duplicate request errors and if the stripe programmers are really good only one will submit the payment. How does a dev tell the IC to deal with that mess? Even a time stamp in a get request requires dev intervention. Poll and push by a trusted party is going to be massively less complex.

-------------------------

Maxfinity | 2022-05-22 21:56:29 UTC | #81

I think the IC has a clever solution to the consensus problem, the idea being devs would write reducers and so when a requests goes through the consensus, we would not get the whole response but only on some function of it, which could exclude the timestamps and just query for the relevant information. I think info is fine, more complex stuff with payments I have no idea how the IC will solve.

-------------------------

Maxfinity | 2022-05-22 22:00:05 UTC | #82

[quote="skilesare, post:80, topic:9670, full:true"]
It has always seemed like outgoing requests would break determinism for me. You can trust one node to execute the task and trust them, but that is a recipe for disaster. Having n number call the same web 2 post will never provide sufficient responses to reach consensus. Imagine 8 servers all hitting the same submit_payment stripe api at the same time. A bunch are going to get duplicate request errors and if the stripe programmers are really good only one will submit the payment. How does a dev tell the IC to deal with that mess? Even a time stamp in a get request requires dev intervention. Poll and push by a trusted party is going to be massively less complex.
[/quote]

I guess they will be get requests, but not on-shot. Update may not work for the IC.

-------------------------

skilesare | 2022-05-22 22:01:56 UTC | #83

I’ve seen some stuff about the reducers, but I can’t imagine they will be worth the trouble for anything but simple data feed requests. I can’t imagine writing a decentralized service with any kind of decent value associated with it and trust an external http request. You are at the complete mercy of the service provider not faking data. Maybe if it is your own service, but again, Poll and push just seems so much easier of a pattern.

-------------------------

JaMarco | 2022-05-22 22:58:46 UTC | #84

How is Chainlink solving this?

-------------------------

mparikh | 2022-05-23 01:44:34 UTC | #85

I thought that the following pattern would be preferable in an async world.


fn update(x_transid: i64, key:i32, value:i32) -> bool { 
    // x_transid is expcted to be unique. Only one call to x_transid will succeed in external call ; if at all...every other call will fail

    // therefore reducers will ALWAYS return true
}

fn lookup(x_transid: i64, key: i32) -> bool {
    // did update suceed in external call with key being updated with attached x_transid
}


So you make the call to update; but rely on lookup to know whether the update actually suceeded. Of course support is required from the external system.

-------------------------

coin_master | 2022-05-23 09:52:16 UTC | #86

Might be interesting to you, there's currently an example of this feature in review.

https://github.com/dfinity/examples/pull/238

-------------------------

dieter.sommer | 2022-05-23 09:54:50 UTC | #87

Well observed! Indeed, we are implementing a simple sample dApp in Rust and Motoko. The dApp will pull ICP exchange rates from Coinbase and offer the rates over an on-chain API.

-------------------------

dieter.sommer | 2022-05-23 10:16:46 UTC | #88

[quote="skilesare, post:78, topic:9670"]
That is “coming soon” but I think will only be one shot get requests. I don’t think your canister will be able to process the response.
[/quote]

[quote="Maxfinity, post:79, topic:9670, full:true"]
How can we do anything with the data returned if it’s one-shot? I sincerely hope the request enables us to use the data. What the IC really needs is a time-out.
[/quote]

What the feature will be capable of is to allow canisters to make GET requests to external services and receive the (transformed) response. If responses of the Web 2 server are not deterministic, you need to define a transform function to make it deterministic, i.e., remove non-deterministic attributes like timestamps and session ids. This allows then all replicas to receive the same transformed response and let consensus agree on it.

POST
Doing POST calls is a rather small extension that would be added after an initial release. Doing a post with this feature assumes that the Web 2 service can handle that the same request be made by all nodes of the subnet. Web 2 services that support the **Idempotency-Key** header as specified in the [draft RFC](https://tools.ietf.org/id/draft-idempotency-header-01.html) should work for correctly processing POST requests when using the Idempotency-Key header in the request.

-------------------------

skilesare | 2022-05-23 15:11:24 UTC | #89

[quote="dieter.sommer, post:88, topic:9670"]
Idempotency-Key
[/quote]

Nice! Great feature. I wonder have ubiquitous the implementation is.

-------------------------

dieter.sommer | 2022-05-25 08:56:20 UTC | #90

[quote="skilesare, post:89, topic:9670"]
Nice! Great feature. I wonder have ubiquitous the implementation is.
[/quote]

It's definitely not implemented by every service. So this is something that practically limits the possibility of POST requests to Web 2.0 HTTP-based services using the current version of this feature.

-------------------------

Maxfinity | 2022-05-25 17:37:47 UTC | #91


Makes sense I like the idea ...

-------------------------

goose | 2022-06-17 03:40:37 UTC | #92

The feature is finalized  in June？

-------------------------

Iceypee | 2022-06-22 01:00:07 UTC | #93

big macs for sergey !!!

-------------------------

dieter.sommer | 2022-06-22 08:08:54 UTC | #94

**Progress update**

We are currently wrapping up the MVP implementation of the feature, only a few small things remain to be done. We plan to launch the feature in July. The MVP will be an IPv6-only launch for the reason of our replicas not having IPv4 addresses. Going via boundary nodes, as initially planned, may be added at a later stage, but the main issue is that all subnets then share the rate limits of services as we only have 10-20 boundary nodes currently.

What is missing now are the following items:
* Merge some MRs that are under review
* Finish the sample dApp demonstrating the feature (ICP price quotes from Coinbase)
* HEAD and POST extensions and corresponding system test
* Local https-capable setup for system tests (currently going via external site); requires support for self-signed certificates
* Enable SDK (almost done, still requires replica with feature to be shipped)
* Cycles charging: decision on price (under discussion)
* Rollout to selected subnet(s)
* Full rollout to all subnets

-------------------------

ovictor | 2022-07-13 13:17:45 UTC | #95

Just to be sure, the feature is now live?
https://github.com/dfinity/examples/tree/master/rust/exchange_rate

-------------------------

dieter.sommer | 2022-07-16 17:08:36 UTC | #96

**Update**

Using the opportunity of a short interruption of my hiking vacation to give you an update.

The feature is now code complete and waiting for its documentation to be finalized and some infrastructure configuration changes to be done before we can release it. Those infrastructure changes are required in order to prevent canisters from trying to access ports of internal services (e.g., logging) that are accessible from replicas (and thereby would be accessible also from canisters, and not just replicas, with this feature becoming available). For according security, to prevent this access already at the networking level and not rely solely on access control within the feature, this needs to be addressed. Thus, in the spirit of a defense-in-depth design principle, the feature is blocked on those infrastructure changes.

Security is a primary concern, hope you all understand this! We hope to be close to the most recent plan of launching the feature be end of July 2022. Maybe it slips a little into August, depending on the effort to make the infrastructure changes.

-------------------------

MCLYang | 2022-07-19 08:52:47 UTC | #97

I was told released on late May... now it’s August. Dfinity plz stop being busy with something else and release the MVP

-------------------------

tonynguyen | 2022-07-19 11:50:08 UTC | #98

Dfinity team is god of delay. I think they aren't good at estimation, planning

-------------------------

daijianlin | 2022-07-20 09:02:56 UTC | #99

Maybe they take this (delayed things) just completely for granted as the time going, I really don't like to complain but dfinity team really bad at estimation. Really hope the team could do better next times... @dieter.sommer 😁😺😁 seems that nobody from outside could trust a team that break the plans again and  again, so maybe that's one of the reasons the price is down so heavy...

-------------------------

pxf520 | 2022-07-21 03:48:13 UTC | #100

Dfinity team is god of delay.
Agreed.

-------------------------

diegop | 2022-07-21 22:21:22 UTC | #101

*(I am going to get on my soapbox a bit and defend Dieter and some of my fellow colleagues working hard on this feature)*

Let's give the folks working on this project some slack here...

To be fair, enabling HTTP requests from smart contracts (in a secure way) is a feature that has eluded every blockchain. This team has taken a few months to do what no other chain has *in years*.

Did they underestimate the work necessary? Yes, but this is not surprising since they are literally inventing things so they are not sure what they will find as they build it (not to mention a litany of security reviews to make sure it is bulletproof).

-------------------------

mparikh | 2022-07-21 05:34:30 UTC | #102

I second this opinion from @diegop ...copying the gist of something that i picked up from elsewhere in a completely different context(btc integration context)...

"....They are being super cautious; even if the math adds up. That is to say we know we can go to mars; but we really dont need an disaster to land on mars.

.... This is ...literally...a mission to mars project. It hasnt beem done before. Paving the road and learning along the way. 

We have one shot and we better not screw it up. On the positive side, the worlds best team to handle these crypographic needs....."

-------------------------

MCLYang | 2022-07-21 22:04:22 UTC | #103

Thank u very much for replying. I know Dfinity team is exceptional and that's why we choose to build on ICP

-------------------------

dieter.sommer | 2022-08-03 13:39:03 UTC | #104

**Update**

We still need to conclude the following tasks before a release on the IC:

* Making the infrastructure changes mentioned further above. Parts of it has been implemented already, parts are still to be done.

* Reviewing and merging the code related to a major performance improvement resulting from the change of the signature scheme used to sign artifacts in the consensus layer. We wanted to get this out before a first release.
* Writing and publishing the documentation for the feature.

The abovementioned performance improvement results in a major reduction of CPU overhead due to using a different signature scheme.

-------------------------


bohdan1227 | 2024-05-24 07:42:05 UTC | #1

Hello, everyone.

I checked that ckUSDC is live on the mainnet.
This means ckERC20 is done?
I am waiting for ckERC20 to be done.

Best regards

-------------------------

b3hr4d | 2024-05-24 08:28:14 UTC | #2

Yes, `ckUSDC` utilizes [ckERC20](https://github.com/dfinity/ic/blob/master/rs/ethereum/cketh/docs/ckerc20.adoc) behind the scenes!
[quote="Manu, post:169, topic:22819"]
ckUSDC is now live on mainnet! With the acceptance of proposal [129750 ](https://dashboard.internetcomputer.org/proposal/129750), the ckERC20 â€œledeger suite orchestratorâ€ canister ([vxkom-oyaaa-aaaar-qafda-cai ](https://dashboard.internetcomputer.org/canister/vxkom-oyaaa-aaaar-qafda-cai)) created a ledger & index canister for ckUSDC, and the ckETH minter canister is now also responsible for converting between native USDC and ckUSDC.
[/quote]

-------------------------

bohdan1227 | 2024-05-24 08:36:09 UTC | #3

Thank you for your response.

So this means I can use ckERC20 for my custom token? 
If so, where can I find guide how to use it?
I already have ERC20 token on ethereum. I am going to make ckERC20 token on internet computer so that users can convert  token between ethereum and IC.

Thanks

-------------------------

Manu | 2024-05-24 08:57:18 UTC | #4

Hi @bohdan1227, here are two options.

1. You can propose that the ckETH/ERC20 canisters that are under NNS control (so the canisters listed [here](https://dashboard.internetcomputer.org/ethereum)) add support for a new ERC20 token. That would be a proposal similar to https://dashboard.internetcomputer.org/proposal/129750, and if the NNS DAO approves, your ERC20 token is now supported by these canisters. 

2. You can take the [source code](https://github.com/dfinity/ic/blob/master/rs/ethereum/cketh) of ckETH/ERC20, and deploy your own instance under your own control, such that you don't need the approval of the NNS. 

Out of curiosity, for which ERC20 token would you like to have a ck-version?

-------------------------

bohdan1227 | 2024-05-27 13:28:57 UTC | #5

Hi, Manu.

Thank you for your kind guide.

We have token on ethereum and we are going to make it convertable between ethereum and ICP.
We are waiting for ckERC20 to be ready and it seems it's already finished.
And I think first option is fit for us.
If you can help with this, that would be grateful.

Best regards

-------------------------

b3hr4d | 2024-05-24 09:07:47 UTC | #6

I suggest creating your own implementation/canister for custom tokens for now. Take a look at this [tutorial](https://forum.dfinity.org/t/building-a-cross-chain-eth-payment-and-e-commerce-platform-on-the-internet-computer-a-step-by-step-tutorial/23938). It will give you an idea of how to start with HTTP outcalls, verify events generated by your ERC20 token, and then perform your tasks on the Internet Computer blockchain.

-------------------------

Ajki | 2024-05-25 22:50:14 UTC | #7

[quote="Manu, post:4, topic:31109"]
You can take the [source code ](https://github.com/dfinity/ic/blob/master/rs/ethereum/cketh) of ckETH/ERC20, and deploy your own instance under your own control, such that you donâ€™t need the approval of the NNS.
[/quote]

What are the security implications of a custom ckERC20 canister? 
For example, what happens to ckAsset if the developer does not top up the cycles or deletes it at some point?

-------------------------

b3hr4d | 2024-05-26 08:20:58 UTC | #8

The security of a trusted custom ckERC20 canister shouldnâ€™t solely rely on the developerâ€™s hands. Itâ€™s an NNS-backed project, meaning it is controlled by the Internet Computer community.

Moreover, ckAssets are essentially ledger canisters that use the ICRC standard token, providing a standardized and secure framework for token management.

-------------------------

Robert_Hon | 2024-06-01 10:50:44 UTC | #9

@Manu is there any plan about ckUSDT, anyway, the official ckUSD series promoted by dfinity will make the ecosystem more and more prosperous.

-------------------------

bohdan1227 | 2024-06-02 07:52:30 UTC | #10

Hi, everyone!

I found solution to send proposal using quill.
I am going to send proposal to ckERC20 Ledger Suite Orchestrator Canister to add ckNOBL (our utility token). 
but what I am concerning is that where I should put ethereum NOBL address. Is it okay to add on Summary text?

This is what I referred; https://wiki.internetcomputer.org/wiki/How-To:_Create_an_NNS_motion_proposal

Best regards

-------------------------

wpb | 2024-06-02 22:34:40 UTC | #11

[quote="bohdan1227, post:10, topic:31109"]
I am going to send proposal to ckERC20 Ledger Suite Orchestrator Canister to add ckNOBL (our utility token).
[/quote]

Looks like you submitted [proposal 130142](https://dashboard.internetcomputer.org/proposal/130142), which is a Motion proposal.  It will not add support for NOBL if it is executed.  Motion proposals to not change any code.  The payload is inaccurate.

@Manu provided a link to a previous successful [proposal 129750](https://dashboard.internetcomputer.org/proposal/129750) that upgraded the NNS canister.  Notice that it is a System Canister Management topic of the NNS Canister Upgrade type, not a Governance topic of the Motion type.  You would have to submit this type of proposal and it would need to have complete and accurate details in the payload in order for it to execute automatically if it is adopted by the NNS.

That said, I don't think the intent is for the community to do this on our own yet.  I have a feeling that DFINITY intends to lead a community discussion on what ERC-20 token we want to see implemented as the next ckERC20 token.  I would still expect DFINITY to originate ckERC20 token proposals for now.  Whenever it is open to the community, there would certainly be an expectation of plenty of discussion and community feedback prior to submitting the proposal.  Generally, proposals that hit the NNS without any warning don't get adopted.  You should lead community discussion and give people time to think about and make educated decisions on how they would vote for your proposal.  People need to be given time to study and discuss your proposal.

Anyway, I hope you find this to be constructive feedback.  Good luck.

-------------------------

Sormarler | 2024-06-02 23:06:00 UTC | #12

Why do we need gatekeeper for a simple ckERC20? Anybody should be able to launch a ERC20 token in a decentralized manner without permission.

-------------------------

wpb | 2024-06-03 03:40:13 UTC | #13

Go for it.  Submit a System Canister Management proposal for your favorite ckERC20 token.  Here is a primer to get you started.

https://github.com/dfinity/ic/tree/master/rs/ethereum/ledger-suite-orchestrator

-------------------------

bblist | 2024-06-03 04:56:36 UTC | #14

Are you saying that the submission is not correct? 
...plenty of discussion before submitting?  I am also wondering how this will hamper the onboarding of many devs - some devs like to act quickly without first having to build up a fraternity... are you saying we need to first become buddies?

-------------------------

bohdan1227 | 2024-06-03 05:39:03 UTC | #15

Hi, @wpb 

Thanks for your explain.

I also read https://github.com/dfinity/ic/tree/master/rs/ethereum/ledger-suite-orchestrator .
Then, what do you suggest for new ckERC20 token support?

Or should we wait for a while that dfinity team discuss and decide about ckNOBL support?

Please let me know what should I do.

Best regards

-------------------------

Lorimer | 2024-06-04 05:45:05 UTC | #16

Did you read @Manu's suggestion?

> You can take the [source code ](https://github.com/dfinity/ic/blob/master/rs/ethereum/cketh) of ckETH/ERC20, and deploy your own instance under your own control, such that you donâ€™t need the approval of the NNS.

-------------------------

Pete | 2024-06-04 14:47:28 UTC | #17

Thanks everyone for your interest in enabling additional ckERC20 tokens. 

To recap;
- The ckERC20 orchestrator has been built to enable new tokens in a scalable manner which doesn't require coding, only canister configuration updates.
- New ckERC20 tokens are enabled by an NNS DAO proposal. Anyone in the community with a neuron may submit proposals. DFINITY will publish a clearer help guide soon.

However as the orchestrator smart contract is newly deployed, DFINITY would suggest that the community activates new ckERC20 tokens at a reasonable pace, at least initially, to mitigate new smart contract risk. Suggestion would be around ~10 additional ckERC20 tokens beyond ckUSDC over the next 2 months. 

DFINITY will both propose additional ckERC20 tokens and vote on community initiated ckERC20 proposals. The foundation's goal is to encourage a diversity of twinned tokens, so will vote agnostically on community initiated ckERC20 proposals. Though the foundation will sanity check proposals for technical accuracy (e.g. proposal is correctly formed, payload and text is consistent, ICRC-1/2 configuration is consistent with the ERC-20 token being twinned etc). 

Hope this helps & let the "chain fusion summer" beginâ€¦

-------------------------

Lorimer | 2024-06-04 19:59:02 UTC | #18

[quote="Pete, post:17, topic:31109"]
The ckERC20 orchestrator has been built to enable new tokens in a scalable manner which doesnâ€™t require coding, only **canister configuration updates**
[/quote]

Thanks for clarifying @Pete. Presumably the 'ckERC20 Ledger Suite Orchestrator' canister therefore shouldn't need upgrading to a new binary (just to facilitate a [function call](https://github.com/dfinity/ic/blob/1b1e474f7e4ef8765547193e15135cc044820c46/rs/ethereum/ledger-suite-orchestrator/src/lifecycle/mod.rs#L65) to add the new ckERC20 token to the canister configuration and create the new ledger suit). But unless I'm mistaken it looks like the intended pathway for triggering this is a 'System Canister Management' (SCM) proposal, executing the `NnsCanisterUpgrade` function (is that correct?).

In an ideal world, wouldn't it be worth avoiding desensitising the community to SCM proposals proposed by unrecognised neurons / non-Dfinity devs (given the potential for such proposals to modify critical system components). It feels like this sort of thing should have a dedicated proposal type with limited scope in terms of the changes it can apply.

Please let me know if I have the wrong end of stick.

-------------------------

Manu | 2024-06-05 07:11:53 UTC | #19

You're right that ckERC20s are added using normal canister upgrade proposals. While this proposal type can do more than is needed to add an ERC20 token, the upside of using this type is that there is no need for custom logic in the NNS. You could imagine introducing some new ckETH/ckERC20 specific proposal type, but now there's a new type of proposal that needs to be built into the NNS and that all voters need to understand. 

> In an ideal world, wouldnâ€™t it be worth avoiding desensitising the community to SCM proposals proposed by unrecognised neurons / non-Dfinity devs (given the potential for such proposals to modify critical system components).

This i actually see very differently. I don't think anybody should trust some proposal just because it happens to be submitted by dfinity. We should always verify that all proposals make sense, and otherwise reject, the submitted should be irrelevant imo.

-------------------------

Lorimer | 2024-06-05 07:59:33 UTC | #20

Thanks @Manu.

> You could imagine introducing some new ckETH/ckERC20 specific proposal type, but now thereâ€™s a new type of proposal that needs to be built into the NNS and that all voters need to understand

I was thinking that a more general purpose way of achieving this might be to introduce a 'System Canister Payload' proposal (or similarly named), such that it's clear that all it does is feed the payload to an update call on the canister (and not capable of modifying the binary that the canister is running). This way there'd just be one new NNS function that is clearly self describing, and therefore more understandable for the majority of the community and easier for them to review and hold an opinion on. I think making things easier for more people to engage is an important thing to strive for, don't you think?

> I donâ€™t think anybody should trust some proposal just because it happens to be submitted by dfinity

I agree - personally I would never manually vote on a proposal without first reviewing and doing my best to understand the changes. However I don't think this is true for everyone. Personally, I think it would be a good thing to encourage everyone in the community to exercise extreme scepticism in the face of SCM proposals that originate from new or unrecognised neurons. But I'm not sure it's realistic to expect everyone in the community to exercise that same level of scepticism for every single SCM proposal, particularly not if they're normalised and typically proposed by anyone. The potential for damage from a nefarious SCM proposal seems enormous.

-------------------------

Pete | 2024-06-05 10:16:59 UTC | #21

[quote="Lorimer, post:20, topic:31109, full:true"]
I agree - personally I would never manually vote on a proposal without first reviewing and doing my best to understand the changes. However I don't think this is true for everyone. Personally, I think it would be a good thing to encourage everyone in the community to exercise extreme scepticism in the face of SCM proposals that originate from new or unrecognised neurons. But I'm not sure it's realistic to expect everyone in the community to exercise that same level of scepticism for every single SCM proposal, particularly not if they're normalised and typically proposed by anyone. The potential for damage from a nefarious SCM proposal seems enormous.
[/quote]

Rest assured that DFINITY will always be reviewing any SCM proposals! 

The reality today is that there is already nothing technically stopping anyone submitting such proposals. DFINITY itself uses a diverse set of neuron IDs which are not cryptographically verified to be acting on DFINITY's behalf. So we all have to be on guard for the inevitable eventuality that someone else submits an SCM proposal.

Which leads me to think it's better to normalize the process which we will need to safeguard the system, than rely on it not happening and being a rare event which catches people off guard. 

I also agree that one of the possible trust signals is "do I know who the proposer is", but given that compromising a "trusted account" is a major vector of cyberattacks today, I would not place too much emphasis on it. When it comes to critical parts of the system, better not to trust & verify.

-------------------------

gregory-demay | 2024-06-05 12:23:52 UTC | #22

Hi everyone!

A follow-up regarding Pete's message
> Anyone in the community with a neuron may submit proposals. DFINITY will publish a clearer help guide soon.

We just added some guidelines on how to [add a new ckERC20 token](https://github.com/dfinity/ic/blob/master/rs/ethereum/ledger-suite-orchestrator/README.adoc#adding-a-new-ckerc20-token). I hope this will clarify any misunderstanding regarding how to submit a NNS proposal for this use-case. As usual, feel free to ask any clarifying question on the forum.

-------------------------

Lorimer | 2024-06-05 17:35:50 UTC | #23

Thanks @gregory-demay for the detailed guidelines, and thanks @Pete for your response.

[quote="Pete, post:21, topic:31109"]
The reality today is that there is already nothing technically stopping anyone submitting such proposals.
[/quote]

I think it's right that anyone should be able to submit SCM proposals (when their intention is actually to update the binary that a system canister is running). I'm not suggesting otherwise.

> Which leads me to think itâ€™s better to normalize the process which we will need to safeguard the system, than rely on it not happening and being a rare event which catches people off guard.

I respect where you're coming from. I'd just like to make sure that I'm clear on this philosophy if that's okay. You're suggesting keeping the potential attack surface of proposals for NNS canister **configuration updates** unnecessarily large, intentionally, to keep the community on it's toes and train greater due diligence?

<details>
<summary>Here's a slightly more detailed description of my concerns</summary>

Unless I'm mistaken, as it stands the configuration update process requires the proposer to build and deploy the canister WASM despite the fact that the WASM hasn't changed (hence why the hashes are the same for the [last two canister upgrades](https://dashboard.internetcomputer.org/canister/vxkom-oyaaa-aaaar-qafda-cai#:~:text=2024%20Internet%20Computer) - 658c5786cf89ce77a0bb3b17fe855c30f00171de0dc946cc463c9f19c348cb5e).

If this type of proposal becomes greater in frequency (which hopefully they will given that the intention is to encourage community participation), can't you imagine members of the community getting used to the fact that the WASM doesn't change for these types of proposals and just eyeballing it (visually checking that the first few and last few digits look right), and spending the majority of their time reviewing the more salient aspects of the proposal?

There's a low chance of the first few and last few digits in the hash matching by chance. But a bad actor could code any sort of nefarious behaviour into the WASM, then tweak the binary at a point that strategically doesn't alter the intended behaviour, and keep computing the SHA2-256 until a handful of the first few and last few digits look close enough to the one that the community is expecting (the longer they're willing to go at this, the more similar they can make the hash look).

> Rest assured that DFINITY will always be reviewing any SCM proposals

Wouldn't it be better to not rely on that?

</details>

If a new NNS function that has a smaller blast radius is out of the question, why not make the WASM and hash in SCM proposals optional? When they're not provided, then the proposal just restarts the canister and passes along the payload.

This would be much easier to verify correctness of the proposal and reduces potential for reviewer fatigue (if there are to be many of these proposals in the future). Probably more importantly, it means the proposal will no longer misleadingly indicate that it's updating the WASM when it's not (with terms like '**New** compressed Wasm hash', and '**Upgrade** Nns Canister: ... **to wasm** with hash ...' when in fact that's not at all what the proposal is really about).

Thanks for taking the time to read this if you got this far ðŸ™‚

-------------------------

Lorimer | 2024-06-07 14:12:11 UTC | #24

I think that security philosophy would be easier to accept if it were explicitly put to community, and agreed that the VP majority would like to avoid slices of [*Swiss* cheese](https://en.wikipedia.org/wiki/Swiss_cheese_model) in the security sandwich (even when the cheese is cheap and there's a clear space for it).

-------------------------

nolma | 2024-07-29 00:18:58 UTC | #25

Is there a good way to compile just the minter canister? It looks like source code requires that you install dependencies at the top level for ALL ic rust projects.
It would be great to have a "here's how to deploy your own ERC-20 to the ICP" guide that shows just how to compile that canister.
I'm running into a build error for "ic/rs/canister_sandbox". I feel I shouldn't have to make things compile for *all* rust canisters and be able to build and deploy just the 1 I want.

-------------------------

Pete | 2024-07-31 12:01:01 UTC | #26

I largely agree with your suggestion. It would indeed be much cleaner if a proposal which only updates args and does not touch the wasm would not require a copy of the wasm to also be submitted.

There's probably a few components which would need to be updated to make that change. Something for the team to definitely consider doing though.

-------------------------

nolma | 2024-07-31 12:05:45 UTC | #27

I found https://github.com/dfinity/erc20-icp/tree/main/ic which looks like an easier way to do tokens. If I understand this project, it's a way to more an erc 20 to and from IC. On IC it uses the ICRC-1 standard. Has anyone used this?

-------------------------

Stephen-Kimoi | 2024-08-14 15:31:02 UTC | #28

I am trying to interact with ckSepoliaUSDC from my rust canister but getting a few errors while performing a withdrawal of ckSepoliaUSDC to USDC

The first step is approving ckETH minter to burn some of the user's ckETH tokens as payment, this function is failing with the error I have insufficient balance. And yet I have minted roughly 0.1 ckETH tokens to my principal ID

This is what my function looks like: 
```rust 
const CKETH_MINTER: &str = "jzenf-aiaaa-aaaar-qaa7q-cai";

#[ic_cdk::update] 
async fn approve_cketh_burning(user_principal: Principal, amount: Nat) -> ICRC2ApproveResult {
    let from_subaccount = Subaccount::from(user_principal);
    
    // Use the ckETH minter as the spender
    let minter_principal = Principal::from_text(CKETH_MINTER).expect("Invalid minter principal");
    let spender = ICRCAccount::new(minter_principal, None);

    let approve_args = ICRC2ApproveArgs {
        from_subaccount: Some(from_subaccount), 
        spender, 
        amount, 
        expected_allowance: None,
        expires_at: None,
        fee: None, 
        created_at_time: None, 
        memo: None 
    }; 

    InterCall::from(CKETH_LEDGER).call(
        "icrc2_approve", 
        approve_args, 
        CallCycles::NoPay
    )
    .await 
    .unwrap()
}
```
This is the error I am getting when I try to approve burning of ckETH tokens from this particular canister ID: ``4p7ji-qaaaa-aaaal-qjabq-cai`` 
![image|690x147](upload://szRemZnXzTPNPgIeHQ6KnlGtI7S.png)

The second error I am getting is when I try to call ``icrc2_approve`` function on the ``USDC_LEDGER`` to ``approve the minter`` to ``burn`` some of the ``user's ckUSDC`` tokens.
(I am not sure whether I am doing this the right way)

This is what my function looks like: 
```rust 
const CKETH_MINTER: &str = "jzenf-aiaaa-aaaar-qaa7q-cai";
const USDC_LEDGER: &str = "2s5qh-7aaaa-aaaar-qadya-cai"; 

#[ic_cdk::update]
async fn approve_usdc_burning(user_principal: Principal, amount: Nat) -> ICRC2ApproveResult {
    let from_subaccount = Subaccount::from(user_principal);
    
    // Convert minter Principal to ICRCAccount
    let minter_principal = Principal::from_text(CKETH_MINTER).expect("Invalid minter principal");
    let spender = ICRCAccount::new(minter_principal, None);

    let approve_args = ICRC2ApproveArgs {
        from_subaccount: Some(from_subaccount),
        spender,
        amount,
        expected_allowance: None,
        expires_at: None,
        fee: None,
        created_at_time: None,
        memo: None
    };

    InterCall::from(USDC_LEDGER).call(
        "icrc2_approve",
        approve_args,
        CallCycles::NoPay
    )
    .await
    .unwrap()
}
```

But when calling the function I am getting the error: 
```
Err` value: CallError("icrc2_approve", "IC0536: Error from Canister 2s5qh-7aaaa-aaaar-qadya-cai: Canister has no update method 'icrc2_approve'
``` 
![image|690x263](upload://qwTc86xG8XKTcS1GY9m2evONcQQ.png)

The final error I am getting is when I try to get the ``balance`` of ckSepoliaUSDC on my principal ID
This is how I've implemented the functionality 
```rust 
const USDC_LEDGER: &str = "2s5qh-7aaaa-aaaar-qadya-cai"; 

#[ic_cdk::update]
async fn balance(principal_id: Principal) -> Nat {
  let account = ICRCAccount::new(principal_id, None);

  ICRC1::from(USDC_LEDGER).balance_of(account).await.unwrap()
}
```

But I am getting the error:
```rust 
`Err` value: CallError("icrc1_balance_of", "IC0536: Error from Canister 2s5qh-7aaaa-aaaar-qadya-cai: Canister has no update method 'icrc1_balance_of'
```
![image|690x241](upload://1KklOGuLNoIWkrUPJRxM43Ji5iO.png)
 
I would really appreciate if I got some assistance on this

-------------------------

b3hr4d | 2024-08-16 06:10:43 UTC | #29

[quote="Stephen-Kimoi, post:28, topic:31109"]
`2s5qh-7aaaa-aaaar-qadya-cai"; `
[/quote]

This is the wrong canister id for test usdc, you can get the canister ids from ic dashboard or from [b3forge](https://sehgq-cqaaa-aaaap-ahc4q-cai.icp0.io/).

-------------------------

Stephen-Kimoi | 2024-08-16 22:10:05 UTC | #30

This is impressive, thank you! 

Is it open source?

-------------------------

b3hr4d | 2024-08-17 06:05:31 UTC | #31

Thank you, Not yet, but i did use [ic-reactor](https://github.com/B3Pay/ic-reactor) to creating it.

-------------------------


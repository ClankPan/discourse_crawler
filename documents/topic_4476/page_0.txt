ICVF | 2021-05-28 07:24:59 UTC | #1

Anyone working on alternate (other than IC's Internet Identity) methods of user authentication to be deployed in canister, such as email-based or sms-based.... any experiences to share?

-------------------------

Pwoseidon | 2021-05-28 07:26:38 UTC | #2

Ya is anyone working on a way to access the portal and NNS on a browser without biometric or hardware key?

-------------------------

senior.joinu | 2021-05-28 12:38:29 UTC | #3

As far as I know, recently there was an update. Now you can manage your seed phrase by yourself (like on ethereum), without having to rely on any hardware solution.

-------------------------

hackape | 2021-05-28 12:53:10 UTC | #4

It's also possible to use Ed25519 keypair to gen a self-authenticating principal in browser. The trick involves this lib:

```
import { Ed25519KeyIdentity } from '@dfinity/identity'
```

This is also the principal scheme used by `dfx` tool.

-------------------------

neeboo | 2021-05-28 13:04:31 UTC | #5

yes. working on it. With Metamask/wallectconnect as well

-------------------------

ICVF | 2021-05-28 13:26:39 UTC | #6

nice... are you also looking to have an Auth Oracle that would solve for Auth by connecting to sign-in options such as Google, Facebook, etc that have traditionally been used by developers?

-------------------------

Pwoseidon | 2021-05-28 16:14:02 UTC | #7

I just tried using the recovery phrase to login via my laptop and it didn't work =[
I tried on 3 different browsers =[

But hopefully one of the options below will work!

-------------------------

Pwoseidon | 2021-05-28 16:18:48 UTC | #8

Oh wow, thank you so much!

I'm fairly new to coding--I'm only fluent at using R for statistics--so I'll have to look into figuring out this option.

Found this site, which might be of help!
https://www.unixtutorial.org/how-to-generate-ed25519-ssh-key/


Thank you again!

-------------------------

Pwoseidon | 2021-05-28 16:20:28 UTC | #9

@neeboo Oh that would be brilliant! I'll keep an eye out for that!!

@ICVF that would be helpful too actually! I just dont have a smart key so anything that works would be great

-------------------------

jzxchiang | 2021-07-21 03:46:38 UTC | #10

OK I've been thinking about this today. For reference, I'm building a native mobile app (in React Native) that talks to an IC canister backend.

Can someone tell me whether this would work, i.e. is secure? It's a traditional email-password login flow instead of the Internet Identity flow.

1. End user enters email and password in mobile app, and submits.
2. Mobile app tries logging in using Firebase Auth (via their React Native SDK). If credentials are accepted, Firebase Auth returns a JWT ID token.
3. Mobile app calls a `login` method on a custom IC canister, passing both the JWT and the Firebase Auth public key as arguments [1]. The identity (containing the principal) used to authenticate the request will be generated by the mobile app using `Ed25519KeyIdentity.generate()` and saved in local (mobile) storage.
4. The canister validates the signature on the JWT using the Firebase public key [2], and then retrieves the `uid` (i.e. unique ID for the user). It saves the mapping between the principal in the request and the `uid` in some Map variable.
5. Whenever the mobile app wants to do something on behalf of the logged in user, it no longer needs to pass the JWT and simply makes the request to the canister with the same identity/principal it generated in step 3. Basically, it's a session ID.
6. When the end user logs out, the mobile app calls `signOut` using the Firebase SDK. It then calls some `logout` method on the canister, which deletes the mapping from principal to `uid`. Lastly, it removes the identity from local storage.

The alternative is to completely do away with all IC identities/principals, use `AnonymousIdentity` for all canister-bound requests, and pass the JWT ID token to authenticate every should-be-authenticated request. The benefit is that it's stateless, since the canister no longer needs to store any mapping and therefore we can get rid of the `login` and `logout` canister methods. Also, the Firebase SDK will automatically handle persisting tokens to local storage.

The drawback is that if someone happens to steal the ID token (even over HTTPS or some other way), then they have complete access to that end user's info (until the token expires), whereas stealing a principal doesn't matter if you can't steal the associated private key. All they could do is replay the exact same request. Also, there's probably a slightly performance drawback with validating JWT on every requestâ€”but on the other hand, you don't need to validate the `sender_sig` on every request since we are using the anonymous principal.

I'm actually leaning towards the alternative option... Please tell me if I'm thinking about this correctly or am missing an obvious security risk.

[1] The public key is deliberately passed to the canister, because otherwise it would need to rely on an oracle to fetch the public key from an external Firebase URL. Instead, the mobile app client can fetch it.
[2] There's an open-source Rust SDK for JWTs, but none for Motoko.

-------------------------

GLdev | 2021-07-21 06:14:37 UTC | #11

There's also a team that received a grant from dfinity for building an alternative to the II service. Reading through their presentation I got the feeling that they plan to allow users to create an identity on their service with "traditional" flows (e.g. e-mail).

-------------------------

stephenandrews | 2021-07-21 11:11:44 UTC | #12

Yeah mate that's how I would do it for if I were to use an external service as an authenticator, i.e. trusted service.

Pros and cons for both - I'd personally go with the session key idea, generating a ed key locally and submitting it once with the jwt. Would make it easier to just deal with Principals, and could also work cross canisters. E.g. you could use the login canister as a way to authenticate on the IC. When you submit the jwt, it updates the Principal attached to a user account with a given user ID.

You can then query external canisters that support this authentication method with your user ID. The canister can make a call to the login canister to ensure that the principal you are using actually is authorized to act as the user.

The jwt could technically be intercepted and used by someone else during the initial setup, but it wouldn't be hard to get around this

-------------------------

jzxchiang | 2021-07-21 17:19:07 UTC | #13

[quote="stephenandrews, post:12, topic:4476"]
You can then query external canisters
[/quote]

The idea with the login <> external canisters is actually really interesting. Didn't think of that, since I was thinking of having a single frontend canister accept all client requests, but maybe that doesn't scale?

Can you clarify how you would get around the JWT being intercepted? I was planning on just relying on HTTPS for that.

One issue with this whole principal to user id thing I'm concerned about is whether I need a TTL for this mapping. For example, JWT ID (and access) tokens have expiry times. Even the `DelegatedIdentity` that the Internet Identity passes back to the client to use to authenticate with the IC has an expiration. A normal non-delegated `Ed25519KeyIdentity` doesn't though... and I'll be persisting the identity in local storage so maybe that's a risk where it can get stolen?

-------------------------

jzxchiang | 2021-07-21 17:24:03 UTC | #14

Do you remember what team this was, or do you have a link to their presentation? Would definitely be interested in talking.

-------------------------

stephenandrews | 2021-07-21 17:53:34 UTC | #15

To make the JWT process more secure, you could do a 2 step approach:

1) User generates a hash of the JWT and must submit it first along with the Principal to be linked
2) User waits until this has been committed to the chain
3) User then submits actual JWT, which is then linked to the account
4) The canister only allows the JWT hash to be linked with a single account, so if someone were to intercept the JWT at stage 3, and try to submit the hash alongside a different Principal it wouldn't work as the hash is already linked

Yeah expiry times it something that should be added to for sure.

-------------------------

cyaolong | 2021-07-21 18:58:36 UTC | #16

Maybe you are referring this?
[AstroX: building Web3 Identity Service for 8 billion users | by AstroX | Jun, 2021 | Medium](https://astrox.medium.com/astrox-network-building-web3-identity-service-for-8-billion-users-8cbc8ebae78b)

-------------------------

jzxchiang | 2021-07-21 20:45:22 UTC | #17

Fascinating! A crash course in security. Thanks, this makes sense.

-------------------------

GLdev | 2021-07-22 05:06:22 UTC | #18

Yeah, astrox was the team that I read about.

-------------------------

ArjaanBuijk | 2022-03-18 20:43:42 UTC | #19

@jzxchiang ,
You mention that there is an open source Rust library for JWT.

Which one is that?

Have you tried to deploy it to an IC canister?

Background of my question is that I am working on a flow where the user logs in with Internet Identity, and I then want to call an IC canister to create a JWT, which I then  use to make an authenficated call to an off IC back end service. The JWT canister and the off IC backend service both know the secret jwt key .

That way, all can be done with just II, and no need to also have the user do a traditional login with user/password.

-------------------------

d3w3 | 2022-06-27 11:18:09 UTC | #20

That's exactly what I've currently in mind. I'd like to hear how you get with that idea?

-------------------------

ArjaanBuijk | 2022-07-03 19:44:00 UTC | #21

Maybe this will help you.

I have open sourced my project where I implemented it by calculating a JWT in Python, pyJwt, using an off IC Django API. It is bit elaborate, but it does nicely secure things using II.

- The live deployment of my project can be found at [https://web3r.chat](https://web3r.chat/)

- The full application consists of 3 GitHub repositories:

1. [dapp-0](https://github.com/web3r-chat/dapp-0)
2. [dapp-0-django](https://github.com/web3r-chat/dapp-0-django)
3. [dapp-0-bot](https://github.com/web3r-chat/dapp-0-bot)

I am considering to sponsor a bounty with icdevs to for someone to implement the equivalent of pyjwt in Motoko. That would make things more easy.

-------------------------

d3w3 | 2022-07-05 20:44:12 UTC | #22

I appreciate your solution very much, and please try to get it listed in https://github.com/dfinity/awesome-dfinity

-------------------------

domwoe | 2022-07-06 12:14:54 UTC | #23

Just a note:

With the upcoming threshold ECDSA feature, you can also issue JWTs using asymmetric cryptography without having to store secrets in a canister.

If anyone is interested in implementing tooling and an example application please talk to me.

-------------------------

inviscidpixels | 2022-07-29 18:31:22 UTC | #24

Am interested, lot of vital application for on-boarding with this kind of functionality.

-------------------------

kpeacock | 2022-08-01 21:03:47 UTC | #25

I think that would be a really helpful example - threshold ECDSA is going to be a really versatile feature, and we should be hyping it up more for general secret functionality

-------------------------

ArjaanBuijk | 2022-09-08 01:38:31 UTC | #26

@domwoe ,
I am very interested to learn how one could get a JWT.

It would simplify my app architecture a lot.

Where can I learn more about it?

-------------------------

domwoe | 2022-09-08 06:37:01 UTC | #27

Hey @ArjaanBuijk,

I'd love to get more input on your use case.

Do you want to use a canister to issue tokens that can be used to access resources outside the Internet Computer?

-------------------------

ArjaanBuijk | 2022-09-08 21:58:21 UTC | #28

@domwoe 
Yes, exactly!

I am using a chatbot framework that runs outside the IC, in a traditional cloud. Long term my goal is to run it on the IC, but that will be long term. 

My front end is serbed from a canister and it uses Internet Identity as the login mechanism. After login, he frontend then connects to the off IC chatbot over socketio, protected by a JWT token.

Ideally, as part of the Internet Identity login flow, an asymmetric JWT would be generated in the canister and returned to the frontend, which then uses that to authenticate with the chatbot. 

Currently, I hacked together an elaborate procedure where the front first logs in with II, then calls an api of an off IC python web server to generate the JWT. The python webserver calls a canister to confirm that a principal was properly logged in with II, and only if that is the case, will it return a JWT.  Currently I am using a symmetric JWT and store a secret with the python server that generates the JWT and with the chatbot that validates the JWT.

That off IC python server and complicated logic, just to generate a JWT can be removed if the JWT could be created by the canister during II login.

Please let me know if my description is clear.

-------------------------

domwoe | 2022-09-13 06:06:57 UTC | #29

Thank you for the description.

I think your architecture is not a bad choice. 

You could also verify the delegation from II directly on the chatbot server and just create a session for the user.

tECDSA signatures for access tokens are probably too costly/resource intensive (currently a subnet can do about 1 sig/s).  Nevertheless, I created a small PoC that creates different types of JWTs on the IC, if you're curious: https://github.com/domwoe/jwt_issuer_poc

-------------------------

ArjaanBuijk | 2022-09-15 03:03:03 UTC | #30

Thank you for that feedback and the example. 

I like your idea to  verify the delegation from II directly on the chatbot server and just create a session for the user. I am going to investigate that option.

-------------------------

domwoe | 2022-09-15 05:44:46 UTC | #31

The complication is that you'd need to verify a canister signature. 

Here's the respective code in the replica: https://github.com/dfinity/ic/blob/4c6487b6c0bd53fe1973c7d88cc4d30b90e1dd35/rs/crypto/internal/crypto_lib/basic_sig/iccsa/src/api.rs#L51

cc: @rckprtr

-------------------------


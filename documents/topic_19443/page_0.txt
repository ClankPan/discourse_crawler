skilesare | 2024-02-12 09:24:50 UTC | #1

# ICDevs.org DateTime Library - #53

## Current Status: Discussion

* Discussion (03/24/2023)
* Ratification: (TBD)
* Open for application: (TBD)
* Assigned (TBD)
* In Review 
* Closed 

[Official Link](https://icdevs.org/bounties/2023/03/24/53-Motoko-DateTime.html)

## Bounty Details

* Bounty Amount: $10,000 USD of ICP at award date.
* ICDevs.org Bounty Acceleration: For each 1 ICP sent to 6e8afebab59f703356e189297e3f49fbe18ace5150ccc43f74f30ceb3f6b5ece, ICDevs.org will add .25 ICP to this issue and .75 ICP to fund other ICDevs.org initiatives.
* Developer Type: Individual
* Opened: TBD
* Time Commitment: Months
* Project Type: DateTime Library for Motoko
* Experience Type: Expert - DateTime and Motoko

## Description

The proposed project aims to create an updated and fully-featured datetime library for Motoko. The current datetime library in Motoko is basic and does not consider time zones, which can lead to inaccuracies in date and time calculations. 

The new datetime library will be designed to be comprehensive and feature-rich, with support for time zones, date and time formatting, and a range of date and time calculations including duration arithmetic. The library will also include support for leap years and daylight saving time, which are important considerations in many applications.

To create this new datetime library, the project will require anf experienced developers who is proficient in Motoko and that has a strong understanding of date and time calculations. The dev will work closely with the Motoko community to ensure that the new library meets the needs of developers working on the Internet Computer.

There are several popular open source DateTime frameworks written in other languages such as Luxon in Javascript, Moment in Javascript and Joda-Time in Java. The new datetime library should be designed taking the best practices and learnings from these libraries while incorporating the unique features and requirements of Motoko.

Overall, the new datetime library will provide a valuable resource for developers working on the Internet Computer, enabling them to create more accurate and reliable applications that consider time zones and other important date and time factors.

The solution should include a significant test suite similar to the test suite of the libraries mentioned above.

This bounty gives the opportunity to

* learn about Motoko
* learn about DateTime programming


## To apply for this bounty you should:

* Include links to previous work building web applications and any other open-source contributions (i.e., your Github).
* Provide a brief overview of how you will complete the task. This can include things like which dependencies you will use, how you will make it self-contained, the sacrifices you would have to make to achieve that, or how you will make it simple. Anything that can convince us you are taking a thoughtful and expert approach to this design.
* Give an estimated timeline on completing the task.
* Post your application text to the Bounty Thread

## Selection Process

The ICDevs.org developer's advisors will propose a vote to award the bounty and the Developer Advisors will vote.

## Bounty Completion

Please keep your ongoing code in a public repository(fork or branch is ok). Please provide regular (at least weekly) updates.  Code commits count as updates if you link to your branch/fork from the bounty thread.  We just need to be able to see that you are making progress.

The balance of the bounty will be paid out at completion.

Once you have finished, please alert the dev forum thread that you have completed work and where we can find that work.  We will review and award the bounty reward if the terms have been met.  If there is any coordination work(like a pull request) or additional documentation needed we will inform you of what is needed before we can award the reward.

## Bounty Abandonment and Re-awarding

If you cease work on the bounty for a prolonged(at the Developer Advisory Board's discretion) or if the quality of work degrades to the point that we think someone else should be working on the bounty we may re-award it.  We will be transparent about this and try to work with you to push through and complete the project, but sometimes, it may be necessary to move on or to augment your contribution with another resource which would result in a split bounty.

## Funding

The bounty was generously funded by the DFINITY Foundation. If you would like to turbocharge this bounty you can seed additional donations of ICP to 6e8afebab59f703356e189297e3f49fbe18ace5150ccc43f74f30ceb3f6b5ece.  ICDevs will add .25 for every 1 token donated to the bounty.  All donations will be tax deductible for US Citizens and Corporations.  If you send a donation and need a donation receipt, please email the hash of your donation transaction, physical address, and name to donations@icdevs.org.  More information about how you can contribute can be found at our [donations page](https://icdevs.org/donations.html).


## FYI: General Bounty Process

### Discussion

The draft bounty is posted to the DFINITY developer's forum for discussion

### Ratification: (01/09/2023)

The developer advisor's board will propose a bounty be ratified and a vote will take place to ratify the bounty.  Until a bounty is ratified by the Dev it hasn't been officially adopted. Please take this into consideration if you are considering starting early.

### Open for application

Developers can submit applications to the Dev Forum post.  The council will consider these as they come in and propose a vote to award the bounty to one of the applicants.  If you would like to apply anonymously you can send an email to austin at icdevs dot org or sending a PM on the dev forum.

### Assigned

A developer is currently working on this bounty, you are free to contribute, but any splitting of the award will need to be discussed with the currently assigned developer.

### In Review

The Dev Council is reviewing the submission

### Awarded

The award has been given and the bounty is closed.


[Other ICDevs.org Bounties](https://icdevs.org/bounties.html)

-------------------------

Gekctek | 2023-04-16 21:31:07 UTC | #2

I think I might want to tackle this one, if you guys will have me back. I have done a weird amount of DateTime and Timezone C# programming work for a previous job that should help me out here. Im playing with a few ideas on what the datetime/time types are going to look like but I came up with a list of features to support. Can add or change any if anyone has thoughts.

```md
# Creation:

- Create DateTime for the current date and time
- Create DateTime from a specific date and time
- Create DateTime from various formats (e.g., ISO 8601, Unix timestamp)
- Handle timezone conversion to UTC and back and daylight savings time
- Validate date and time components (e.g., correct number of days in a month, valid hours, minutes, and seconds)

# Formatting:

- Format DateTime into human-readable strings in various formats (e.g., ISO 8601, RFC 2822, Unix timestamp)
  -? Format DateTime according to locale-specific rules and conventions
  -? Customize formatting with user-defined patterns

# Date and Time Manipulation:

- Add or subtract durations (e.g., days, hours, minutes, seconds)
- Set specific date and time components (e.g., year, month, day)
- Compare DateTimes for equality or order
- Truncate/Round DateTimes to a specific unit (e.g., remove minutes and seconds, leaving only hours)

# TimeSpans:

- Represent stretches of time as TimeSpans (e.g., 2 hours, 30 minutes)
- Perform arithmetic operations with TimeSpans (e.g., add, subtract)
- Calculate the difference between two DateTime objects as a TimeSpan

# Calendar Support:

- Retrieve calendar-related information (e.g., week number, day of the week)
- Perform calendar-specific calculations (e.g., add or subtract months, years)
- Identify leap years and handle leap year-specific calculations

```

-------------------------

quint | 2023-04-17 08:51:42 UTC | #3

Minimal DateTime implementation (no manipulation, etc.):
https://github.com/aviate-labs/date.mo

-------------------------

Safik | 2023-04-20 10:23:19 UTC | #4

It may come in handy
https://github.com/ByronBecker/motoko-datetime

-------------------------

Gekctek | 2023-04-20 19:08:07 UTC | #5

Heres a question. Something I havent really settled on with Motoko yet is 
- the more functional/record + functions approach
vs 
- the more object oriented approach with having a DateTime object with methods

Any thoughts on which way to go down. 
With motoko, I feel like I should be doing more of the data + functions approach but there is some ease of use with the object oriented approach

-------------------------

icme | 2023-04-20 21:44:58 UTC | #6

Here’s another simple library if this helps at all.

https://github.com/ByronBecker/motoko-datetime


I’m in favor of an object oriented approach that can produce its internal state if “stable” data is necessary. Then, you can pass that data back into the class constructor or function if needed (i.e. `fromDateTime()` )

-------------------------

Gekctek | 2023-05-17 01:16:16 UTC | #7

Just as an update, ive been working on this on the side but I have just been waiting for approval to give this priority. 
Thats all, just wanted to check in.

-------------------------

skilesare | 2023-05-17 03:30:16 UTC | #8

What approvals do you need? You should be good to go on our end.

-------------------------

Gekctek | 2023-05-17 03:44:59 UTC | #9

:man_shrugging: i didn't see any confirmation and it still says open

What is the process these days for approval/review, do you guys use a DAO/group consensus or is it all you @skilesare 

I'll stay putting priority towards it and give weekly updates

-------------------------

skilesare | 2023-05-17 10:29:39 UTC | #10

Ahh...you're right...I thought I'd submitted it to the board, but I haven't done so yet...I though it was in the last batch.  I'll do it asap, but as you've done other bounties I don't expect anyone to object.

-------------------------

Gekctek | 2023-05-21 02:06:23 UTC | #11

UPDATE:

Im just going to put in here some design decisions I made which i encourage people to give me feedback during the process.
Here is what I got so far

The library is split into 3 modules/types for dates:
  - `Components` - the year, month, day, etc... of a date as a record type. This will be used as a data structure to create datetimes or get from datetimes. If converted into a datetime with a timezone, then the 'timestamp'/utc time will be different for each unique timezone.
   ```motoko
  public type Components = {
        year : Int;
        month : Nat;
        day : Nat;
        hour : Nat;
        minute : Nat;
        nanosecond : Nat;
  };
   ```
   I went with the 'nanosecond' vs the normal 'second' or mixing different types of seconds. Open to critiques but it seems to work well this way.
I use a `isValid(components : Components) : Bool` to make sure that the combination of values are valid since there is no restrictions to the type.

- `DateTime` - The class that holds a UTC/timestamp representation of a datetime. It will have all the normal functionality like adding, conversions to other formats, comparisons, and getting/calculating of datetime information.
It takes in nanoseconds in the constructor
I went with `DateTime` having no timezones because from my experience, if you dont need timezones, then they only get in the way an complicate things. Rather another class will be for timezones with datetimes
- `DateTimeWithTZ` - (Name is a work in progress) The `DateTimeWithTZ` is a class with very similar functionality to DateTime, but the constrcutor and functionality handles timezone data.
The constructor takes in `Components` and a timezone (could be nanoseconds but I found that it might be more? clear this way and there might need to be an initial conversion, but I dont have strong thoughts)
TimeZones currently look like this:
```motoko

    public type TimeZone = {
        #fixed : FixedTimeZone;
        #dynamic : DynamicTimeZone;
    };

    public type DynamicTimeZone = {
        getOffsetSeconds : (components : Components) -> Int;
    };

    public type FixedTimeZone = {
        #seconds : Int;
        #hoursAndMinutes : (Int, Nat);
    };
```
Where a timezone could be fixed or by dynamic. Dynamic would be a function that would get the fixed timezone value at a certain datetime. 
My goal is to have a IANA implementation of this that is optional where someone could use the IANA timezones at the cost of size of the database data. Im not sure exactly how to approach the splitting up of the data if someone wants the smallest possible library and get what they need and not have it be tedious. Any thoughts appreciated about this.
I havent yet even tried to tackle the parsing of the logic of IANA data but Im assuming that is the way we want to go

-------------------------

icme | 2023-05-21 03:25:04 UTC | #12

[quote="Gekctek, post:11, topic:19443"]
```
public type Components = {
     year : Int;
     month : Nat;
     day : Nat;
     hour : Nat;
     minute : Nat;
     nanosecond : Nat;
};
```
[/quote]

If this is meant to work with time stamps received from external clients or sending data to other clients, milliseconds is a bit more standard. Maybe keep nanos, but add milliseconds (and nanos is the remainder).



[quote="Gekctek, post:11, topic:19443"]
Dynamic would be a function that would get the fixed timezone value at a certain datetime.
[/quote]


[quote="Gekctek, post:11, topic:19443"]
```
public type DynamicTimeZone = {
        getOffsetSeconds : (components : Components) -> Int;
    };
```
[/quote]

Where does the tz come into play in this function here, and why does this return an Int?

I guess the confusing part is the TZ in the naming, but there’s no reference to a time zone in the parameters passed in.

-------------------------

Gekctek | 2023-05-21 03:58:19 UTC | #13

The idea is that a locales timezone is really just a certain offset on a certain date that can change overtime due to daylights savings or tweaks the governments decide to make for any reason. So this could be implemented by some IANA database code where it would determine the offset given a datetime.

Ya i need to rethink the whole area of timezone naming. 
`getTimeZoneOffset` or `getTimeZoneOffsetSeconds`?

-------------------------

icme | 2023-05-21 04:20:04 UTC | #14

Just spitballing here - I like the idea of

```
func componentsToMillisSinceEpoch(components: Components, tzinfo: TzInfo) -> Int;
```
or

```
type Offset = Int; // relative to UTC, -12 to +12? Or an enum of #m12 to #p12

func componentsToMillisSinceEpoch(components: Components, offset: Offset) -> Int;
```


Then if you have DateTime as:

```
public type DateTime = {
  components : Components;
  offset : Int // relative to UTC, -12 to +12? Or an enum of #m12 to #p12
};
```
`offset` remains the internal representation, and you can layer whatever text TZ/region sugar on top.

Also, unsolicited advice, but I'm a fan of chain style syntax like I did for [motoko-color](https://github.com/ByronBecker/motoko-color), where you preserve the initial DateTime but can immutably generate modified copies easily. Not sure how efficient this is though :sweat_smile:

-------------------------

Gekctek | 2023-05-21 16:58:54 UTC | #15

The problem is that timezones != offset which is the need of the dynamic timezone. The `getOffsetSeconds` gets the seconds of what the offset is at the specified 'timezone agnostic datetime' (Components). So the offset would have to be an Int since the timezones are really determined by the seconds off it is from UTC even though most are divisible by hours. Look back before 1900 and no one is in sync like Rangoon before 1920 was +6:24:47 which makes my life just great lol

More like this? with good documentation. Or I could call it a `TimeZoneLocale` or something 

 if the components put in are before 1920, then i get out the seconds equivalent of `+6:24:47`
```
    public type Seconds = Int;
    public type DynamicTimeZone = {
        getOffset: (components : Components) -> Seconds;
    };
```

Big fan of the fluent/chain style. Used it a lot in my C# work, ill take a look. I think i am doing that somewhat already since I create a new DateTime object after a modification.

-------------------------

icme | 2023-05-22 04:07:48 UTC | #16

[quote="Gekctek, post:15, topic:19443"]
Look back before 1900 and no one is in sync like Rangoon before 1920 was +6:24:47 which makes my life just great lol
[/quote]

For this reason it might be nice to have the tz/offset be a variant, so you can add and specify the exact tz/offset you want (`#pst, #edt, #cet, #minus7, #plus5`), and even allow a custom `#customOffset: Int` where the developer can provide that hour/seconds offset and dig their own grave :rofl:

Most of the time though, the developer will know the TZ they're looking for, and you can always add new variants as people request them.

I've never written a datetime library though, so again...take all this with a grain of salt.

Maybe @claudio, @kentosugama, and @rvanasa have some better input :slight_smile:

-------------------------

Gekctek | 2023-05-22 22:19:19 UTC | #17

Ya, i would say my current implementation is more technical and less user friendly. Ill probably do the predefined offset and custom like you suggest or if i can make it easy enough and small enough I was thinking about doing something that looks like `DateTimeWithTZ(components, TimeZone.Locale("America/Los_Angeles")` or `DateTimeWithTZ(components, TimeZone.Offset(-8))`

-------------------------

Gekctek | 2023-05-22 22:21:34 UTC | #18

Any thoughts on `LocalDateTime`/`LocalizedDateTime` vs `DateTimeWithTZ`?

-------------------------

quint | 2023-05-23 08:39:28 UTC | #19

Is there a particular justification for the inclusion of timezones? Given that backend services operate globally and are not heavily reliant on the concept of timezones, their significance appears to be limited. Conversely, the client operates within a specific timezone, rendering the need for extensive timezone support less impactful. Therefore, I fail to perceive significant additional value in accommodating timezones, to be honest.

-------------------------

skilesare | 2023-05-23 11:30:38 UTC | #20

The justification is to allow for moving beyond just backend services. For motoko to grow we need to be able to write all kinds of software. (https://forum.dfinity.org/t/completed-icdevs-org-bounty-34-wasmer-motoko-10-000/17887)

Right now you don't write front end code in motoko, but that doesn't mean you can't.

The most direct use case: If you wanted to write a bbs with @kpeacock 's express like framework where the user can select their timezone, the server would need to format the date on posts if you were trying to make a pure html site.

-------------------------

Gekctek | 2023-05-23 14:26:08 UTC | #21

I'm hoping to at least split up the repo into a couple packages so the timezone part/bloat is optional

-------------------------

icaten | 2023-05-26 18:33:42 UTC | #22

Just an aside, great call on iterating interactively.

-------------------------

Gekctek | 2023-06-05 18:07:08 UTC | #23

Missed last week but not too much to show. Ill put my current API here for anyone to comment on/make suggestions. This is not anything final, just what I have so far.


Types:
```

    public type Duration = {
        #nanoseconds : Int;
        #milliseconds : Int;
        #seconds : Int;
        #minutes : Int;
        #hours : Int;
        #days : Int;
        #weeks : Int;
        #months : Int;
        #years : Int;
    };

    public type Components = {
        year : Int;
        month : Nat;
        day : Nat;
        hour : Nat;
        minute : Nat;
        nanosecond : Nat;
    };

    public type TextFormat = {
        #iso8601;
    };

    public type TimeZoneDescriptor = {
        #unspecified;
        #utc;
        #hoursAndMinutes : (Int, Nat);
    };

    public type TimeZone = {
        #fixed : FixedTimeZone;
        #dynamic : DynamicTimeZone;
    };

    public type DynamicTimeZone = {
        getOffsetSeconds : (components : Components) -> Int;
    };

    public type FixedTimeZone = {
        #seconds : Int;
        #hoursAndMinutes : (Int, Nat);
    };
```

Module: Components
```

    public type FromTextResult = {
        components : Components;
        timeZoneDescriptor : TimeZoneDescriptor;
    };

    /// Returns the the epoch (1970-01-01T00:00:00Z) in component form
    ///
    /// ```motoko include=import
    /// let epoch : Components.Components = Components.epoch();
    /// ```
    public func epoch() : Components ;

    /// Compares two components, returning the order between them.
    /// Will return null if either of the components are invalid
    ///
    /// ```motoko include=import
    /// let c1 : Components.Components = {year = 2020; month = 1; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let c2 : Components.Components = {year = 2020; month = 2; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let ?order : ?Order.Order = Components.compare(c1, c2) else return #error("One or both components are invalid");
    /// ```
    public func compare(c1 : Components, c2 : Components) : ?Order.Order;

    /// Compares two components, returning the order between them.
    /// Will trap if either of the components are invalid
    ///
    /// ```motoko include=import
    /// let c1 : Components.Components = {year = 2020; month = 1; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let c2 : Components.Components = {year = 2020; month = 2; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let order : Order.Order = Components.compareOrTrap(c1, c2);
    /// ```
    public func compareOrTrap(c1 : Components, c2 : Components) : Order.Order;

    /// Converts the components to the equivalent UTC time in nanoseconds since the epoch.
    /// Will return null if the components are invalid
    ///
    /// ```motoko include=import
    /// let c : Components.Components = {year = 2020; month = 1; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let ?order : ?Time.Time = Components.toTime(c) else return #error("Components are invalid");
    /// ```
    public func toTime(components : Components) : ?Time.Time;

    /// Converts the UTC time in nanoseconds since the epoch to the equivalent components.
    ///
    /// ```motoko include=import
    /// let components : Components.Components = Components.fromTime(123467890);
    /// ```
    public func fromTime(nanoseconds : Int) : Components;

    /// Checks if the specified components are valid.
    /// Checks that the day is valid for the month and year, and that the time is valid.
    /// Returns true if the components are valid, false otherwise.
    ///
    /// ```motoko include=import
    /// let c : Components.Components = {year = 2020; month = 1; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let isValid : Bool = Components.isValid(c);
    /// ```
    public func isValid(components : Components) : Bool;

    /// Converts datetime components to text in ISO 8601 format (e.g. `2021-01-01T00:00:00.000Z`)
    ///
    /// ```motoko include=import
    /// let c : Components.Components = {year = 2020; month = 1; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let text : Text = Components.toText(c, TimeZone.utc());
    /// ```
    public func toText(components : Components, timeZone : TimeZoneDescriptor) : Text;

    /// Converts datetime components to the specified text format.
    ///
    /// Formats:
    /// - `#iso8601` - ISO 8601 format (e.g. `2021-01-01T00:00:00.000Z`)
    ///
    /// ```motoko include=import
    /// let c : Components.Components = {year = 2020; month = 1; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let text : Text = Components.toTextFormatted(c, #iso8601, TimeZone.utc());
    /// ```
    public func toTextFormatted(components : Components, timeZone : TimeZoneDescriptor, format : InternalTypes.TextFormat) : Text;

    /// Parses a formatted datetime text into components and timezone with the specified format.
    /// Returns null if the text is not a valid formatted datetime
    /// Formats:
    /// - `#iso8601` - ISO 8601 format (e.g. `2021-01-01T00:00:00.000Z`)
    ///
    /// ```motoko include=import
    /// let ?result : ?FromTextResult = Components.fromTextFormatted("2020-01-01T00:00:00Z", #iso8601) else return #error("Invalid datetime text");
    /// ```
    public func fromTextFormatted(text : Text, format : TextFormat) : ?FromTextResult;


    public func addTime(components : Components, nanoseconds : Time.Time) : Components;
```


Module: DateTime
```
    /// Creates an instance of the `DateTime` type from a `Time.Time` value.
    ///
    /// ```motoko include=import
    /// let nowTime : Time.Time = Time.now();
    /// let nowDateTime : DateTime.DateTime = DateTime(time);
    /// ```
    public func DateTime(time : Time.Time) : DateTime = object {
        /// Adds a `Duration` and returns the resulting new `DateTime` value.
        /// Does not modify the current `DateTime` value.
        ///
        /// ```motoko include=import
        /// let now : DateTime.DateTime = DateTime.now();
        /// let fourDays : DateTime.Duration = #days(4);
        /// let fourDaysFromNow : DateTime.DateTime = now.add(fourDays);
        /// ```
        public func add(duration : Duration) : DateTime;


        // TODO rename
        /// Calculates the time difference between this `DateTime` and another `DateTime` value.
        /// Will return a negative value if the other `DateTime` is in the future compared with this `DateTime` value.
        ///
        /// ```motoko include=import
        /// let dateTime : DateTime.DateTime = DateTime.now();
        /// let otherDateTime : DateTime.DateTime = DateTime.fromText("2021-01-01T00:00:00.000Z");
        /// let timeSince : Time.Time = dateTime.timeSince(otherDateTime);
        /// ```
        public func timeSince(other : DateTime) : Time.Time;

        /// Creates a `Time.Time` (nanoseconds since epoch) value from a `DateTime` value.
        ///
        /// ```motoko include=import
        /// let dateTime : DateTime.DateTime = DateTime.now();
        /// let nanoseconds : Time.Time = dateTime.toTime();
        /// ```
        public func toTime() : Time.Time;

        /// Formats the `DateTime` as Text value using the ISO 8601 format (e.g. `2021-01-01T00:00:00.000Z`)
        ///
        /// ```motoko include=import
        /// let dateTime : DateTime.DateTime = DateTime.now();
        /// let dateTimeText : Text = dateTime.toText();
        /// ```
        public func toText() : Text;

        /// Formats the `DateTime` as Text value using the given format.
        ///
        /// Formats:
        /// - `#iso8601` - ISO 8601 format (e.g. `2021-01-01T00:00:00.000Z`)
        ///
        /// ```motoko include=import
        /// let dateTime : DateTime.DateTime = DateTime.now();
        /// let dateTimeText : Text = dateTime.toTextFormatted(#iso8601);
        /// ```
        public func toTextFormatted(format : TextFormat) : Text;

        
        /// Creates a `Components` from a `DateTime` value.
        ///
        /// ```motoko include=import
        /// let datetime : DateTime.DateTime = DateTime.now();
        /// let components : Components.Components = datetime.toComponents();
        /// ```
        public func toComponents() : Components;

        /// Checks if the `DateTime` is in a leap year.
        ///
        /// ```motoko include=import
        /// let datetime : DateTime.DateTime = DateTime.now();
        /// let isInLeapYear : Bool = datetime.isInLeapYear();
        /// ```
        public func isInLeapYear() : Bool;

        /// Compares this `DateTime` with another `DateTime` value.
        ///
        /// ```motoko include=import
        /// let a : DateTime.DateTime = DateTime.fromTime(...);
        /// let b : DateTime.DateTime = DateTime.fromTime(...);
        /// let order : Order.Order = a.compare(b);
        /// ```
        public func compare(other : DateTime) : Order.Order;
        
        /// Checks the equality of this `DateTime` with another `DateTime` value.
        ///
        /// ```motoko include=import
        /// let a : DateTime.DateTime = DateTime.fromTime(...);
        /// let b : DateTime.DateTime = DateTime.fromTime(...);
        /// let areEqual : Bool= a.equal(b);
        /// ```
        public func equal(other : DateTime) : Bool;
    };

    /// Checks the equality of two `DateTime` values.
    ///
    /// ```motoko include=import
    /// let a : DateTime.DateTime = DateTime.fromTime(...);
    /// let b : DateTime.DateTime = DateTime.fromTime(...);
    /// let equal : Bool = DateTime.equal(a, b);
    /// ```
    public func equal(a : DateTime, b : DateTime) : Bool;

    /// Compares two `DateTime` values and returns their order.
    ///
    /// ```motoko include=import
    /// let a : DateTime.DateTime = DateTime.fromTime(...);
    /// let b : DateTime.DateTime = DateTime.fromTime(...);
    /// let order : Order.Order = DateTime.compare(a, b);
    /// ```
    public func compare(a : DateTime, b : DateTime) : Order.Order;

    /// Creates a `DateTime` for the current time
    ///
    /// ```motoko include=import
    /// let now : DateTime.DateTime = DateTime.now();
    /// ```
    public func now() : DateTime;

    /// Creates a `DateTime` from a `Time.Time` (nanoseconds since epoch) value.
    /// (Same functionality as DateTime constructor)
    ///
    /// ```motoko include=import
    /// let nanoseconds : Time.Time = Time.now();
    /// let dateTime : DateTime.DateTime = DateTime.fromTime(nanoseconds);
    /// ```
    public func fromTime(nanoseconds : Time.Time) : DateTime;

    /// Creates a `DateTime` from a `Components` value.
    /// Returns null if the `Components` value is invalid.
    ///
    /// ```motoko include=import
    /// let components : Components.Components = { 
    ///     year = 2021;
    ///     month = 1;
    ///     day = 1;
    ///     hour = 0;
    ///     minute = 0;
    ///     nanosecond = 0;
    /// };
    /// let ?dateTime : ?DateTime.DateTime = DateTime.fromComponents(components) else return #error("Invalid date");
    /// ```
    public func fromComponents(components : Components) : ?DateTime;


    /// Formats the `DateTime` as Text value using the ISO 8601 format (e.g. `2021-01-01T00:00:00.000Z`)
    ///
    /// ```motoko include=import
    /// let dateTime : DateTime.DateTime = DateTime.now();
    /// let dateTimeText : Text = DateTime.toText(dateTime);
    /// ```
    public func toText(dateTime : DateTime) : Text;

    /// Formats the `DateTime` as Text value using the given format.
    ///
    /// Formats:
    /// - `#iso8601` - ISO 8601 format (e.g. `2021-01-01T00:00:00.000Z`)
    ///
    /// ```motoko include=import
    /// let dateTime : DateTime.DateTime = DateTime.now();
    /// let dateTimeText : Text = DateTime.toTextFormatted(datetime, #iso8601);
    /// ```
    public func toTextFormatted(dateTime : DateTime, format : TextFormat) : Text;

    /// Parses the Text value as a `DateTime` using the given format.
    /// Returns null if the Text value is invalid.
    ///
    /// Formats:
    /// - `#iso8601` - ISO 8601 format (e.g. `2021-01-01T00:00:00.000Z`)
    ///
    /// ```motoko include=import
    /// let dateTimeText : Text = "2021-01-01T00:00:00.000Z";
    /// let ?dateTime : ?DateTime.DateTime = DateTime.fromTextFormatted(dateTimeText, #iso8601) else return #error("Invalid date");
    /// ```
    public func fromTextFormatted(text : Text, format : TextFormat) : ?DateTime;
```


Module: LocalDateTime
```


    public func LocalDateTime(components : Components, timeZone : TimeZone) : LocalDateTime = object {

        public func equal(other : LocalDateTime) : Bool;

        public func add(duration : DateTime.Duration) : LocalDateTime;

        public func nanosecondsSince(other : LocalDateTime) : Int;

        public func toTime() : Time.Time;

        public func toText() : Text;

        public func toTextFormatted(format : DateTime.TextFormat) : Text;

        public func toComponents() : Components.Components;

        public func isInLeapYear() : Bool;

        public func compare(other : LocalDateTime) : Order.Order;

        public func toUtcDateTime() : DateTime.DateTime;

        public func getOffsetSeconds() : Int;

        public func getTimeZoneDescriptor() : TimeZoneDescriptor;
    };

    public func fromComponents(components : Components, timeZone : TimeZone) : ?LocalDateTime;

    public func equal(a : LocalDateTime, b : LocalDateTime) : Bool;

    public func now(timeZone : TimeZone) : LocalDateTime;

    public func fromTime(nanoseconds : Time.Time, timeZone : TimeZone) : LocalDateTime;

    public func toText(dateTime : LocalDateTime) : Text;

    public func toTextFormatted(dateTime : LocalDateTime, format : TextFormat) : Text;

    public func fromTextFormatted(text : Text, format : TextFormat) : ?LocalDateTime;

```

Module: TimeZone
```


    public func utc() : TimeZone;

    public func withFixedOffset(offset : Offset) : TimeZone;
    
    /// Gets the UTC offset in seconds for the specified components and time zone.
    /// The components are used if the timezone is dynamic. This is due to the timezone offset
    /// being dependent on the date (daylight savings, changes to locale offset, etc...).
    ///
    /// ```motoko include=import
    /// let timeZone : TimeZone.TimeZone = ...;
    /// let c : Components.Components = {year = 2020; month = 1; day = 1; hour = 0; minute = 0; nanosecond = 0};
    /// let offsetSeconds : Int = TimeZone.getOffsetSeconds(timeZone, c);
    /// ```
    public func getOffsetSeconds(timeZone : TimeZone, components : Components) : Int;

    /// Gets the UTC offset in seconds for the specified fixed time zone.
    ///
    /// ```motoko include=import
    /// let timeZone : TimeZone.TimeZone = #fixed(#hoursAndMinutes(1, 0));
    /// let offsetSeconds : Int = TimeZone.getFixedOffsetSeconds(timeZone);
    /// ```
    public func getFixedOffsetSeconds(fixedTimeZone: FixedTimeZone) : Int;

```

-------------------------

Gekctek | 2023-06-09 23:32:15 UTC | #24

Nothing big to show as an update, just been filling out tests before I go to implement Locale based timezones and add more advanced features.

I am implementing some more text formats and was wondering if there was any preference on what datetime text format is used? I was thinking something at least very close to [strftime](https://www.man7.org/linux/man-pages/man3/strftime.3.html) or [Rust chromo strftime](https://docs.rs/chrono/latest/chrono/format/strftime/index.html) which are like `%Y-%m-%d`
I have used others like [C# datetime formats](https://learn.microsoft.com/en-us/dotnet/standard/base-types/custom-date-and-time-format-strings) which are more of `yyyy-MM-dd`

-------------------------

Gekctek | 2023-06-19 17:42:54 UTC | #25

Not much to show but I have started working on the IANA TZ database parsing.

My current approach is to create a script to convert the db files to motoko source code. So if there are any new databases, then the script can be run to update the source.

Im probably going to split them into different libraries due to size, but for now I am keeping them one for simplicity

-------------------------

Gekctek | 2023-06-27 05:48:20 UTC | #26

UPDATE 2023-06-26

I have cracked the IANA data and I feel pretty good about it

- I switched to use momentjs data as my data source vs trying to parse the IANA data itself https://momentjs.com/. This allows me to just write a JS script and library (moment) vs having to manually parse the files. Also the strftime just seemed not intuitive and dated, so went the momentjs route of YYYY-MM-dd route
- I am using the JS script to generate Motoko files that are essentially giant arrays/data structures that hold all the data I need
- I split up the generated Motoko into different files. 1 file per timezone top level group like 'America.mo' which has 'America/Los_Angeles' and 1 file per locale like 'EN_AU.mo' for 'en_AU'
- Using generated motoko files with different files allows an à la carte model where you only include the code that is relevant to you or none at all. 
- If you dont know before hand the ones you need, all can be imported/found with  'RegionFinder'/'LocaleFinder' or use 'RegionList'/'LocaleList' for an entire list (also pregenerated source code'
- Whenever the timezones/locales need to be updated, there are scripts to just regenerate the files

Sample:
No regional timezones or locales
```motoko
import LocalDateTime "LocalDateTime";

let components = {
    year = 2023;
    month = 1;
    day = 1;
    hour = 0;
    minute = 0;
    nanosecond = 0;
};
let timeZone = #fixed(#seconds(0));

LocalDateTime.LocalDateTime(components, timeZone);

```
Compiled Size: 203KB

Single Regional Timezone/Locale
```motoko
import EN "../iana/locales/EN";
import America "../iana/timezones/America";
import LocalDateTime "LocalDateTime";
import RegionalTimeZone "RegionalTimeZone";

let components = {
    year = 2023;
    month = 1;
    day = 1;
    hour = 0;
    minute = 0;
    nanosecond = 0;
};
let region = America.Los_Angeles.region;
let locale = EN.locale;
let timeZone = #dynamic(RegionalTimeZone.RegionalTimeZone(region));

LocalDateTime.LocalDateTime(components, timeZone);

```
Compiled Size: 219KB

Region/Locale Finder
```motoko
import LocalDateTime "LocalDateTime";
import RegionalTimeZone "RegionalTimeZone";
import RegionFinder "../iana/RegionFinder";
import LocaleFinder "../iana/LocaleFinder";

let components = {
    year = 2023;
    month = 1;
    day = 1;
    hour = 0;
    minute = 0;
    nanosecond = 0;
};
let ?region = RegionList.find("America/Los_Angeles") else Debug.trap("Region not found");
let ?locale = LocaleFinder.find("en") else Debug.trap("Locale not found");
let timeZone = #dynamic(RegionalTimeZone.RegionalTimeZone(region));

LocalDateTime.LocalDateTime(components, timeZone);

```
Compiled Size: 1389KB



There are more optimizations to do but i thought that was pretty cool

-------------------------

Gekctek | 2023-07-05 21:06:01 UTC | #27

UPDATE 2023-07-05

Been having some issues integrating the toText and fromText functionality utilizing locales. There is a lot of complexity and weird cases to handle so its been taking longer than i expected. I have also struggled specifially with Meridiems (AM/PM) and Oridnals (1st, 2nd, ...) because not all locales follow the same pattern. Moment handles this using custom code per locale and regex per locale. Both of which are issues because I cant translate the custom code from JS to Motoko. I tried a few work arounds sine MOST follow a pattern but there is always at least one that just blows it up. Also since Motoko doesnt have Regex libraries yet, I cant use what is provided. For now I am disabling some parsing around these cases temporarily until I find a better solution. I am going to try to finish the basic version then come back to it. I might need another data source than momentjs for some of these

-------------------------

Gekctek | 2023-07-13 23:54:09 UTC | #28

UPDATE 2023-07-13
Pre-Final Review

I believe I am at a place to get a review of current functionality and naming. 
Before I put on the final polish, I want to get some feedback to not have to redocument after changes made
Things to be done still:
- Add README docs
- Final pass on function/type docs
- Meridiem/Ordinal parsing/date formatting (right now its essentially hard coded to AM/PM and english ordinals)
- A few more tests

@skilesare @icme @quint  or anyone else, now would be the time for anymore feedback.

Here is a link to the generate docs: https://github.com/edjCase/motoko_datetime/blob/main/docs/index.md

If there is no feedback then ill go ahead and polish up and submit for final review

-------------------------

Gekctek | 2023-07-14 21:09:27 UTC | #29

Also Ill just give an overview of my library

Components - Raw date and time fields that represent a specific date/time with no context of timezone or 'instance in time'

DateTime - UTC based datetime with no timezone context or functionality. If need, can convert to a LocalDateTime

LocalDateTime - Timezone based datetime more complex functionality than DateTime

TimeZone - Fixed offset or dynamic. Dynamic are timezones with different offsets based on raw date (Components)

IanaTimeZone - A dynamic implementation of a timezone based off IANA timezone data. Timezone data can be retrieved with direct reference to any file in iana/timezones or found with iana/TimeZoneFinder or iana/TimeZoneList. 

Locale - Location specific datetime formatting information. Like timezones can be gotten from iana/locales or iana/LocaleFinder or iana/LocaleList

-------------------------

Gekctek | 2023-07-20 00:13:42 UTC | #30

Alright. I updated a few things and threw some polish on it

Since there was no feedback im going to officially request a final review by ICDevs @skilesare

-------------------------

kingzak | 2023-09-15 13:07:38 UTC | #32

Is this opened to multiple developers, I want to take the challenge, with timezone, daylight savings, leapyear and internalisation support, the inspiration is to do a total port of momentjs to Motoko

-------------------------

Gekctek | 2023-09-16 13:53:22 UTC | #33

https://github.com/edjCase/motoko_datetime/

Feel free to add onto this. Could use more love in the localization department like mentioned above
But you'll have to talk with icdevs if you are looking for compensation

-------------------------

skilesare | 2023-09-18 18:50:16 UTC | #34

Gekctek has finished this bounty.  You're welcome to add things to the library if you need them, but the official bounty is closed.

-------------------------

Gekctek | 2024-01-27 02:50:23 UTC | #35

I was just browsing ICDevs site. Looks like this bounty is still labeled as open

Might have someone interested in doing some other bounties, so I'm showing them

-------------------------

skilesare | 2024-01-27 11:27:58 UTC | #36

It is on my list to get everything updated both in the forum and on the ICDevs site. We'll have some EVM stuff soon(waiting for the bitcoin stuff to withdraw from PGN -7 day wait!!!) and I'm working on what I hope will be some cool new stuff around bounties that cater the larger ecosystem.  All the current ICDevs bounties are Closed or being wrapped up by someone. More soon!

-------------------------


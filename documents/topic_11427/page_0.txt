skilesare | 2023-01-06 19:03:14 UTC | #1

Special Note:  Thanks to @Arthur and cycle_dao for accelerating this bounty. I've called it "A DAO for cycles" to avoid confusion, but this is a cycle dao, and THE [cycle_dao](https://cycledao.xyz/) has collaboratively agreed to be a sponsor on the bounty.

Special Note 2:  This idea was inspired by a conversation I had with @Maxfinity about how we could use the IC's properties to fund the actual operation of the IC(cycles).

# A DAO for Cycles - #17

## Current Status: Discussion

* Discussion (02/25/2022)
* Ratification 
* Open for application
* Assigned 
* In Review 
* Closed 

[Official Link](https://icdevs.org/bounties/2022/02/25/A-DAO-for-Cycles.html)

## Bounty Details

* Bounty Amount: $10,000 USD of ICP at award date - Standard ICP Match Available
* ICDevs.org DFINITY Foundation Grant Match: This grant was accelerated with by [Arthur Falls](https://twitter.com/arthurfalls?lang=en) and the [cycle_dao](https://cycledao.xyz/) for an additional $5,000. For every ICP sent to 596b5cdecdae9a8ba967d3bdc448d829f353c40c40a284b5f51a6ca283249e02 we will add .25 ICP to this issue and .75 ICP to fund other ICDevs.org initiatives.
* Project Type: Team
* Opened: 02/24/2021
* Time Commitment: Days
* Project Type: Library
* Experience Type: Beginer - Motoko;
* Issue Type: Motoko Canister

## Description

This bounty gives the opportunity to

* learn about DAOs and how they work
* learn about cycles on the IC
* learn about governance on the IC

The goal of this bounty is to create a DAO that collects cycles for a particular application's canisters and rewards users that supply those cycles with DAO tokens that can be used to manage the DAO.

Functions:

wallet_recieve()-> async () - must be called from a cycle wallet that can pass cycles. Use the experimental_cycles functionality to deposit the cycles and mint new DAOTokens according to the following schedule:

* If the Canister has more than MAX_CYCLES, refund all cycles.
* Consult the CYCLE_EXCHANGE_CONFIG and reward enough cycles to get to MAX_CYCLES and reward with minted tokens according to the menu levls.  If MAX_CYCLES is greater than the highest configuration should use the highest configuration as max_cycles. Default Config:

```
MAX_CYCLES = 150_000_000_000_000;

[
    {min:0; max:2_000_000_000_000; rate_per_T: 1: float;}
    {min:2_000_000_000_000; max:10_000_000_000_000; rate_per_T: 0.8: float;}
    {min:10_000_000_000_000; max:50_000_000_000_000; rate_per_T: 0.4: float;}
    {min:50_000_000_000_000; max:150_000_000_000_000; rate_per_T: 0.2: float;}
]
```

The canister should support calling the DIP20, EXT(Fungible), and Ledger canister standards for the issued DAOToken for fungible tokens and DIP721, EXT(non-fungible), and the nft_origyn standard for NFTs.  The canister should be a minting canister for the DAO token canister and call mint on the DAO token canister passing in the determined value as the token value(fungible) or the meta_data variable if an NFT.

The canister should implement:

configure_dao(command: ConfigureDAOCommand) -> async Nat;

Each command must be submitted to the configured governance canister for approval.  The governance canister should return a Nat that is a unique proposal id.  The governance canister is free to implement any approval or voting scheme that it would like.

```
type ConfigureDAOCommand:{
    #UpdateMaxCycles: Nat;
    #UpdateMintConfig: [ExchangeLevel];
    #DistributeBalance: { //sends any balance of a token/NFT to the provided principal;
        to: Principal
        token_principal: Principal;
        amount: Nat; //1 for NFT
        id: ?{#Text: Text; #Nat: Nat}; //used for nfts
        standard: Text;
    };
    #DistributeCycles; //cycle through the allow list and distributes cycles to bring tokens up to the required balance
    #DistributeRequestedCycles; //cycle through the request list and distributes cycles to bring tokens up to the required balance
    #ConfigureDAOToken: {
        principal: Principal;
    };
    #AddAllowList: {
        principal: Principal;
        min_cycles: Nat;
    };
    #RequestTopUp: { //lets canister pull cycles
        principal: Principal;
    };
    #RemoveAllowList: {
        principal: Principal;
    }
    #ConfigureGovernanceCanister: {
        principal: Principal;
    };
};

type ExchangeLevel {
    min: Nat;
    max: Nat;
    rate_per_T: Float;
};
```

The canister should implement execute_proposal(Nat) -> Result<Bool, Error> that runs a proposal and should only be callable by the governance canister.

As an implementation detail of DistributeCycles, it should likely be wired up via timer function and automatically approved and executed by the governance canister.  The internal logic should keep it from running too often.

The canister should implement query cycle_balance() -> Nat that returns the current number of cycles in the canister.

The inspiration for this kind of generic infrastructure was inspired by Max and the InfinitySwap team that is implementing something similar to support their canisters.

## To apply for this bounty you should:

* Include links to previous work writing tutorials and any other open-source contributions(ie. your github).
* Include a brief overview of how you will complete the task. This can include things like which dependencies you will use, how you will make it self-contained, the sacrifices you would have to make to achieve that, or how you will make it simple. Anything that can convince us you are taking a thoughtful and expert approach to this design.
* Give an estimated timeline on completing the task.
* Post your application text to the Bounty Thread

## Selection Process

The ICDevs.org developer's advisors will propose a vote to award the bounty and the Developer Advisors will vote.

## Bounty Completion

Please keep your ongoing code in a public repository(fork or branch is ok). Please provide regular (at least weekly) updates.  Code commits count as updates if you link to your branch/fork from the bounty thread.  We just need to be able to see that you are making progress.

The balance of the bounty will be paid out at completion.

Once you have finished, please alert the dev forum thread that you have completed work and where we can find that work.  We will review and award the bounty reward if the terms have been met.  If there is any coordination work(like a pull request) or additional documentation needed we will inform you of what is needed before we can award the reward.

## Bounty Abandonment and Re-awarding

If you cease work on the bounty for a prolonged(at the Developer Advisory Board's discretion) or if the quality of work degrades to the point that we think someone else should be working on the bounty we may re-award it.  We will be transparent about this and try to work with you to push through and complete the project, but sometimes, it may be necessary to move on or to augment your contribution with another resource which would result in a split bounty.

## Funding

The bounty was generously funded by the DFINITY Foundation and cycle_dao. If you would like to turbocharge this bounty you can seed additional donations of ICP to 596b5cdecdae9a8ba967d3bdc448d829f353c40c40a284b5f51a6ca283249e02.  ICDevs will match the bounty 0.25:1.  All donations will be tax deductible for US Citizens and Corporations.  If you send a donation and need a donation receipt, please email the hash of your donation transaction, physical address, and name to donations@icdevs.org.  More information about how you can contribute can be found at our [donations page](https://icdevs.org/donations.html).


## General Bounty Process

### Discussion

The draft bounty is posted to the DFINITY developer's forum for discussion

### Ratification

The developer advisor's board will propose a bounty be ratified and a vote will take place to ratify the bounty.  Until a bounty is ratified by the Dev it hasn't been officially adopted. Please take this into consideration if you are considering starting early.

### Open for application

Developers can submit applications to the Dev Forum post.  The council will consider these as they come in and propose a vote to award the bounty to one of the applicants.  If you would like to apply anonymously you can send an email to austin at icdevs dot org or sending a PM on the dev forum.

### Assigned

A developer is currently working on this bounty, you are free to contribute, but any splitting of the award will need to be discussed with the currently assigned developer.

### In Review

The Dev Council is reviewing the submission

### Awarded

The award has be been given and the bounty is closed.

# Matches

DFINITY Foundation Grant: - $5,000 USD of ICP at award date
cycle_dao - 40 ICP accelerator Matched with $5,000 from the DFINITY Foundatin Grant


[Other ICDevs.org Bounties](https://icdevs.org/bounties.html)

-------------------------

sardariuss | 2022-03-14 02:13:46 UTC | #2

Hello Skilesare,

 I am quite interested to work on this! I have a few questions to see if I understood correctly the thing before I submit my application:

  - The cycle DAO canister does not directly mint its own DAO token. The "DAO token" comes from another canister (called here DAO token canister), that can be fongible OR non-fongible, and shall respect one of the six mentionned standards. It's up to the cycle DAO canister to be configured with any canister performing as its DAO token canister.

  - For the *configure_dao* function signature, here it seems that a unique proposal ID will be created every time. Shouldn't the function *configure_dao* rather return a *?Nat* or *Result<Nat, Error>* instead of a *Nat* so that no usless propasal ID is generated (e.g. in case the caller doesn't have any DAO tokens so no right to suggest a proposal)?

  - In *#DistributeBalance* I guess the *token_principal* is required in case the configured DAO token canister changes before the *#DistributeBalance* is adopted by the gouvernance canister, so the distribution can still be performed?

 - *#DistributeCycles; //cycle through the allow list and distributes cycles to bring tokens up to the required balance.* The required balance is the *min_cycles* specified in *#AddAllowList* right? Does the cycles DAO canister just refill up to each allowed canisters' minimum ?

  - I am not sure to understand, will the *#DistributeCycles* be called periodically by a kind of controller canister or user (and in this case the cycles DAO needs to keep track of the last call and only perform the actual distribution if enough time has passed), or shall the cycles canister itself call the *distributeCycles* method in a loop (which I think is not possible) ?

  - I guess the reason there is a *requestedList* of canisters in addition of the *allowedList* periodically refed up, is in the case one or many canister are more needy than others and the DistributeCycles is not called frequently enough, to urgently provide cycles to these greedy canisters?

-------------------------

skilesare | 2022-03-14 06:07:05 UTC | #3

[quote="sardariuss, post:2, topic:11427"]
The cycle DAO canister does not directly mint its own DAO token. The ‚ÄúDAO token‚Äù comes from another canister (called here DAO token canister), that can be fongible OR non-fongible, and shall respect one of the six mentionned standards. It‚Äôs up to the cycle DAO canister to be configured with any canister performing as its DAO token canister.
[/quote]

Yes.  For example, the standard ledger(ICP) has a "minting canister" and that canister has the rights to produce tokens.  In this instance, the DAO canister would be the minting canister for whatever token you'd set up.

[quote="sardariuss, post:2, topic:11427"]
For the *configure_dao* function signature, here it seems that a unique proposal ID will be created every time. Shouldn‚Äôt the function *configure_dao* rather return a *?Nat* or *Result<Nat, Error>* instead of a *Nat* so that no usless propasal ID is generated (e.g. in case the caller doesn‚Äôt have any DAO tokens so no right to suggest a proposal)?
[/quote]

Good point!  The spec is meant as a suggestion and I think this is a great change.

[quote="sardariuss, post:2, topic:11427"]
In *#DistributeBalance* I guess the *token_principal* is required in case the configured DAO token canister changes before the *#DistributeBalance* is adopted by the gouvernance canister, so the distribution can still be performed?
[/quote]

This is there so that if the DAO ends up with a balance of some other kind of IC based token, it can distribute those tokens.  So for instance, if the DAO generates some NFTs as part of its configuration, this function could be used to distribute those. Or if it collects XICP it could distribute some to developers wanting to undertake a project. 

[quote="sardariuss, post:2, topic:11427"]
*#DistributeCycles; //cycle through the allow list and distributes cycles to bring tokens up to the required balance.* The required balance is the *min_cycles* specified in *#AddAllowList* right? Does the cycles DAO canister just refill up to each allowed canisters‚Äô minimum ?
[/quote]

Yes. Fill up to the specified amount.  Maybe the vocab needs to be less confusing. Suggestions welcomed.

[quote="sardariuss, post:2, topic:11427"]
I am not sure to understand, will the *#DistributeCycles* be called periodically by a kind of controller canister or user (and in this case the cycles DAO needs to keep track of the last call and only perform the actual distribution if enough time has passed), or shall the cycles canister itself call the *distributeCycles* method in a loop (which I think is not possible) ?
[/quote]

I thought about heartbeat, but that chews cycles. I figured it was better to let each application decide how it wants to call this. We just need to create the handle to be pulled by the dapp/dao.

[quote="sardariuss, post:2, topic:11427"]
I guess the reason there is a *requestedList* of canisters in addition of the *allowedList* periodically refed up, is in the case one or many canister are more needy than others and the DistributeCycles is not called frequently enough, to urgently provide cycles to these greedy canisters?
[/quote]

That was my thinking.  One method is a push and one is a pull.

-------------------------

sardariuss | 2022-03-14 17:32:09 UTC | #4

Thanks for your answers.

> So for instance, if the DAO generates some NFTs as part of its configuration, this function could be used to distribute those. Or if it collects XICP it could distribute some to developers wanting to undertake a project.

So you suggest that the wallet_receive() functions could trade cycles against DAO tokens and optionally other token/NFT ? In this case the cycle DAO canister not only keep a reference to the canister for DAO tokens but optionally to a list of other token/NFT canisters?

> That was my thinking. One method is a push and one is a pull.

I was wondering why do we even need a push method. But you seem to suggest the push (DistributeCycles) would be automatically accepted by the gouvernance DAO, but not the pull ? My understanding is the danger if you automatically approve every application's canisters pulls is that you might open the door to DoS attacks that could burn all your DAO cycles, am I right?

-------------------------

skilesare | 2022-03-14 17:36:31 UTC | #5

1. Yes. 2. Yes...something like that. A well-thought-out exercise in attack vectors would be warranted.

-------------------------

sardariuss | 2022-03-14 18:21:58 UTC | #6

Ok cool, sorry for all the questions, I am quite new in this space :D 

So I'd definitly like to work on that!

**Previous work**: I don't have much to show to justify my background, but I can say that
 - I have six years of programming experience in C++
 - I went through all the motoko tutorials, hands-on
 - I started my own motoko project a few months ago (that I'd like to keep private for now), I kinda hit a wall, then I started again experimenting with the sudograph library. Taking a step back I think it would be wise for me to try to get more involved in this space and becoming more knowledgeable before trying to build my own stuff. I have a lot of interest into DAOs.
 - I am part time available (around 20 hours per week), happy to work in a team or alone.
 - My goal is to be able to quit my current job and be able to sustain on working on community projects or my own projects, so this is very exciting for me

**Overview how I will complete the task**: right know I am thinking about creating a "minimum viable" cycles DAO canister that could only use a DIP20 canister for its DAO token, implementing the inner logic of the cycle DAO canister, and then playing around with a dummy "mocked" gouvernance canister. Then improving the inner logic, find workarounds for potential limitations, and finally implementing the other standards.

**Timeline**: I'd say 3 months if I'm alone, but this might be underestimated, as I say I'm quite new in this space. By exemple I only checked one token standard so far.

**Post your application on the bounty thread**: I hope this is it!

-------------------------

paulyoung | 2022-03-14 21:43:02 UTC | #7

https://sdk.dfinity.org/docs/examples/dao.html üëÄ

-------------------------

skilesare | 2022-03-15 21:00:05 UTC | #8

Awesome!  This bounty just got easier. :)

-------------------------

sardariuss | 2022-03-21 22:56:39 UTC | #9

https://github.com/sardariuss/CyclesDAO

I implemented the *cycle_balance*, *wallet_receive*, and *set_token_dao* functions. For now only the DIP20 token can be used as DAO token. Note that I slightly changed the data structure used for *cycle_exchange_config*, because the one suggested duplicates the information (max from interval N = min from interval N+1). Also the MAX_CYCLES is the last threshold in the array, again to avoid duplicates.

I added some tests (see srs/CyclesDAO/test/add_cycles.test.sh), it seems to work well so far. 

Any comment will be appreciated.

The next steps for me if nobody has comment will be:
 - implementing a function that allows to modify the *cycles_exchange_config*: *func* *update_config(interval: Types.ExchangeInterval)*.
 - plug the BasicDAO canister and start implementing *execute_proposal*

-------------------------

skilesare | 2022-03-22 01:12:22 UTC | #10

Awesome! Will Review.

-------------------------

sardariuss | 2022-03-28 00:09:57 UTC | #11

Small update. I started to implement the *configure_dao* method. In the current implementation, the *configure_dao* method actually executes the command (but only if it is called by the governance canister), and I don't have an *execute_proposal* method. I did that because to be able to submit a proposal to the governance BasicDAO canister, you need to have an account, otherwise an error is returned. And to me it didn't make a whole lot of sense that the CyclesDAO canister gets an account to the governance canister (IMO the CyclesDAO shall be 100% the slave of the governance canister). Having a single method also removes some (I think) some unecessary logic for keeping a list of proposal IDs inside the CyclesDAO, because everything is handled internally by the Governance canister anyway.

For example, to submit a proposal to configure the CyclesDAO so it uses the "dip20" canister to mint the tokens (in ic-repl commands, see prelude.sh in tests):


```
call basicDAO.submit_proposal(
  record {
    method = "configure_dao";
    canister_id = cyclesDAO;
      message = encode cyclesDAO.configure_dao(
        variant {
          configureDAOToken = record {
            canister = dip20;
        }
      }
    );
  }
);
```

If the vote passes, the configure_dao method is called on the CyclesDAO canister which gets updated as intended.

Let me know what you guys think!

-------------------------

skilesare | 2022-03-29 11:40:19 UTC | #12

Great adjustment! Looks like you are making great progress. I'll make sure you are marked as assigned on this bounty!  I'll do a deeper dive into the code when I get a chance.

-------------------------

sardariuss | 2022-04-29 13:15:40 UTC | #13

Hello, long time no see, I am coming back with another round of questions :slight_smile: 

Concerning the token standards to interface with, I added the link I found to each of them. Could you confirm it's the right ones? Also I have some remarks on some of them.

DIP20: https://github.com/Psychedelic/DIP20/tree/main
--> The single standard implemented so far

EXT (fungible and non-fungible): https://github.com/Toniq-Labs/extendable-token/blob/main/standards/ext-core.mo
--> There is a mintNFT function in the ERC721 (non-fungible) interface, but for the standard fungible interface I could not find any mint function. I am not sure what how am I supposed to mint then.

DIP721: https://github.com/Psychedelic/DIP721/tree/main
--> Looks allright

nft-origyn: https://gist.github.com/dpori/380177f111899bfda59e0f17f620bdc5 
--> I could just find the interface, so I won't be able to test by creating a nft-origyn canister on my side. Other than that looks allright.

ledger: https://github.com/dfinity/ic/blob/master/rs/rosetta-api/ledger_canister/ledger.did and example here: https://github.com/dfinity/examples/blob/master/motoko/ledger-transfer/src/ledger_transfer/main.mo
--> The problem I think I will have is that only the internet computer gov canister can mint ICP? With my current design one needs to give the ownership of the minting canister to the CyclesDAO canister to mint the tokens which is impossible here. So I think there is probably something off with my design.

Maybe instead of giving the ownership of the token canister to the CyclesDAO canister it shall still belong to the governance canister, and the CyclesDAO shall (periodically or when it does not have anymore tokens?) ask the governance canister to refill it ? Or is there a possibility to give authorization to mint to another canister? (but looking at each token standard, it does not seem possible)

-------------------------

skilesare | 2022-04-29 14:00:48 UTC | #14

Hey...Origyn just uses the NNS/SNS ledger standard for the OGY token. There are a couple extra dfx calls, but nothing that should be relevant.  Here is the current branch:  https://github.com/ORIGYN-SA/ic/tree/dip-20-passthrough/rs/rosetta-api/ledger_canister

The NFT standard is not published in full yet but the first test canisters are coming out this week and you'll be able to preview the API.

-------------------------

skilesare | 2022-04-29 14:03:26 UTC | #15

[quote="sardariuss, post:13, topic:11427"]
Maybe instead of giving the ownership of the token canister to the CyclesDAO canister it shall still belong to the governance canister, and the CyclesDAO shall (periodically or when it does not have anymore tokens?) ask the governance canister to refill it ? Or is there a possibility to give authorization to mint to another canister? (but looking at each token standard, it does not seem possible)
[/quote]

I don't think that this canister is going to be able to run with ICP. Like you say, it needs to be the minting canister to be able to mint.  You don't need to integrate it with the ICP ledger specifically.  Since the SNS will use that interface it will be good to have the interface working so those tokens can set the minting canister to the DAO canister.  Maybe something in the SNS would preclude this, we can ask @lara.

-------------------------

lara | 2022-05-04 13:54:03 UTC | #16

Hi all! just read through the thread a bit and keen to try to help, but I don't think I understand the concrete question you have just now. 
Can you maybe try to reformulate the question that I might be able to help with?

Do I understand correctly that in your setting there are the following canisters: governance, ledger / token canister, and cyclesDAO canister (that trades cycles for governance tokens)? 
I currently don't fully understand whether you imagine to use the SNS canisters for governance / ledger?
Is the question whether for some of them you could use the SNS cansiters and be compatible? Or how the control / minting cansiters are set in the SNS design?

-------------------------

skilesare | 2022-05-04 16:53:40 UTC | #17

I think the question is:  Will the SNS be its own minting canister, or can we have a configurable one?

If it is configurable then this CycleDao canister could be used as a minting canister and set on the SNS ledger as the minting canister

-------------------------

lara | 2022-05-04 17:36:22 UTC | #18

Got it, thanks for clarifying!

If you just want to use the SNS canisters as a basis but implement you own additions, you should be able to set the minting account to anything when you deploy the ledger canister. If you chose any canister other than the governance canister it might however be trickier to implement voting rewards (if you want them to consist of freshly minted tokens).

If you want to use the SNS "out of the box", then by the Carbon milestone it will have a first simple version of a reward scheme, where the SNS governance canister will indeed be set as the minting account (minting canister). The design is however still in the discussion phase (see [here](https://forum.dfinity.org/t/open-governance-canister-for-sns-design-proposal/10224/36)). This is just a first version however, so it might be possible to make this configurable later (e.g., for SNSs that don't want voting rewards, with voting rewards that are minted this would be harder).

We will also have a community conversation about SNS rewards next week if you are interested! It will be held by @bjoernek who leads the work on the SNS reward scheme.
(Bjoern, please also feel free to add details that I might have missed here).

Hope that helps, please let me know if you have further questions!

-------------------------

skilesare | 2022-05-04 17:45:37 UTC | #19

Thanks for the reply!  Maybe it makes sense in the future to have multiple minting accounts if you have different functions that you want to mint tokens for.  Example: A network that rewards for 1. Voting 2. Sending cycles to the network 3.

-------------------------

sardariuss | 2022-05-04 18:52:23 UTC | #20

Thank you both for your answers! So for now I am gonna do as you suggest lara, put the minting account to the CyclesDAO when I deploy it.

-------------------------

lara | 2022-05-05 11:34:08 UTC | #21

I think we would have to carefully consider the consequences, also together with the ledger team that has maybe already thoughts on that.

-------------------------

lara | 2022-05-05 11:36:16 UTC | #22

So are you planning to use the SNS canisters for your project? And will you anyway use the code that we provided but not necessarily follow all the upgrade paths that we will establish for the Carbon deadline?
If so, I think just setting the account on initialization is a good solution.

-------------------------

sardariuss | 2022-05-06 03:40:41 UTC | #23

[quote="lara, post:22, topic:11427"]
So are you planning to use the SNS canisters for your project?
[/quote]
I think we defintly would like to be able to do that.

[quote="lara, post:22, topic:11427"]
And will you anyway use the code that we provided but not necessarily follow all the upgrade paths that we will establish for the Carbon deadline?
[/quote]

We should be able to use the SNS governance canister from the Carbon milestone (the one that sets itself as the minting canister). The only thing is that we won't be able to set the governance canister and the CyclesDAO to mint the same token.

But I think this problematic is not inherent to the SNS. @skilesare Correct me if I'm wrong, but we assumed with the design of the CyclesDAO that it would be possible to have two canisters (the CyclesDAO and the governance ones) that could mint the same token, but right now the token standards don't support to have more than one minting address. I think at the end the choices are:
 - accept CyclesDAO canister and governance canister can only mint different tokens
 - have a mint function on the governance canister, and the governance would keep a list of principals that are allowed to mint tokens through it
 - have this logic in an intermediate "access control" canister that manages the minting rights, and governance and CyclesDAO would interact with this intermediate instead of the ledger/token
 - push to update the token standards to be able to have multiple principals that could mint the token

-------------------------

lara | 2022-05-06 08:28:34 UTC | #24

Thanks for the clarifications!
Just to make sure we are in agreement, let me comment on the proposed solutions:
* accept CyclesDAO canister and governance canister can only mint different tokens

I think this would work with the SNS as it is planned (although to be honest I am still not sure I fully understand what the required functionality of the system is and thus if having two tokens is something that makes sense). Probably this would mean that one has a SNS ledger and on top of this another ledger cansiter that is just also controlled by the SNS?

* have a mint function on the governance canister, and the governance would keep a list of principals that are allowed to mint tokens through it

This will not exist for the SNS from Carbon deadline and is not explicitly planned. It would require a change in the SNS governance canister that should be considered carefully. If not done right this opens the SNS up to dangerous attacks. Especially, I assume these principals would all have to be SNS controlled, so this might have to be enforced.
What could be done with the SNS currently is to add a new proposal type that is allowed to mint tokens on the ledger when the proposal is adopted, but I assume this is not what you are looking for.

* have this logic in an intermediate ‚Äúaccess control‚Äù canister that manages the minting rights, and governance and CyclesDAO would interact with this intermediate instead of the ledger/token

As long as this new special canister is set to be the minting canister, this might work with the SNS canisters. However, it might not work with the "out of the box"-SNS that is planned for Carbon where SNS governance might be set to the minting canister (as mentioned, the reward design is under way and will be discussed with the community next week). In any case, I want to reiterate that this would have to be designed extremely carefully to ensure that the minting of tokens is controlled in a decetralized way and that the end-users also have to possibility to verify this fact. 

* push to update the token standards to be able to have multiple principals that could mint the token

As you say, this would require changing the SNS ledger. Again, we would have to carefully assess whether this is actually secure and advisable. 

These are just my spontaneous thoughts on how I think the different solutions relate to what is currently planned on the roadmap. Hope that helps a bit!

-------------------------

sardariuss | 2022-05-28 20:55:38 UTC | #25

I am a bit lost on what function does what. Can the function wallet_receive only mint the fungible tokens in exchange of the received cycles ? If not, how do I know which NFT(s) to mint in exchange of the cycles ?

On ConfigureDAOCommand(#DistributeBalance), shall the CyclesDAO transfer or mint the token?

In my current implementation, I assumed:
 - Only DIP20, EXT(fungible), Ledger standards can be set and then used to exchange cycles in exchange of freshly minted tokens (no NFT)
 - ConfigureDAOCommand(#DistributeBalance) performs a transfer of the given token (one of the six possible, NFTs included)

-------------------------

skilesare | 2022-05-29 03:45:12 UTC | #26

[quote="sardariuss, post:25, topic:11427"]
Can the function wallet_receive only mint the fungible tokens in exchange of the received cycles ? If not, how do I know which NFT(s) to mint in exchange of the cycles ?
[/quote]

The idea here is that if you contribute cycles you will get some dao tokens. Perhaps you could set this up to lint nfts, but that wasn‚Äôt the original intent.

[quote="sardariuss, post:25, topic:11427"]
On ConfigureDAOCommand(#DistributeBalance), shall the CyclesDAO transfer or mint the token?
[/quote]

This is only needed if the dao ends up with a balance somehow. Maybe the main token wants to take .5% of every transaction and send it to the dao so the dao can distribute it to developers. Just an example.

-------------------------

sardariuss | 2022-05-30 12:39:43 UTC | #27

Ok thanks, I think I'm doing the right thing then.

-------------------------

sardariuss | 2022-07-13 12:14:55 UTC | #28

I think I have finished with the development besides:
  - some minor blockings/notes: everything is written in the readme. I am waiting on your feedback to work on these.
  - the implementation of the NFT_ORYGIN standard: last time I checked I could not find the candid/wasm files for the NFT token, but I'm gonna ask on the forum.
  - a phylosophical question: currently the cycles DAO can be configured with any principal as governance, which can be a single individual or an actual DAO. IMO it's nice to have a separation of responsabilities per canister, and it allows a broader usage of the CyclesDAO. The drawback is that the frontend does not allow to add proposals, or to see their states - it only shows accepted proposal (i.e. actual configure calls). Also that makes the name CyclesDAO a bit misleading, because it's possible to involve no DAO at all.

-------------------------

sardariuss | 2022-07-13 16:35:25 UTC | #29

I would like to discuss two points:

- one limitation of the current architecture is that the DAO cannot mint the same token as the CyclesDAO. IMO if we make the "CyclesDAO" configurable with any DAO, it's a bummer to have this limitation. I think it could be solved with this architecture:

![CycleSDAO|578x364](upload://lCjEbUM9I9yGW7eRVQPqvgjWMHD.png)


The CyclesDispenser canister is basically be the current CyclesDAO canister but instead of directly doing the mint it calls MintAccessController.mint().

The MintAccessController is a simple canister that is configured with a token to mint. On configureToken, it verifies if it owns the token. It keeps a list of authorized minters that can be added by the admin only. On mint(), it checks if the caller is authorized, if yes it mints the configured token.

The DAO can be any DAO that has the capacity to execute proposals as canister calls (like the BasicDAO from the examples). It can be used to call functions on the CyclesDispenser, the MintAccessController, or anything else. Which brings to my second point:

- if we keep the CyclesDAO configurable with any DAO, IMO it does not make a lot of sense to have a function configure(#Distribute) because the DAO could directly submit a proposal to distribute some token itself, it does not need to call another canister to do that.

-------------------------

skilesare | 2022-07-13 18:06:16 UTC | #31

> * In *walletReceive*, there is no absolute guarentee that after the cycles have been accepted, the minting of the token cannot fail. In this case the loses his cycles and receive no token in exchange (see main.mo:143)

Maybe we should wait to accept the cycles until after the mint?  In addition, the mint may have a cost and we might want to subtract the mint cost from the cycles?  Might be a good use of the cycle calculation API?(ok to wait to another phase for this).

> * In *distributeCycles*, if one call to *fillWithCycles* function traps, it will prevent other allowed canisters from receiving cycles. (see main.mo:232)

Possible solution:  When this is called have deque that is checked....if it is empty, fill it with items from the triemap.  Cycle through the deqeue and before you call the item, move it to the back. If it is successful, remove it entirely.  This way if there is a trap and the function fails, the committed items will be removed and you can just pick it up again on the next call.  You'll have to handle an permenatly failing item...maybe with a time-out?  If the queue is over 5 minutes old it gets blown away?  May need to think through this a bit more, but perhaps something along those lines?

>nft_origyn

I'm finalizing it right now...I'll try to get it to you asap...should be straight forward.

> * a phylosophical question: currently the cycles DAO can be configured with any principal as governance, which can be a single individual or an actual DAO. IMO it‚Äôs nice to have a separation of responsabilities per canister, and it allows a broader usage of the CyclesDAO. The drawback is that the frontend does not allow to add proposals, or to see their states - it only shows accepted proposal (i.e. actual configure calls). Also that makes the name CyclesDAO a bit misleading, because it‚Äôs possible to involve no DAO at all.

I'm not totally sure I follow. Why can't the front end add proposals?  Because it isn't the governance principal?

-------------------------

skilesare | 2022-07-13 18:08:38 UTC | #32

100% agree on this principle.  If you want to work up a simple controller it would be great.  At Origyn we have minting_canister that acts in this way so it is likely a good pattern to at least describe in the read me for people that want to implement it. It can basically be a relay.

-------------------------

sardariuss | 2022-07-13 19:43:11 UTC | #33

[quote="skilesare, post:31, topic:11427"]
Maybe we should wait to accept the cycles until after the mint?
[/quote]

I can do that, it's probably safer this way, but now there is a small risk that the amount of accepted cycles returned from ExperimentalCycles.accept is different than the amount passed as argument. According to the doc, it can happen if "less is available or the canister balance limit is reached". If less is available, I guess that should never happen if we deduce the amount from ExperimentalCycles.available. If the canister limit is reached: this I don't know where that limit is defined, but we should make sure that we cannot set a cycles exchange config that goes over that limit, otherwise once the limit is reached it's free mint of tokens for everybody that call walletReceive.

[quote="skilesare, post:31, topic:11427"]
Possible solution: When this is called have deque that is checked‚Ä¶if it is empty, fill it with items from the triemap. Cycle through the deqeue and before you call the item, move it to the back. If it is successful, remove it entirely. This way if there is a trap and the function fails, the committed items will be removed and you can just pick it up again on the next call. You‚Äôll have to handle an permenatly failing item‚Ä¶maybe with a time-out? If the queue is over 5 minutes old it gets blown away? May need to think through this a bit more, but perhaps something along those lines?
[/quote]

Yes! I'm not sure to understand the timing thing though. But having an intermediate deque to monitor with which canisters to resume if the previous call to distributeCycles ever traps could work on its own.

[quote="skilesare, post:31, topic:11427"]
I‚Äôm not totally sure I follow. Why can‚Äôt the front end add proposals? Because it isn‚Äôt the governance principal?
[/quote]

Well I'm not sure what final product you expect. Do you prefer:
 1. a frontend specific to the CyclesDispenser canister. This frontend does not do anything DAO specific, it's pretty much readonly (but maybe allow to call walletReceive, using plug or stoic ? is this something you want ?).
 2. same as 1. + another frontend specific to the BasicDAO (that btw I'm gonna have to fork and modify, I just realized that it needs to use a real token :clown_face:). So if the user ever decides to use another DAO that the BasicDAO, it still can access the CyclesDispenser frontend.
 3. a single unified frontend that uses both the cyclesDispenser and BasicDAO canisters, but if you decide to use your own DAO instead of the BasicDAO, the frontend wouldn't work.

[quote="skilesare, post:32, topic:11427"]
100% agree on this principle.
[/quote]
Cool! Then I know what to continue with :)

-------------------------

skilesare | 2022-07-14 14:33:21 UTC | #34

[quote="sardariuss, post:33, topic:11427"]
I can do that, it‚Äôs probably safer this way, but now there is a small risk that the amount of accepted cycles returned from ExperimentalCycles.accept is different than the amount passed as argument. According to the doc, it can happen if ‚Äúless is available or the canister balance limit is reached‚Äù. If less is available, I guess that should never happen if we deduce the amount from ExperimentalCycles.available. If the canister limit is reached: this I don‚Äôt know where that limit is defined, but we should make sure that we cannot set a cycles exchange config that goes over that limit, otherwise once the limit is reached it‚Äôs free mint of tokens for everybody that call walletReceive.
[/quote]

I think you are right.  We probably need a two-phase commit that makes things harder.  You could record the transaction in a log, add the id of that log to a data repo(probably a Trie) and then when the mint succeeds...take it out.  That way if it fails, you can add a retry function that takes the log ID and retries.  I guess you'd need to expose this list via a function as well so people can query if they need to retry or not.

[quote="sardariuss, post:33, topic:11427"]
Yes! I‚Äôm not sure to understand the timing thing though. But having an intermediate deque to monitor with which canisters to resume if the previous call to distributeCycles ever traps could work on its own.
[/quote]

Think about this more, you probably need some kind of configuration that is a max_remote_calls anyway. If you have too many servers you will always overrun the cycle limit.  You could return a variant that is #result(), #eof() and call it until it gets to eof.

[quote="sardariuss, post:33, topic:11427"]
3. a single unified frontend that uses both the cyclesDispenser and BasicDAO canisters, but if you decide to use your own DAO instead of the BasicDAO, the frontend wouldn‚Äôt work.
[/quote]

I think I want this but without the limitation of something not working. Can't you make the canisters configurable?  What makes it not work? The lack of a standard? Maybe we should ruminate on that and maybe look at what SNS is doing for proposals?

-------------------------

skilesare | 2022-07-20 15:29:30 UTC | #35

Hey‚Ä¶what is your time line on this. I‚Äôd love to see it get wrapped up because I‚Äôd live to talk to you about a more permanent opportunity if you are interested. Are you currently working on another project? Where are you located?

-------------------------

sardariuss | 2022-07-21 16:23:17 UTC | #36

Hey! Well I was about to tell you that the implementation of the backend is very closed to being finished, probably will be in one or two days. The test coverage is not perfect but quite good. For now I complied with the initial bounty description only, which means:
(1) I haven't updated the frontend yet, it's still readonly, no way to interact with the dao or feed cycles
(2) I haven't checked how to integrate it with SNS, I need to ramp-up on all the forum discussions on this first

For (1) it will probably take me one or maybe two weeks more. Ultimatly it would be nice to have it work, it would feel like having a real product that every random people could use.
For (2) I have no idea yet, I don't even know if it will be possible. I actually was hoping to get a part of the bounty reward or so before digging into that.

Right now I'm only working on the bounty and I don't have any set plan for after, so yes I am definitely interested on working on something more permanent if it involves the IC :) I am located in Montreal, Canada.

-------------------------

sardariuss | 2022-07-29 19:42:15 UTC | #37

Hi!

I advanced on the frontend side, it will still probably take a week to be finished. I used the plug and stoic wallet to log the user in.

I have been looking deeper on the SNS integration. It's very probable I'm missing something, but with what I've found it shall be possible to interface with it, but it's not trivial. 

First thing, the frontend. The current architecture:

![detailed_architecture_1|477x351](upload://9cDewWL56ggLzPYs2wZ6r64mVZu.png)


**Proposal 1.1** If we want to be able to use the SNS governance, one could have a configuration during deployement to tell the frontend to use the basic Governance or the SNS governance interface to submit/vote/list the proposals:

![detailed_architecture_2|649x351](upload://6WCMpCGov54l05Bscoh6W7Xejwp.png)

With this architecture, the difficulty is in the frontend, which has to handle two different kind of governance interfaces and if configured with the SNS governance, do the right transfer calls to make proposal to configure the cycles provider and list/vote proposals specific to the cycles provider only.

**Proposal 1.2** If we want the frontend to be agnostic of the type of governance, one could make the current governance configurable and *wrap* the SNS governance calls.

![detailed_architecture_3|690x314](upload://nLNEa6leyS17ILpXlDOuwGJPaAy.png)


But this will still require the frontend to call *AddNeuronPermission* on the SNS governance canister to give the basic governance canister the right to submit/vote the proposals. In some regards, this is similar to what is being done right now with the current governance: to submit a proposal, the frontend first asks the governance canister the transfer parameters for the submission deposit (canister id, transfer arguments (for EXT and LEDGER) or allowance arguments (for DIP20)), then performs the transaction, then only calls submitProposal on the governance canister. Right now it's done in kindof a switch in the frontend (see https://github.com/sardariuss/CyclesDAO/blob/main/src/frontend/src/utils/actors.tsx#L135), but it could probably be done in an IC raw call (or I saw that in plug you can do that in a window.ic.plug.batchTransactions too) so the frontend does not have to handle this switch and stay agnostic of the actual governance implementation.

Second thing, the minting. The current architecture:

![detailed_architecture_4|477x311](upload://vAQvcI0jKqfETivRzpNsOEibdy2.png)

**Proposal 2.1** An easy solution would be to just no mint the same tokens:

![detailed_architecture_5|651x311](upload://bZLhWe3ZeSpbyq2c5p8YOK1cPIT.png)


And then probably have another service that swaps both tokens in 1:1. This is just an idea that poped in my mind, I don't know the consequences of this.

**Proposal 2.2** Add the ICRC-1 token in the list of token standards supported AND make the MintAccessController expose the ICRC-1 interface fonctions so it is transparent for the SNS Governance:

![detailed_architecture_6|477x311](upload://qBRIxinOYY1SQDWqnmVMgZeXMIZ.png)


The implementation might simply consist of calling the same function on the configured ICRC-1 canister (but the mint that shall check if the caller is in the list of authorized minters). These functions shall probably trap if the configured token is not ICRC-1? One flaw of this design is that the MintAccessController has to be deployed *before* the SNS Governance, otherwise it's not possible to make it the owner of the ICRC-1 token.

**Propoal 2.3** I haven't been thinking too much about it, but is it absolutly needed the CyclesProvider mints token? Could it not just transfer tokens ? From what I read from the SNS discussions, it seems like it's not planned to give to the canisters managed by the SNS (the SNS root dapp canisters) any possibility to mint, but rather have a SNS proposal that mints a bunch of tokens for them. Maybe we could think about an automatic submit proposal that ask to mint tokens to the SNS if it gets below some threshold?

-------------------------

skilesare | 2022-07-29 20:18:38 UTC | #38

You've thought a lot more than I have about this at this point.  What do you think is the best solution?

Front end:  Let's keep it simple. The SNS isn't out yet, so we could just release the governance interface first and add the sns branch later if there is demand.

Minting:  I like 2.3, but perhaps we have to have a switch. It is certainly nice to have the cycle dao canister mint if it can, but if not, then it can submit a proposal to sns to mint tokens to it.  This seems like a good governance loop.  This could be configurable.

-------------------------

sardariuss | 2022-07-29 20:56:00 UTC | #39

Right now 1.2 and 2.3 make the most sense to me. For 2.3. though, it requires small modifications to make the MintAccessController more configurable (configure it to mint or just transfer tokens) and if we want something that submits a proposal automatically to refill the tokens, we will need to assign a dedicated neuron to the CyclesDAO, but it's a little price to pay.

-------------------------

skilesare | 2022-07-29 21:00:18 UTC | #40

Sounds good.  Thumbs up for minimum characters.

-------------------------

sardariuss | 2022-08-05 20:31:33 UTC | #41

Hi!

I finally would like to submit my application for the bounty. There are a few limitations and tasks left (see readme.md and github issues) but the applicaton looks good, seems quite stable and hopefully does the job! Note that this does not include the SNS integration. 

As a reminder, the code is here: https://github.com/sardariuss/CyclesDAO

If you want a demo I could record a video or do it live.

-------------------------

skilesare | 2022-08-05 23:39:07 UTC | #42

Awesome. Hey @northman whats the community call schedule look like? Maybe we can get a demo spot?

-------------------------

skilesare | 2022-08-17 18:23:04 UTC | #43

@sardariuss has finished the bounty!  We'd love to have people review the implementation so we can award the bounty:

https://github.com/sardariuss/CyclesDAO

If you are looking for a solution to fund your canister, this may be it.

-------------------------

sardariuss | 2022-09-05 19:24:24 UTC | #44

It's been a month since I've submitted the bounty. Since then I had no feedback but suggestions to work on other bounties and "let me see what I can do". I gotta say it is a bit frustrating.

-------------------------

skilesare | 2022-09-05 21:38:28 UTC | #45

I apologize. I‚Äôm waiting for the payment from dfinity. To pay it out. You are welcome to start in a new bounty if you want to. The work you did was fantastic.

Please send me your principal and I‚Äôll send a payment as soon as I can.

-------------------------

sardariuss | 2022-09-05 23:14:11 UTC | #46

Thank you, I appreciate it. I will PM you soon.

-------------------------


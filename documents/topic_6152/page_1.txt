skilesare | 2021-12-03 15:14:52 UTC | #104

Great to know it is possible! Thanks for the quick reply.

-------------------------

dieter.sommer | 2021-12-10 17:07:12 UTC | #105

**Status update:**
We have set a new (aggressively timed) milestone for implementing the signing protocol creating ECDSA signatures and thereby consuming the quadruples we can compute already: December 22.
After that we need to "iron out" the shortcuts we still have in there in order to get towards the final protocol. We'll keep you posted!

-------------------------

nomeata | 2021-12-15 20:33:40 UTC | #106

[quote="nomeata, post:94, topic:6152"]
(Amusingly, it renders attempts to prevent canisters from holding ICPs or to prevent neurons from being transferrable more or less futile.)
[/quote]

Hmm, nobody bit this bait, so maybe I should make it clearer:

With canisters performing ECDSA signatures, it will be possible for canisters to control neurons (with a little help to submit ingress messages signed by the canister), and thus make neurons transferable. I assume this is not a new observation to @dieter.sommer and the rest of the team, but I am curious what the consequences are. I can see four possible consequences; is is clear which way we are heading?

1. The system somehow tries to recognize canister-owned ECDSA keys and will not allow them in ingress messages, to plug this hole.
 2. Accept that canisters can own neurons this way, but not do anything about. If people really want canister-own or transferable neurons, they’ll have to jump through these hoops.
3. Remove the restriction that neuron owners can’t be canisters, because it can be worked around anyways, canisters can already own ICP, and it opens up interesting applications like autonomous neurons.
4. Additionally, simply make neurons transferable, given that they can be transferred using this feature.

-------------------------

mparikh | 2021-12-15 22:07:01 UTC | #107

I am struggling with making the logical leap to the transfer functionality conceptually. 

Given that  canisters already can manage self-authenticating principals with ICPs in them ,  I suppose that it is (or would be)  possible for canisters to create neurons through those principals and hence become owner of the neuron through the self authentication principals.

The controlling of the neuron; including disbursement; would be possible as well. 

I get lost while thinking about the transfer functionality. Could you elaborate a little on what exactly is meant by a transfer?

-------------------------

nomeata | 2021-12-15 22:52:24 UTC | #108

[quote="mparikh, post:107, topic:6152"]
Given that canisters already can manage self-authenticating principals with ICPs in them
[/quote]

What method are you thinking of here? Canister signatures as used by the Internet Identity? Yes, these lead to the same conclusions, once they are accepted from any subnet, not just the root subnet. This is not yet the case, as far as I know.

[quote="mparikh, post:107, topic:6152"]
Could you elaborate a little on what exactly is meant by a transfer?
[/quote]
You can't change the controller of a neuron; this is an intentional restriction related to long term incentives or accountability or something like that. But if you put a controlling canister in between, you can now easily transfer ownership of the canister (which is unrestricted and not tracked), thus circumvent the restriction.

-------------------------

mparikh | 2021-12-16 00:26:25 UTC | #109

[quote="nomeata, post:108, topic:6152"]
What method are you thinking of here? Canister signatures as used by the Internet Identity? Yes, these lead to the same conclusions, once they are accepted from any subnet, not just the root subnet. This is not yet the case, as far as I know.
[/quote]
Yes. We are still stuck here. https://github.com/dfinity/ic/blob/master/rs/certified_vars/src/lib.rs#L94-L96.

Either this restriction will be lifted OR the allow https calls. This restriction is easier in many perspectives to being amenable to being lifted, imo.

[quote="nomeata, post:108, topic:6152"]
You can’t change the controller of a neuron; this is an intentional restriction related to long term incentives or accountability or something like that. But if you put a controlling canister in between, you can now easily transfer ownership of the canister (which is unrestricted and not tracked), thus circumvent the restriction.
[/quote]

Thanks. That was the missing link for me.

-------------------------

LightningLad91 | 2021-12-16 00:36:01 UTC | #110

[quote="nomeata, post:108, topic:6152"]
But if you put a controlling canister in between, you can now easily transfer ownership of the canister (which is unrestricted and not tracked), thus circumvent the restriction.
[/quote]

Hi. Just want to make sure I understand. It sounds like this would only work for new neurons created using a canister and not for existing neurons. Is that right?

-------------------------

nomeata | 2021-12-16 09:16:09 UTC | #111

[quote="LightningLad91, post:110, topic:6152"]
It sounds like this would only work for new neurons created using a canister and not for existing neurons. Is that right?
[/quote]

Correct. (Existing neurons can be transferred as well, in away, if you find a way to transfer the controlling cryptographic key. Send the yubikey by mail. Let the receiver take over your Internet Identity. Somehow convince the receiver that you deleted all copies of the secret key. I guess it is just a matter of hassle…)

-------------------------

dieter.sommer | 2021-12-23 11:59:52 UTC | #112

**Update**

We are close to reaching our milestone of having signature generation working end-to-end (with shortcuts in the implementation still being there) that has been scheduled for Dec 22. Most of the functionality for reaching this milestone is there, but the system API still needs to be hooked up so that canisters can make signing requests and responses can find their way back to canisters. As the holiday season starts now, milestone achievement will likely slip into the first week of the new year.

-------------------------

Hazel | 2022-01-03 20:04:34 UTC | #113

Could I request the foundation releases a means of verifying signatures with Motoko. Even outside of its intended use with Bitcoin this is an incredibly useful feature.

-------------------------

timo | 2022-01-03 20:12:32 UTC | #114

Which signature schemes are you interested in?

-------------------------

skilesare | 2022-01-03 20:59:54 UTC | #115

Maybe Relevant with use cases for needing to verify signatures:  https://forum.dfinity.org/t/tackling-certifieddata-in-motoko/6272

-------------------------

Hazel | 2022-01-03 21:34:04 UTC | #116

Just having a Motoko lib capable of verifying the [generated ECDSA signatures](https://forum.dfinity.org/t/threshold-ecdsa-signatures/6152/30) would be all I need.

-------------------------

ayjayem | 2022-01-04 00:27:46 UTC | #117

FWIW, I definitely think that neuron transfer implications need to be explicitly addressed sooner rather than later, given that it sounds like neuron transfer will soon be possible.

Perhaps the most foundational concern (among a number) is that liquid democracy can be frustrated in a world with transferable neurons.

Neurons follow other neurons. So if a followed neuron is transferred, its followers end up following an entity they didn't choose (the transferred neuron's new controller). Neurons can be transferred without any record of the transfer. So how does liquid democracy work when followers can't know that they're following who they chose in the first place?

NNS voting today depends on liquid democracy. So IMHO, it's critical to determine, at the very least, how liquid democracy will work when neurons soon become transferable.

@jwiegley and @johan, given that you are working on IC tokenomics and have previously [alluded](https://forum.dfinity.org/t/tokenomics-proposal-community-consideration/6159/15) to the risks of neuron transfer, I would be interested in what may be in the works to address.

-------------------------

mparikh | 2022-01-03 22:59:26 UTC | #118

Neuron transfer is inevitable. Liquid democracy  != equal democracy. The more voting power one has the greater is the right to be heard. So if some neurons are bought by someone else, they will have greater voting power.

Also coming soon to a theater near you is the ability to self-borrow from your future self some percentage of your neuron's present value; by temporarily suspending your internet identity linked to the neuron; repaying that loan through time. Think a model similar to Alchemy.

-------------------------

ayjayem | 2022-01-03 23:24:31 UTC | #119

Agreed: it sounds like neuron transfer is inevitable. Hence why its biggest risks need to be addressed.

The concern above isn't about those more invested in the IC getting more VP.

The concern is that untracked neuron transfer (to a new neuron controller) means that follower neurons can end up following new neuron controllers they don't want to. So the idea of liquid democracy as currently implemented breaks down.

-------------------------

Maxfinity | 2022-01-03 23:19:54 UTC | #120

Have to say I agree with this, although even with the ECDSA I don't think it's 100% secure. Who knows whether Dfinity will suspend the chain-key api in future or unavailable. However, even if Dfinity puts in blocks on using the ECDSA signatures then some other org/chain whatever with the technology will make it possible. It's inevitable imo.

-------------------------

mparikh | 2022-01-03 23:24:45 UTC | #121

The right to vote/follow whoever goes with the transfer. Just like the original owner can change whom to follow. How does this break down liquid democracy

-------------------------

ayjayem | 2022-01-03 23:46:50 UTC | #122

The problem is that the neuron that is *being followed* can be transferred to a new (canister) controller without the *follower's* knowledge. So the follower can't be sure that they continue to follow who they chose to represent them initially.

If followers can't trust that they're following who they want to, then liquid democracy breaks down.

-------------------------

ayjayem | 2022-01-04 00:06:35 UTC | #123

Just because the terminology is cumbersome here, symbols may be helpful:

* **Neuron 'A'** follows **Neuron 'B,'** staked by a canister controlled by **Person 'C'** - whom **A**'s controller trusts to represent her in NNS voting.
* But without advertisement, **C** transfers canister control of **Neuron B** to **Person 'D'** - someone unknown to **A**'s controller.
* **A** is now effectively following **Person D**, without **A**'s controller's knowledge or choice.

-------------------------

timo | 2022-01-04 08:12:26 UTC | #124

[quote="Hazel, post:116, topic:6152, full:true"]
Just having a Motoko lib capable of verifying the [generated ECDSA signatures](https://forum.dfinity.org/t/threshold-ecdsa-signatures/6152/30) would be all I need.
[/quote]

The ECDSA signatures generated by the IC itself through the threshold ECDSA mechanism? What would be the application?

So canister A would hold a virtual private ECDSA key, that is distributed among the hosting subnet, then would get a message signed and another canister, B, would verify the signature on that message. Why doesn't A just send an inter-canister message to B and B looks at `msg.caller` to verify it comes from A?

-------------------------

skilesare | 2022-01-04 12:11:51 UTC | #125

[quote="timo, post:124, topic:6152"]
So canister A would hold a virtual private ECDSA key, that is distributed among the hosting subnet, then would get a message signed and another canister, B, would verify the signature on that message. Why doesn’t A just send an inter-canister message to B and B looks at `msg.caller` to verify it comes from A?
[/quote]

There are async-temporal applications(general) and cross-chain applications(specifically) where we just need some solid crypto libraries in motoko.  ICDevs will have some bounties around this in the next couple of weeks, but if you all have them sitting around on hard drives it would be nice to apply the funds elsewhere.

-------------------------

timo | 2022-01-04 12:29:56 UTC | #126

No it doesn't exist. 

I would be interested to see how performant they are. But since you're likely only going to verify a single signature per message the performance is probably irrelevant in practice.

RSA would be very to implement, anything EC related a lot more work. At least Motoko already has arbitrary precision integers so you don't need a gmp library. That helps a bit. Just need to find someone to implement it.

-------------------------

Hazel | 2022-01-04 18:15:01 UTC | #127

[quote="timo, post:124, topic:6152"]
The ECDSA signatures generated by the IC itself through the threshold ECDSA mechanism? What would be the application?
[/quote]

All of the applications I can think of are orchestrating communication in swarms of canisters spawned from a trusted source. Given Source, Ca, Cb - how can Ca and Cb interact with one another while verifying they both belong to Source. The "best" solution here would be if we could derive the pubkey of a principalId - but I don't think that is a feature on the roadmap (or even possible). The naive solutions are either too difficult implement (PubSub events on Canister Creation), or are subject to physical attacks `HMACy -> Hash(Common Secret + Claim)`.

If I had this today, I would implement something like the following - Given Source, Ca, Cb. When creating a canister Source would pass its public key and a claim to Ca, Cb. When Ca sends an inter-canister call to Cb, it can tack on its claim and Cb can verify.

So, I pretty much just want to use this for glorified JWTs. :joy:

-------------------------

timo | 2022-01-04 18:50:47 UTC | #128

Can you have a registry in Source so that Cb can ask Source (once) if Ca belongs to Source or not?
Maybe not because you have so many Cx that you think this is going to be a bottleneck?
Or maybe not because you want to allow for recursion, i.e. chains of certificates?
Otherwise the registry would be easiest.

[quote="Hazel, post:127, topic:6152"]
The “best” solution here would be if we could derive the pubkey of a principalId
[/quote]
How would that help for your use case?

-------------------------

Hazel | 2022-01-04 19:23:12 UTC | #129

[quote="timo, post:128, topic:6152"]
Can you have a registry in Source so that Cb can ask Source (once) if Ca belongs to Source or not?
Maybe not because you have so many Cx that you think this is going to be a bottleneck?
Or maybe not because you want to allow for recursion, i.e. chains of certificates?
[/quote]

Yeah with the certificate scheme one could completely avoid the issues of storing a large number of Cx. Also, with the registry each Cx needs to maintain a record of canisters it has verified. One other thought, consider message queuing problems; If you have a lot of new interactions all the time, now you have to figure out how to distribute the load on the registry. Distributed systems are hard.

[quote="timo, post:128, topic:6152"]
How would that help for your use case?
[/quote]

If you could determine the origin of a principal and you know you can trust the origin you've solved this interaction problem - just in this case the derived principals are the "special" secure thing. After thinking about it I think the additional flexibility you get from passing certificates around is superior.

-------------------------

PaulLiu | 2022-01-07 20:27:08 UTC | #130

Just want to share with everybody here that an important internal milestone has been reached earlier this week: we were able to successfully complete the end-to-end workflow of canister signature signing using threshold ECDSA. A user can submit a message to a canister, which then calls the system API to sign on the message. Subnet nodes then work together to produce this signature and the canister gets it back in a few seconds. The signature can be verified by the user inside a browser using a standard secp256k1 Javascript library against the canister's public key (which was BIP32 derived from its canister id). 

No picture no proof, so here you go:
![tecdsa-demo|550x500, 50%](upload://zF1Y8eBjJEoof5oiP1lT9CH2yHx.png)

Before anyone gets too excited and demand this to be ready tomorrow, there is still much work ahead of us: support facilities, testing, integration, disaster recovery, more testing and security reviews. Nevertheless it is still a validation of the design, protocol and implementation behind this work. Thanks to the hard work put in by everybody on the team and also all community members who supported this project with warmth and valuable discussions, we are one step closer to the goal!

-------------------------

senior.joinu | 2022-01-08 13:45:53 UTC | #131

I was wondering, can you ECIES using these keys? Not for the canisters, but if you could apply this same technology to another task.

I mean, if I want to encrypt something that only a group of people cooperatively can decrypt, will this help?

-------------------------

victorshoup | 2022-01-08 17:16:13 UTC | #132

Good question. What you are asking here is: can we do threshold decryption on the IC? While threshold signing and decryption have some things in common, they are not exactly the same thing. So ECDSA threshold signing will not directly enable threshold decryption. That said, threshold decryption is something dfinity is definitely exploring. It certainly could be done, so it is just a matter of prioritizing engineering resources.

-------------------------

dpdp | 2022-01-09 16:49:33 UTC | #133

Is there a way to get the extended public key of the canister key? it could be a nice one; 

So we can derive it and know which keys/signatures are coming from that canister (via BIP-32);

I see the derivation path generated with a `Principal` here ( https://github.com/dfinity/ic/blob/f24300c0a2f65c5fdab6379f2a103a15361afb96/rs/crypto/internal/crypto_lib/threshold_sig/tecdsa/src/bip32.rs#L27 ) + in the workshop document it states the key derivation is unhardened;

-------------------------

dieter.sommer | 2022-01-12 09:46:42 UTC | #134

[quote="dpdp, post:133, topic:6152"]
Is there a way to get the extended public key of the canister key? it could be a nice one;
[/quote]

Only canisters themselves will be able to query their canister "root" public key from the system API. The canister's "root" public key is derived by the system from the ECDSA master key. The canister can make the public key, further public keys derived from this public key, or Bitcoin addresses computed from those public keys available to any parties they wish using an application-specific interface. For example, a DEX canister would give each of its customers their own Bitcoin address computed from a public key that has been BIP-32 derived from the canister's "root" key it has queried from the system. Then, the customer can transfer Bitcoin to this customer-specific address.

-------------------------

nomeata | 2022-01-12 11:23:51 UTC | #135

[quote="dieter.sommer, post:134, topic:6152"]
The canister’s “root” public key is derived by the system from the ECDSA master key.
[/quote]

Is the ECDSA master key secret, or does the key derivation somehow include a secret salt? Otherwise I’d expect this to be possible?

-------------------------

dpdp | 2022-01-17 16:27:26 UTC | #136

I think herumi currently works on a library (I follow him on github)

https://github.com/herumi/ecdsa-motoko

-------------------------

dieter.sommer | 2022-01-28 09:06:44 UTC | #137

[quote="nomeata, post:135, topic:6152"]
Is the ECDSA master key secret, or does the key derivation somehow include a secret salt? Otherwise I’d expect this to be possible?
[/quote]

Apologies for my late response, the upcoming Bitcoin release and other things have been taking up all my time. ;-)

Let me provide some background on ECDSA keys:
* We will have one master ECDSA key in the beginning, the architecture being extensible to multiple keys and also multiple curves, e.g., we see secp256r1 as one that might come next to enable decentralized CA use cases.
* There will be one active signing subnet and one key backup subnet in the beginning.
* The signing subnet will not run user-space canisters for reducing the attack surface on the key. (no user-space canister is even better than sandboxed ones)
* We will have a system API for allowing canisters to retrieve its own or other canisters' public keys and also derive public keys when specifying a derivation path.
* The master public key is not published as it is derived with a non-standard extension of BIP-32: It uses a canister id as input instead of a 32-bit integer to derive the canister master key from the master key.
* Returned public keys are always accompanied with a chain code for allowing further BIP-32 unhardened key derivation.
* When requesting a signature, the canister provides the message hash and derivation path as input to the method.

The key management and deployment are part of the feature IC-733 that is about threshold ECDSA system integration and handles the required aspects besides the core protocol IC-316.

Does this answer your question above? -- I tried go give some more context about related things to provide the larger picture.

-------------------------

dieter.sommer | 2022-01-28 09:19:31 UTC | #138

[quote="dpdp, post:136, topic:6152"]
I think herumi currently works on a library (I follow him on github)
[/quote]

This is a regular ECDSA library if I am not mistaken. Thanks for the pointer to this! It may contain some building blocks, e.g., EC scalar multiplication on the secp256k1 curve, which we will need as building blocks for Motoko-based canisters, e.g., for deriving Bitcoin addresses.

Doing ECDSA  signing directly in a canister is not the best idea: It requires that the private key be stored in every replica and if one replica is breached, the private key is breached as well. So using an ECDSA library directly in the canister is not aligned with the trust model of the IC which stipulates that less than 1/3 of the replicas can be compromised and it is still secure. Anyone who needs ECDSA signing functionality in a canister is advised to use threshold ECDSA once available. However, it's nice to have this library for verifying ECDSA signatures, so we appreciate this work! :slight_smile: 

Also, for the Bitcoin Developer Preview threshold ECDSA will not yet be available and such an ECDSA library is nice to have to compute ECDSA signatures in a non-secure way during development and then switching over to threshold ECDSA once it's available and before going live with the canister using this functionality. :slight_smile:

-------------------------

dpdp | 2022-01-28 09:49:12 UTC | #139

Yes I was referring to the message from Hazel - 

> Just having a Motoko lib capable of verifying the [generated ECDSA signatures](https://forum.dfinity.org/t/threshold-ecdsa-signatures/6152/30) would be all I need.

Which is around **verifying** ECDSA and threshold ECDSA signatures - as they should be the same only :+1: 

but good to mention the security risk around (non-threshold) signing from a canister;

-------------------------

nomeata | 2022-02-03 12:59:31 UTC | #140

[quote="dieter.sommer, post:137, topic:6152"]
The master public key is not published as it is derived with a non-standard extension of BIP-32: It uses a canister id as input instead of a 32-bit integer to derive the canister master key from the master key.
[/quote]

Thanks! So the public key stays private in the same sense as the Internet Identity ~~seed~~ salt is private: the nodes participating in that subnet know it, but won't tell anyone.

You always emphasize “unhardened”. How hard is it to find the original public key?

Also, what is the rationale for not simply publishing the key and the derivation mechanism? This would unlock use cases where the receiver of a signed message wants to know if it was signed by a specific canister (rather than just by some public key claimed to be a canister) - or is that exactly something you don't want?

-------------------------

timo | 2022-01-31 19:22:38 UTC | #141

To provide some background on the library at https://github.com/herumi/ecdsa-motoko
This work was started in response to requests made here on this thread, in which people said being able to verify ECDSA signatures in Motoko would be useful in situations involving swarms of canisters or cross-chain applications.

The signing functionality is there for completeness. After all, Motoko is a general purpose language not limited to canisters, isn't it? The implementation is not optimized, but that's fine because it seems that the desired applications tend to require only one verification per message execution. The idea is to have this library available right away, from day 1, when the threshold ECDSA signatures go live.

-------------------------

timo | 2022-01-31 19:31:12 UTC | #142

[quote="nomeata, post:140, topic:6152"]
So the public key stays private in the same sense as the Internet Identity seed is private
[/quote]

No, in a weaker sense.

[quote="nomeata, post:140, topic:6152"]
You always emphasize “unhardened”. How hard is it to find the original public key?
[/quote]

It shouldn't be hard. I think you need to observe the master public key of two canisters for which you know the canister id and then you can solve a linear equation. Or something like that.

[quote="nomeata, post:140, topic:6152"]
Also, what is the rationale for not simply publishing the key and the derivation mechanism?
[/quote]

There were some reasons but I don't remember them. Maybe it has to do with not wanting people to start relying on something that is an implementation detail and that can't be guaranteed in the future. The derivation mechanism is public of course because it is in the code.

-------------------------

nomeata | 2022-01-31 20:06:34 UTC | #143

[quote="timo, post:142, topic:6152"]
It shouldn’t be hard. I think you need to observe the master public key of two canisters for which you know the canister id and then you can solve a linear equation. Or something like that.
[/quote]

Ok, so in all practical senses, people will (should they find a need) figure this out.

Which leads to the next question: Is the plan to eventually have more than one ESDSA master key signing subnet, and have some canisters get their key from one and others from another?

-------------------------

timo | 2022-02-01 07:54:53 UTC | #144

[quote="nomeata, post:143, topic:6152"]
Which leads to the next question: Is the plan to eventually have more than one ESDSA master key signing subnet, and have some canisters get their key from one and others from another?
[/quote]

I think that's at least a possibility. That's why it's better to not rely on any current implementation details.

A question out of curiosity: Is there any application where it is desirable to be able to derive a canister's public key without asking the canister? It is not something that you can do in the "real" world. You can ask your friends for their public keys in person but you cannot detect if they gave you someone else's public key or if they share the private key with someone else. No matter what you use (PKI, identity based encryption, etc.) can change that. Still nobody has a problem with that. So why the need with canisters?

-------------------------

nomeata | 2022-02-01 17:35:32 UTC | #145

Well, we have that property for Bitcoin addresses for example - I can send you a signature and you can check that it belongs to the owner of a Bitcoin address.

If you first have to ask the canister, you have to either use update calls (expensive, canister may not want to pay for it) or a query call with certified variables (non-trivial to implement). 

But no, I don't have anything concrete in mind.

BTW, I wonder if the Internet Identity would have used this instead of our slightly odd “Canister Signatures” if we had had it back than? Even if we did, we can't get rid of them now (at least until the next major crash of this beta network ;-)). But it might be an interesting question to think about for those who implement similar services.

-------------------------

lastmjs | 2022-02-02 19:41:18 UTC | #146

[quote="nomeata, post:140, topic:6152"]
So the public key stays private in the same sense as the Internet Identity seed is private
[/quote]

What do you mean by this? Are you saying that II seed phrases are stored in plain text in the II canister?

-------------------------

timo | 2022-02-02 20:20:21 UTC | #147

He meant salt, not seed. A salt used in the derivation of per-dapp principals so that your identity anchor can't be traced across different dapps. If you are thinking of the recovery phrases then of course they are not stored anywhere. They are created client side, never leave your device and are not stored on your device either.

-------------------------

dieter.sommer | 2022-02-11 09:06:03 UTC | #148

[quote="timo, post:142, topic:6152"]
There were some reasons but I don’t remember them. Maybe it has to do with not wanting people to start relying on something that is an implementation detail and that can’t be guaranteed in the future. The derivation mechanism is public of course because it is in the code.
[/quote]

One reason for not wanting to publish the master public key was indeed the fact that this would in some way require the concrete implementation of having a single master key and deriving each canister "root key" from this. We thought it to be a cleaner API to allow everyone to just query canister root public keys.

[quote="nomeata, post:145, topic:6152"]
If you first have to ask the canister, you have to either use update calls (expensive, canister may not want to pay for it) or a query call with certified variables (non-trivial to implement).
[/quote]

The ic0 system API will be such that any canister can query any canister's root public key. This is more general than originally envisioned as we resolved some underlying architecture challenges of making this work in the most general deployment of having any number of ECDSA master keys on any number of subnets for different ECDSA curves. We won't have this general deployment, at least initially.

We did not see any application either that would be prevented by this approach. So the canister whose public key you want to obtain need not be involved in any other canister getting the key, so does not incur any cost in this case. But that's more the special case. If public keys should be given to end users, this, of course, means the canister incurs some cost for this. A query with a certified variable for this is cheap, but you have to go through the complexity of implementing it as you mention somewhere. The canister offering its keys (or derived Bitcoin addresses) as part of its API will definitely be an important key distribution scenario for many applications, e.g., a DEX giving every user their own Bitcoin address to transfer funds to.

-------------------------

dieter.sommer | 2022-02-11 09:13:52 UTC | #149

[quote="nomeata, post:143, topic:6152"]
Which leads to the next question: Is the plan to eventually have more than one ESDSA master key signing subnet, and have some canisters get their key from one and others from another?
[/quote]

As @timo  mentions, this is definitely a possibility for the future. We have concluded the design of the mechanisms for the rollout now. In summary, there will initially be one ECDSA signing subnet and one for key backup (the NNS). The architecture incl. NNS proposals and Registry records are all kept sufficiently general to support the most generalized way of deploying threshold ECDSA: An arbitrary number of ECDSA master keys, multiple ECDSA curves, the keys sitting on an arbitrary number of subnets, multiple keys per subnet, and subnets being either signing subnets or only key-holding subnets for key backup purposes. Note that not all aspects of the implementation support this generality now, but the API does.

I plan to post more details on the rollout decisions and system integration design when there is some time for that. There will probably also be a Community Conversation in the near future on this topic: Threshold ECDSA signatures: System integration.

-------------------------

dieter.sommer | 2022-02-11 12:24:01 UTC | #150

**Threshold ECDSA signatures: System integration**

For threshold ECDSA, we have been working intensively on the design of the system integration in the recent weeks. This has been split off as a separate feature from the main feature IC-316 "Threshold ECDSA signatures." The new system integration feature is IC-733 "Threshold ECDSA signatures: System integration." It deals with the following questions which are crucial for system integration and deployment of the feature:
* Rollout: How do we roll out threshold ECDSA to the Internet Computer mainnet?
* Key generation: How do subnets get a threshold ECDSA key?
* Deployment: How many and which subnets will support threshold ECDSA keys? How many threshold ECDSA keys do we have?
* Subnet recovery: How can we do subnet recovery for subnets that support ECDSA?
* Pricing: How many cycles do we charge for a sign_with_ECDSA ic0 system call?

We have answered all these questions and have a design ready, implementation of which has already started in parallel to the work on the main feature. I'll post details on the design in a future post soon to share key results on how we intend to move forward in this area.

**Threshold ECDSA signatrures progress update**

The crypto and consensus teams are still working intensively on the main IC-316 feature to complete the implementation of the threshold ECDSA signing protocol.

-------------------------

nomeata | 2022-02-11 12:30:48 UTC | #151

[quote="dieter.sommer, post:148, topic:6152"]
The ic0 system API will be such that any canister can query any canister’s root public key.
[/quote]

Ah, that's interesting and neat, and answers some of these questions, thanks!

-------------------------

dieter.sommer | 2022-02-11 12:54:01 UTC | #152

Yes, indeed! :-)

But, admittedly, this powerful API for public key retrieval has only been possible to be decided on very recently, once we had a clear view of how we could implement it also in the most general deployment scenarios (arbitrarily many master keys on many subnets, any canister being able to use any of the keys etc.). The earlier thinking was that a canister could only query its own public key for exactly the reasons of reasonable implementability of the API in the most general settings we could envision. But that's resolved now for the very general, powerful, API.

-------------------------

dieter.sommer | 2022-03-04 15:36:35 UTC | #153

**Progress update**

We have made lots of progress both with the core threshold ECDSA signing feature as well as the system integration of threshold ECDSA.

**Core feature:** We are about to finalize the implementation of complaints handling, which is the last big open item for the signing protocol.

**System integration:** Work has progressed well for the efforts related to the NNS proposals required to create ECDSA master keys, reshare keys, and activate signing for a threshold ECDSA subnet. Some areas where we still have work items open are the following: Key resharing protocol to reshare an ECDSA master key from one subnet to another subnet, tweaks to the management canister API for threshold ECDSA, XNet message routing for ECDSA-related messages, as well as provisioning 34 nodes for a large threshold ECDSA subnet.

**Testing / QA:** Once we complete the implementation, we have a substantial testing effort as well as internal and external code reviews ahead of us.

-------------------------

cyaolong | 2022-03-13 11:17:07 UTC | #154

Has the post been published? Where can I read it?

-------------------------

dieter.sommer | 2022-03-30 12:21:43 UTC | #155

**Progress update**

Awesome news! :tada:

Implementation of complaints handling, the last major open part for the core signing feature, has been finished. The core threshold ECDSA feature is now working in an end-to-end manner. @rsubramaniyam  and @Manu have demonstrated the feature in last week's DFINITY Global R&D meeting. :partying_face:

Now we are focussing on getting all the remaining parts of the feature done. See my post above for major items this comprises -- system integration and specifically Xnet re-sharing require still quite an effort until completion. An effort on writing a system testing suite has been started in parallel. More updates to follow.

-------------------------

dieter.sommer | 2022-04-27 07:35:48 UTC | #156

**Progress update**

The engineering team is still working on the implementation of this feature on multiple fronts: The cryptographic primitives are essentially finished, but there is still an effort required for finalizing the integration of crypto with consensus, e.g., for the X-Net re-sharing of a threshold ECDSA key, as well as some other parts of system integration. For example, the functionality related to the NNS proposals for key management (particularly Xnet re-sharing) still requires some more work to get finalized. A pretty small remaining item will be the integration with DFX which is essentially enabling the feature and generating / loading a key when DFX starts up a replica. Depending on performance measurements, we will need to give performance some attention, but that is currently open.

Another important task coming up is the security review of the consensus-related parts of the code through an external company. This will be started shortly and will help us increase our assurance on the code. We are planning to publish the resulting audit report once the findings have been addressed to share the gained insights with our community.

On the front of the closely-related Bitcoin feature, we have made great progress and will soon be able to run a first beta deployment on an IC subnet (https://forum.dfinity.org/t/direct-integration-with-bitcoin/6147/263). So, the puzzle pieces are (slowly) coming together finally to enable a trustless Bitcoin integration unheard of so far on any blockchain!

-------------------------

dieter.sommer | 2022-04-30 10:20:55 UTC | #157

For those, who have not see this yet: @victorshoup and @JensGroth of the DFINITY Foundation have published their threshold ECDSA work which is the foundation for our threshold ECDSA implementation. You can have a look at the paper uploaded to eprint at the below URL.

**Design and analysis of a distributed ECDSA signing service**
*Jens Groth and Victor Shoup*
*DFINITY*

https://eprint.iacr.org/2022/506.pdf

Have fun! :slight_smile:

-------------------------

borovan | 2022-04-30 19:05:25 UTC | #160

oh damn he's here too, calling you guys morons... can we ban him from the blockchain?

-------------------------

Forreal | 2022-05-06 23:04:27 UTC | #161

Just ignore him. Eventually, he will get tired when he gets no reaction from anyone here.

-------------------------

dieter.sommer | 2022-05-09 12:48:39 UTC | #162

**Progress update**

The implementation has further progressed and we think that this or next week we may be ready for a first deployment of the feature on an IC subnet. This deployment will likely not contain the Xnet re-sharing yet, but the core signing algorithm. The purpose of this first deployment is to observe the behaviour of the feature on mainnet and to get operational experience with it before we will release the feature on the NNS and a large dedicated threshold ECDSA subnet.

As of last week, the major open issues to be implemented for a first deployment have been the following:
* Payload validation to be finished. This is a prerequisite for the protocol to be secure and we won't release on mainnet even for any form of testing purposes before this has been done.
* Fixing some issues with Xnet communication for signing requests. Currently, Xnet routing of signing requests and responses still has some glitches.

A further major item that we do not necessarily need for a first deployment, but that is crucial for the overall feature is the following:
* Xnet re-sharing requires to be end-to-end tested and validated. The protocol itself is implemented (crypto and consensus), but we have not been able to end-to-end validate its correctness.

There are multiple further items that still need to be done, but we are slowly getting there.

-------------------------

dieter.sommer | 2022-05-11 12:14:54 UTC | #163

# Threshold ECDSA System Integration

As promised long time ago, I wanted to give you an overview of the system integration of threshold ECDSA and particularly how we intend to deploy the feature.


## New and Updated NNS Proposals for Managing Threshold ECDSA Keys

We needed to define or extend multiple NNS proposals to realize the threshold ECDSA key management functionality required for the intended deployment scenarios.
* `do_update_subnet`: Updated proposal that allows for defining that a specific subnet should generate a new threshold ECDSA key with a given key id.
* `create_subnet`: Updated proposal that allows for creating a new subnet with a threshold ECDSA key being re-shared from a specified subnet (actually, multiple keys from different subnets could be re-shared to this subnet in the future, the proposal is already generalized to such scenarios). Re-sharing works by the key source subnet computing initial threshold ECDSA dealings encrypted towards the replicas of the target subnet (Phase 1 of the cryptograpihc re-sharing protocol), which are then stored in the CUP for the to-be-created subnet in the Registry. This is all orchestrated by the NNS canisters when executing the `create_subnet proposal`. Once the new subnet bootstraps, its replicas pick up the initial dealings from the Registry and compute their threshold ECDSA key shares from those initial dealings (Phase 2 of the cryptographic re-sharing protocol).
* `update_ecdsa_signing_subnets`: New proposal for enabling / disabling the signing functionality for a subnet for a key id.
* `set_recovery_cup`: New proposal for setting the recovery cup with the initial threshold ECDSA dealings of the intended key from the given subnet.
* A proposal for deleting a given threshold ECDSA key from a subnet.

Note that key ids are pairs comprising the cryptographic group (as variant) and a key identifier (as byte array). Example: `(secp256k1, prod_key_1)`


## Deployment Architecture

Our intended deployment architecture is as follows:
* We initially want one production threshold ECDSA key (and probably a test key, however, this discussion is about the production key) replicated on two subnets for reasons of key availability.
* The NNS will hold the production threshold ECDSA key passively, i.e., the NNS will not accept signing requests with this key.
* A new 34-node subnet will hold the same production threshold ECDSA key and accept signing requests.


## Provisioning Flow

Provisioning flow with abstract API calls (the used key name is an example and not defined yet):
* `do_update_subnet(subnet_id=NNS, ... , ECDSA_keys={ (secp256k1, prod_key_1) })`
  * The NNS is instructed to create a new threshold ECDSA key with id (secp256k1, prod_key_1) locally.
* `do_create_subnet(nodes={X, Y, Z, ...}, ..., ECDSA_key_source={ (NNS, (secp256k1, prod_key_1) }, ...)`
  * Computes ECDSA dealings for nodes `X, Y, Z, ...` from the existing key `(secp256k1, prod_key_1)` and stores them in the Registry as part of the genesis CUP (Catch Up Package) for the new subnet to be created, then creates a new 34-node subnet with nodes `X, Y, Z, ...`, the nodes of which pull the ECDSA dealings from the Registry and finalize the re-sharing protocol to obtain the threshold ECDSA key `(secp256k1, prod_key_1)` in secret-shared form.
* `update_ecdsa_signing_subnets(A, true, key_id_1)`
  * Enables the new 34-node subnet to accept signing requests for the key `(secp256k1, prod_key_1)`.

In case one of the subnets holding the threshold ECDSA key `(secp256k1, prod_key_1)` is destroyed such the key cannot be reconstructed from the available shares any more and thus needs recovery, we use the set_recovery_cup proposal to create a recovery CUP (Catch Up Package) with ECDSA dealings of the key from which the key shares are computed.

## Further Notes

Currently, each subnet can hold a single threshold ECDSA key, future extensions may lift this constraint, e.g., once we need a key in another group or would want multiple keys in the same group. The further may happen sooner than later in order to be able to realize a decentralized CA, which would require one of the `secp256r1` groups.

There will be a talk on May 24th in which we will present more details about this topic.

See the attached figure for an overview of the rollout and related key management process.
![Threshold_ECDSA_System_Integration_Process|690x360](upload://iSX7xjWlQ9LRhO5HiDLurRnCm9W.png)

-------------------------

emmaperetti | 2022-05-20 09:47:21 UTC | #164

Join Community Conversation - Threshold ECDSA - (@andrea & @dieter.sommer) on May 24, 2022: https://dfinity.zoom.us/webinar/register/WN_7-PNsmBySACjLRfvnrWZUw

-------------------------

PaulLiu | 2022-05-20 16:14:34 UTC | #165

BTW, if you want to start developing a project using the ECDSA feature today, you may want to check out this project https://github.com/ninegua/ecdsa_example

It provides a mock implementation to allow deployment both locally and on IC. You can simply change the canister id back to `aaaaa-aa` after this feature is rolled out on main net.

Both Rust and Motoko examples are provided.

-------------------------

dieter.sommer | 2022-05-23 09:48:09 UTC | #166

**Update**

Implementation has been progressing pretty well recently and important work items have been completed, including the following:
* Open issues with Xnet message routing of signing requests
* Xnet re-sharing of threshold ECDSA keys is now covered with end-to-end tests (this is a huge achievement of the engineering team)
* Key deletion (needed during the initial testing phase to gain some operational experience with the feature on IC mainnet)
* All required NNS proposals
* System tests

Considering the current state of the implementation, we can expect a first deployment on IC mainnet with a test key by end of the month or in early July. We plan to perform internal testing of the API to test its stability and performance characteristics and, once we have sufficient assurance of this, we open it up for public consumption. We already have a subnet on IC mainnet reserved for this purpose.

Meanwhile, you can program against a mock API in a canister as explained here: https://forum.dfinity.org/t/threshold-ecdsa-signatures/6152/165

You will hear on this and other channels once we deploy on IC mainnet! Stay tuned!

-------------------------

dieter.sommer | 2022-06-09 21:14:11 UTC | #167

Progress update

We are nearing completion of the feature for a Beta launch. I would assess that we are currently around 90% - 95% complete for the Chromium / Beta launch.

The plan for the release of the Bitcoin integration feature incl. t-ECDSA is as follows:
* Chromium (Beta) release in some weeks, target is late June: functionally complete implementation
  * API for Bitcoin testnet Integration available on IC mainnet for public consumption
  * Threshold ECDSA deployment with a test key that will be deleted after a Beta phase available on IC mainnet for public consumption
  * Documentation, videos, and a sample project on how to use the feature
* GA (general availability) release targeted at ~1-2+ months after Chromium: production-ready implementation
  * API for Bitcoin mainnet Integration available on IC mainnet for public consumption
  * Threshold ECDSA deployment with the production key that will be hosted on two large subnets on IC mainnet for public consumption
  * ckBTC canister

The Chromium (Beta) release will allow the community to build canisters based on the Bitcoin and threshold ECDSA APIs, i.e., create fully-functional integrations with Bitcoin. The GA release provides fixes towards production readiness, e.g., in the areas of performance, and enables Bitcoin mainnet and the final production threshold ECDSA key.

There are some items still to be implemented for the Chromium / Beta release for t-ECDSA, but some of those are too technical to be self explaining without the full context and are not given here. We estimate those to be doable in the coming few weeks. Examples include:
* Performance & latency benchmarks on realistically-sized subnet
* Turn feature on by default in the SDK
* Supporting key id (only 1 for now in consensus)
* Addressing some security findings from the external code review
* Signed initial dealings (from xnet resharing)
* ic-admin commands for re-sharing to be defined based on tests
* Writing a documentation Web page
* Recording tutorial videos

For the GA release, the following items are currently on the table:
* Further benchmarking
* Performance improvements (if necessary)
* Further testing
* Another code review

-------------------------

jzxchiang | 2022-06-09 21:34:57 UTC | #168

Thanks for the update. Will there not be a ckBTC canister available for testing in the Beta release?

-------------------------

dieter.sommer | 2022-06-10 05:36:28 UTC | #169

Indeed, the ckBTC canister is just not ready for Beta.
The actual ckBTC canister work still needs to start, the involved teams are busy with the other features currently. One engineer and one researcher are, however, currently working on a library that the ckBTC canister will use to very reliably implement the UTXO and Bitcoin transaction handling, which will be one key part of the canister.
Also, there's a dependency on the ledger / token standard that is currently being discussed: The ckBTC canister needs to already implement this standard that is not there yet.

-------------------------

Jaouadtmg | 2022-06-11 14:42:27 UTC | #170

I know you know but sometimes reading it from someone else helps: It is urgent not to rush. The impact of being "late" will be ln(1) compared to a faulty implementation....

-------------------------

dieter.sommer | 2022-07-01 08:30:32 UTC | #171

**Update**

The implementation of the feature for the Beta / Chromium release scope is nearing completion. Next to wrapping up the feature implementation, we still need to work on example code that shows how to use the feature as well as documentation. Launching the feature with a test key within 1-2 weeks can be very realistic.

-------------------------

dieter.sommer | 2022-07-16 18:49:01 UTC | #172

**Update**

The feature is code complete now and we are finishing up the documentation and still need to perform some stress testing in order to make sure everything works as intended when being run on IC Mainnet as well as some benchmarking on Mainnet to get an understanding of the performance of the feature on a 13-node subnet on Mainnet.

We are very close to making the feature available for the general public with a threshold ECDSA test key to be used only for testing purposes.

-------------------------

abc | 2022-07-26 19:43:40 UTC | #173

Excuse me, Can you explain how threshold ECDSA works in solving the problem of on decentralized DNS and decentralized certificate authority?
https://twitter.com/PointNetwork/status/1551975308034727936?s=20&t=PL2hmgvQdxkfxnfA6fX8fw

-------------------------

abc | 2022-07-27 12:02:34 UTC | #174

Thank @bjoerntm very much for your patient and detailed help in your busy schedule!
https://twitter.com/bjoerntm/status/1552235235391283202?s=20&t=-VwUgWEbzNmyWbLu_-Qq8Q

-------------------------

dieter.sommer | 2022-08-03 20:18:22 UTC | #175

Threshold ECDSA Beta released! :rocket:

The threshold ECDSA Beta release, being a key part of the Bitcoin Testnet release, has been officially announced!

https://forum.dfinity.org/t/btc-testnet-icp-integration-the-testnet-is-live/14675

You can now use threshold ECDSA on the IC with a test key. Please note that the test key may be deleted at some point, so it is not advisable to store any value with this key. The test key of the current deployment is intended solely for development and testing purposes, e.g., to hold bitcoin on Bitcoin Testnet.

Documentation:
https://internetcomputer.org/docs/current/developer-docs/functionality/t-ecdsa

Sample dApp:
https://internetcomputer.org/samples/

The team is now working mainly on further performance improvements and another security review as there have been quite some changes since the first one.

Have fun!

-------------------------

dfisher | 2022-08-05 20:43:33 UTC | #176

For the non-technical like me, came across this list so folks can see what the IC can easily integrate with using ECDSA. 

http://ethanfast.com/top-crypto.html

-------------------------

dieter.sommer | 2022-08-15 19:58:53 UTC | #177

[quote="dfisher, post:176, topic:6152"]
For the non-technical like me, came across this list so folks can see what the IC can easily integrate with using ECDSA.
[/quote]

Nice list, thanks for sharing! Shows there's huge potential of this feature and a huge amount of work if we want to unleash all of that. ;-)

**Update**

There's a couple of things that need to be done now to be ready for a mainnet release. The below ones are the main open areas where we will spend most of the engineering time. We can expect 2-3 months until we can release, but this is a rough indication, please do not use this as a firm release date.

*Assurance*
One of the big items here is to increase our assurance of correctness of the implementation. We have already done one external round of code reviews with a world-leading code audit company. We are planning to do another round when the changes that we still want to implement are complete. This will be again with a top-notch external review firm. Review reports will most likely be published. And of course we will be doing lots of testing on our own. For a feature like threshold ECDSA, which will protect large amounts of value, such efforts for quality assurance are crucial to ensure that the chance of security issues and thus the risk of value being lost is reduced to an acceptably tiny value.

*Performance*
In addition to these assurance-related efforts, we still need to work on improving the performance of the implementation. We are currently running the system with the test key on a 13-node subnet. For the production key, we decided to start with a 34-node subnet for the security / decentralization we want to have. This has a major implication on performance, i.e., it will be quite a bit slower there. In order to reach, what we think is an acceptable level of performance, we need to put some more thinking and engineering effort into getting good-enough performance on such larger subnet.

We will keep you posted on the progress!

B.t.w., user @flyq from our community has (against all warnings) already taken the risk to perform a Bitcoin mainnet transaction with the threshold ECDSA test key. After manually crafting a bitcoin transaction to transfer the funds his canister has received back out of the IC again, no Bitcoin was lost and this was the first successful threshold ECDSA-based Bitcoin Mainnet transaction roundtrip on the IC ever! Congratulations! :slight_smile:

The warning still applies to not attach any value to the current t-ECDSA test key. Any experiments are at your own risk if you choose to ignore this warning.

-------------------------

lastmjs | 2022-08-17 12:04:04 UTC | #178

[quote="dieter.sommer, post:177, topic:6152"]
We can expect 2-3 months until we can release, but this is a rough indication, please do not use this as a firm release date.
[/quote]

So we're looking at around November 2022 now? This is a big change in timeline compared to what we've all been told so far, is the 2-3 month timeline based on a new assessment?

-------------------------

h4rdcoder | 2022-08-17 21:54:56 UTC | #179

Do I need to enable something in the local replica to use this feature? I'm getting "No route to canister aaaaa-aa" when calling ecdsa_public_key

-------------------------

dieter.sommer | 2022-08-18 06:51:05 UTC | #180

Indeed, this is very much a pity and I want to apologize for the inconvenience, but here are two key reasons why we cannot release the GA version now:
* We need to get performance to an acceptable level for 34-node or larger subnets. We can currently do 1.5 signatures/s on a 13-node subnet and performance decreases faster than linear with the replication factors. Thus, engineering has to solve some challenge here which does take some time. The performance was impossible to assess upfront, therefore this is a new work item that we could not plan for in any way.
* We need another security audit, which must be done on a final version of the code, if there are too many changes after it, it's meaningless.
* We need to do further testing and reviewing the code ourselves in order to make sure things are as they should be.

If we would release a production key now, it would make moving ahead with optimizations much harder or impossible for the case that optimizations change certain aspects of the protocol. And we cannot start the security review before the code is stable after the optimizations, as otherwise the review would be rather worthless.

Regarding the security-related items, let me quote @mparikh's comment from the Bitcoin thread:

> In this game, “only the paranoid survive”.

How true, we must not take a risk here and release prematurely without the assurance steps we have in mind. Secure must be a top priority for a cryptographic feature like this one.

And w.r.t. performance, we would like to at least get close to 1 signature per second on the large subnet, which would likely be good enough for a first GA release.

Hope this explains a little better why we must do some more work before releasing the feature for production.

-------------------------

dieter.sommer | 2022-08-18 06:52:13 UTC | #181

Do you have the latest SDK installed? Seems like you might be on an older version that does not have the feature (auto-)enabled yet. On the latest SDK in should just work (it is always enabled).

-------------------------

skilesare | 2022-08-18 09:31:51 UTC | #182

[quote="dieter.sommer, post:180, topic:6152"]
We need to get performance to an acceptable level for 34-node or larger subnets. We can currently do 1.5 signatures/s on a 13-node subnet and performance decreases faster than linear with the replication factors. Thus, engineering has to solve some challenge here which does take some time. The performance was impossible to assess upfront, therefore this is a new work item that we could not plan for in any way.
[/quote]

Wow...that is slower than I expected :grimacing: ...while acknowledging that you're doing something amazing, difficult, and novel, what kind of costs are we expecting to call this function?  Seems like it could be expensive and might restrict its usage.

It looks like currently, we're looking at using the system subnet to do these....do we expect it to scale horizontally eventually where we can add more t-ecdsa-specific subnets to enable lots of sig/sec?

-------------------------

lastmjs | 2022-08-18 11:29:06 UTC | #183

Oh yes I agree this should all be done, I'm just hoping the great increase in time limit was indeed unforeseen.

-------------------------

dieter.sommer | 2022-08-18 12:50:47 UTC | #184

[quote="skilesare, post:182, topic:6152"]
Wow…that is slower than I expected :grimacing: …while acknowledging that you’re doing something amazing, difficult, and novel, what kind of costs are we expecting to call this function? Seems like it could be expensive and might restrict its usage.
[/quote]

Performance wise, this is just where you get with this complex kind of protocols. However, the crypto and consensus teams are now spending lots of effort on increasing performance, looking, for example, at measures such as batch verification for artifacts used in the protocol. We are confident to be able to bring this to an acceptable level of performance, but that is what takes time.

[quote="skilesare, post:182, topic:6152"]
It looks like currently, we’re looking at using the system subnet to do these…do we expect it to scale horizontally eventually where we can add more t-ecdsa-specific subnets to enable lots of sig/sec?
[/quote]

We will deploy the production release initially on one 34-node signing subnet and the NNS for key backup.

A scale-out architecture by using k signing subnets is supported by most parts of the architecture already. What would be missing in case we want to enable that in the future, is a deterministic load balancing algorithm in the message routing layer so that signing requests can be transparently dispatched to a signing subnet.

-------------------------

dieter.sommer | 2022-08-18 12:53:47 UTC | #185

[quote="lastmjs, post:183, topic:6152, full:true"]
Oh yes I agree this should all be done, I’m just hoping the great increase in time limit was indeed unforeseen.
[/quote]

Yes, it was! We could not anticipate what the performance of the protocol would be in practice. It comprises so many parts that it was completely infeasible to estimate this from the protocol specification accurately. Once we were running it first with all sub-features enabled on actual subnets, we realized that we will need to spend quite some effort in optimizing the performance of the protocol.

-------------------------

diegop | 2022-08-18 13:59:00 UTC | #186

[quote="dieter.sommer, post:180, topic:6152"]
Indeed, this is very much a pity and I want to apologize for the inconvenience, but here are two key reasons why we cannot release the GA version now:
[/quote]

@dieter.sommer i was not aware of the rationale myself so thank you in explaining it simply enough I can follow (i am by far not in any capacity to opine on Crypto protocols), but I can follow the surprises of performance.

Fwiw, I am grateful to @lastmjs and @skilesare in diving deeper to help us reveal the thinking and memorialize it for others reading this thread.

-------------------------

esquivada | 2022-08-18 15:36:16 UTC | #187

[quote="dieter.sommer, post:184, topic:6152"]
Performance wise, this is just where you get with this complex kind of protocols. However, the crypto and consensus teams are now spending lots of effort on increasing performance, looking, for example, at measures such as batch verification for artifacts used in the protocol. We are confident to be able to bring this to an acceptable level of performance, but that is what takes time.
[/quote]

Thanks for your great work, what you are Achieving is brilliant

-------------------------

Manu | 2022-08-18 16:06:14 UTC | #188

> what kind of costs are we expecting to call this function?

I think in the order of 10B cycles, but of course it depends on how much performance we can get. 

> do we expect it to scale horizontally eventually where we can add more t-ecdsa-specific subnets to enable lots of sig/sec?

Yes

-------------------------

Forreal | 2022-08-19 03:58:09 UTC | #189

Does 1 sig/s mean it can only do 1 tps?

-------------------------

dieter.sommer | 2022-08-19 07:15:37 UTC | #190

Yes. But if demand is higher than this, we can scale out linearly using more signing subnets.

Most of the Bitcoin use on the IC may be anyway through the upcoming ckBTC, i.e., fully on chain on the IC. Only settlement transactions would need to go to the Bitcoin network.

B.t.w., I would be really happy to see 1 trx / sec on the Bitcoin network coming from the IC, that would be around 10% considering the max trx throughput on the Bitcoin network of around 7-10 trx/s. That would be the ultimate success for this feature! :rocket:

-------------------------

skilesare | 2022-08-20 18:59:22 UTC | #191

It looks like eth evm transactions need "v" in the transaction that specifies which point was used.  I see how to get r and s, but what would v be? Is it always the same? Is it per curve?

>`sign_with_ecdsa`: This method returns a new ECDSA signature of the given `message_hash` that can be separately verified against a derived ECDSA public key. This public key can be obtained by calling `ecdsa_public_key` with the caller's `canister_id`, and the same `derivation_path` and `key_id` used here.
The signatures are encoded as the concatenation of the SEC1 encodings of the two values `r` and `s`. For curve `secp256k1`, this corresponds to 32-byte big-endian encoding.

Edit:  Looks like you get it from r:

> Once we have valid values for **r** and **s** , the last piece of the signature is **v** . This value allows you to calculate the public key from a transaction signature. There are a couple of different ways to derive this, but for our purposes, we’ll just use 37 if **r** is even and 38 if **r** is odd, as this follows [EIP-155](https://github.com/ethereum/EIPs/issues/155).

-------------------------

skilesare | 2022-08-20 15:22:57 UTC | #192

Another questions:

> The return result is an extended public key consisting of an ECDSA `public_key` , encoded in [SEC1](https://www.secg.org/sec2-v2.pdf) compressed form, and a `chain_code` , which can be used to deterministically derive child keys of the `public_key` .

Is there code anywhere that demonstrates how to derive these sub-addresses using the chain code?

-------------------------

skilesare | 2022-08-20 15:38:07 UTC | #193

The motoko example: https://m7sm4-2iaaa-aaaab-qabra-cai.ic0.app/?tag=4246322991

Limits the message hash to 32 bytes.  An eth transaction is an arbitrary number of bytes(I'd guess the deployment of a contract could be quite large). Is there a limit to this or a function that we should use to allocate enough cycles for larger strings.

-------------------------

victorshoup | 2022-08-20 15:57:31 UTC | #194

You can sign arbitrary messages, but as per the ECDSA standard, you have to hash the message first. For a number of reasons, we leave it to the canister to hash the message.

-------------------------

skilesare | 2022-08-20 16:32:52 UTC | #195

This makes sense. So for evm this would be a standard sha256 of the RLP encoded transaction?

-------------------------

mparikh | 2022-08-20 23:10:12 UTC | #196

[quote="victorshoup, post:194, topic:6152"]
For a number of reasons, we leave it to the canister to hash the message
[/quote]

Though, in theory, nothing prevents the message itself to be a hash, correct?

-------------------------

timo | 2022-08-21 06:33:33 UTC | #197

[quote="skilesare, post:195, topic:6152"]
So for evm this would be a standard sha256 of the RLP encoded transaction?
[/quote]

I think it’s Keccak for Ethereum.

-------------------------

ysyms | 2022-08-21 12:31:55 UTC | #198

1TPS? We may therefore need more fees to resist similar DOS attacks?Can the same signature be replicated to multiple subnets? Could we be temporarily frozen funds in the signature by a DOS attack?

-------------------------

Manu | 2022-08-22 11:19:43 UTC | #199

> 1TPS? We may therefore need more fees to resist similar DOS attacks?

Yes, the fees will be set to make sure that a subnet burns more ICP than is minted for node providers if all it does is create ECDSA signatures as fast as it can. 

> Can the same signature be replicated to multiple subnets?

Yes, this 1 signature per second estimate is for one subnet. It can scale out such that many subnets can create ecdsa signatures.

-------------------------

Manu | 2022-08-22 11:18:48 UTC | #200

I think https://github.com/dfinity/ic/blob/b8b2eca5bc092b1bba072b1fb6c019489f9b7fb3/rs/crypto/extended_bip32/src/lib.rs#L72 does what you are looking for, does that answer your question?

-------------------------

andrea | 2022-08-23 07:25:35 UTC | #201

Note also that extended BIP32 is compatible with the standard (non-hardened) BIP32 derivation: chain codes and public keys are used in the same way. So if you stick to non-hardened BIP32 derivation paths you should be able to use existing libraries. The only difference with extended BIP32 is that it allows to use longer strings inside the derivation path.

-------------------------

lastmjs | 2022-09-01 15:26:37 UTC | #202

Upon further reflection over the last little while, I'm becoming increasingly concerned about the node operator collusion attack vector. tECDSA has worse BFT properties than ICC, only 1/3 of node operators (secret key share holders) are necessary to collude to create a threshold signature. The current tECDSA subnet has 34 STATIC node operators, meaning that 12 are necessary to collude to sign anything they want.

Is this acceptable security? Is the tECDSA subnet composed of truly independent node operators? Are there 12 independent entities that need to collude, or fewer?

The fact that the subnets are static seems to greatly increase the probability of successful collusion. ICC is based on a static adversary (I'm not sure how related ICC is to tECDSA). Why was this assumption made? This seems woefully inadequate when applying a BFT protocol to the real world.

The decentralization properties (and thus the security properties) of subnets are so very concerning right now. I don't even feel comfortable calling the IC decentralized at this point, I prefer the term progressively decentralizing. But when are we going to address the static node operator collusion attack vector? It may be of the absolute utmost importance compared with everything else when you consider the consequences.

-------------------------

lastmjs | 2022-09-01 15:31:45 UTC | #203

Another quick point maybe to summarize. tECDSA and the Bitcoin Integration are touted as decentralized and non-custodial solutions. Well actually, we depend in the worst case on only 12 known static entities to custody the key shares and use them appropriately. This seems rather custodial to me. Definitely better than 1 party, but seems pretty similar to other bridging solutions that have a small set of validators tasked with security and bridging.

The obvious solution in my mind is truly weaving the node operators and canisters into one giant logical computer, by making subnet node and maybe even canister membership ephemeral and random. At any time node operators could shuffle and perhaps even canisters, so that subnet membership is not static.

The static threat really scares me.

-------------------------

skilesare | 2022-09-01 16:12:39 UTC | #204

As someone going on the road and trying to defend and promote this feature at various places like ETHMexico, Science of Blockchain, and the coming DevCon in Bogata...it would be really helpful to have subnet shuffling on the road map in the highest priority slot(along with boundary node decentralization).

We have the feature set that is years ahead of the market if we can follow through with the decentralization part.

-------------------------

memetics | 2022-09-01 16:38:31 UTC | #205

Holy moly. Invoke a proposal, if we need subnet shuffling & boundary node decentralisation we need it fast. The IC cannot afford a security blunder, especially with other peoples BTC

-------------------------


domwoe | 2023-09-14 21:03:23 UTC | #1

Hello hackers and bounty hunters,

In time for the publication of the mock API for vetKeys and the associated [community conversation](https://internetcomputer.org/live-sessions?source=nav#Community-Conversation-vetKeys-Demo), we'll open a couple of bounties to get you acquainted with the API and its many applications before the actual implementation will be available on the IC.

Interested? Please read on...

## Overview

Status: Closed
Project Type: Cooperative/Contest - Multiple workers can submit work, and the bounty is shared
Time Commitment: Days
Experience Level: Intermediate/Advanced
Size: USD 24'000 in ICP (at time of distribution)
Deadline: September 10th EoD AoE

## Description

The VetKeys bounties are an exciting opportunity for IC developers to participate in the ongoing development and assessment of the vetKeys feature. As part of this program, two demos of the vetKeys feature have been released, and developers are invited to explore the API capabilities, build applications, and provide valuable feedback.

The bounty program focuses on four key use cases: IBE (Identity-Based Encryption), Group Sharing, Timelock Encryption, and Open/Blue skies. Each use case has a prize pool of $6000, offering participants the chance to win rewards for their innovative contributions and valuable feedback on whether the proposed API addresses use case needs. 

**Links to the proposed API and demos**: 
- [vetKD system API proposal](https://github.com/dfinity/interface-spec/pull/158) 
- [E2EE Demo Rust](https://github.com/dfinity/examples/tree/master/rust/vetkd)
- [Encrypted Notes Demo using vetKD (Motoko + Rust)](https://github.com/dfinity/examples/tree/master/motoko/encrypted-notes-dapp-vetkd)
- [ic-vetkd-utils (vetKD user library)](https://github.com/dfinity/ic/tree/master/packages/ic-vetkd-utils)


## Use Cases

There are four key areas in which we'd love to see submissions:

- **IBE** ($6000 prize pool): Identity-Based Encryption (IBE) is a cryptographic scheme where the public key of an entity is derived from its unique identifier, such as an email address, username, or principal. IBE allows for secure communication between entities without the need for exchanging public keys beforehand. Some examples:
    - Encrypted file sharing: Encrypt files and documents based on the identities of authorized users. 
    -  E2EE messaging: Create or extend a messaging application where users could securely communicate without the need for exchanging public keys beforehand.
    - Secure email communication: Traditional email encryption often requires users to use a public key infrastructure (PKI). A secure email dapp could allow users could send encrypted emails based on recipient identifiers (such as email or wallet addresses), eliminating the need for pre-shared keys or complex setups.
    - Private transactions: By encrypting financial data based on user identifiers, you could ensure that only authorized parties can access and process sensitive financial information.

- **Group Sharing** ($6000 prize pool): By Group sharing we refer to the ability to securely share information and resources within a defined group of individuals. Developers can create applications that enable efficient and secure collaboration among group members. For instance: 
    - File-sharing platform: Allow users within a specific group to access and collaborate on shared documents, ensuring only authorized members can view and modify the content.
    - Private social networking: A social networking platform that allows users to create private groups for sharing content, discussions, and media.
    - Gaming communities: Encrypted group sharing can be leveraged in gaming communities to provide a secure platform for players to communicate, share game-related content, and coordinate gameplay.
    
- **Timelock Encryption** ($6000 prize pool): Timelock Encryption involves the concept of encrypting data and setting a time-based restriction on when the encrypted data can be accessed. Participants could build applications that use vetKeys and the IC's notion of time to provide secure access to sensitive information for a specific period. For example 
    - Secure file sharing with expiry: a secure document storage system could use timelock encryption to grant temporary access to confidential files for a limited time.
    - Private voting: Each vote in a voting system could be encrypted with a time-based restriction, ensuring that the vote remains confidential and can only be decrypted within a specific timeframe. This protects the privacy and integrity of the voting process while allowing _authorized authorities_ to decrypt and count the votes during the designated period.
    - Time-limited private auction: Similar to the private voting scenario, bids could be encrypted with a time-based restriction, allowing them to be revealed and considered only within a specified timeframe.
    - MEV protection: Timelock Encryption could be a valuable tool for mitigating Miner/Maximal Extractable Value (MEV) exploits in blockchain-based DeFi systems. Sensitive transaction details could be encrypted with a time-based restriction, ensuring that the contents of the transactions remain confidential until a specified time. 

- **Open / Blue skies** ($6000 prize pool): The Open/Blue skies category is an open-ended opportunity for developers to explore innovative and novel use cases that leverage the vetKeys feature. Participants are encouraged to think outside the box and come up with creative applications that can benefit from the proposed API. For instance, a developer might create a decentralized identity management system that uses vetKeys for secure user authentication and authorization.
    Further inspiration:
    - VRF (Verifiable Random Function): VRF is a primitive that generates random output while providing verifiable proof of its correctness. Developers can explore how VRF can be integrated into applications to generate random numbers or ensure randomness in various scenarios, such as gaming, voting systems, or random selection processes.
    - Witness encryption: Witness encryption is a scheme where the decryption of a ciphertext requires a specific condition or witness to be satisfied. Participants could explore the applications of witness encryption in scenarios like secure multi-party computation, anonymous credentials, or access control systems.

Many of these use cases or variations were described in some detail in the [first community conversation](https://www.youtube.com/watch?v=baM6jHnmMq8).

These bounties are quite open in the sense that it would be great to see new applications being developed and potentially put forward for subsequent grant funding, but it is also ok if the submission is an extension to an existing app (eg the encrypted notes dapp)

## Acceptance Criteria

- Uses the vetKey API
- Falls into one of the use case categories
- Provide feedback on the suggested system API (does it address your needs? A few sentences are enough)
- Demo application deployed to the IC
- Video Pitch/Demo (max. 4min)
- Proper Readme, see [here](https://github.com/dfinity/grant-rfps/blob/main/repo-checklist.md#blue_book-create-an-informative-readme)
- Open Source license (MIT or Apache-2.0)

## Evaluation Criteria

- Design/UX
- Functionality
- Code quality 

## Note
The proposed version of this system API is for demonstration purposes only and should not be used in production.

## How to participate?

Post your submission here in this thread.
Please be aware that [Terms and Conditions](https://support.dfinity.org/hc/en-us/articles/4401932915860-DFINITY-DEVELOPER-GRANT-PROGRAMS-TERMS-AND-CONDITIONS) of the DFINITY Developer Grants Program apply.


## References
* [Forum](https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560)
* [vetKeys Developer Documentation](https://internetcomputer.org/docs/current/developer-docs/integrations/vetkeys/)
* [First community conversation](https://www.youtube.com/watch?v=baM6jHnmMq8)
* [vetKeys primer to understand the crypto background](https://internetcomputer.org/blog/features/vetkey-primer)
* [vetKeys Paper](https://eprint.iacr.org/2023/616.pdf)
* [RWC Talk](https://www.youtube.com/watch?v=-d0Ny7NAG-w&t=3586s)

-------------------------

b3hr4d | 2023-07-11 17:22:22 UTC | #2

Hello everyone,

I'm excited to share some potential plans for participating in the VetKeys bounty program with my project, B3Wallet. B3Wallet is a decentralized, multi-chain digital wallet that I've been developing, and I believe the vetKeys API could significantly enhance its functionality and security.

**Use Case 1: Identity-Based Encryption (IBE)**

One idea I'm considering is implementing a username-password-based login system within B3Wallet. This would provide an alternative to the current login method using Internet Identity, offering users a familiar and straightforward way to access their wallets. The public key of a user would be derived from their unique username, enabling secure communication and transaction signing without the need for exchanging public keys beforehand.

**Use Case 2: Group Sharing**

Another potential enhancement for B3Wallet involves the implementation of a secure backup system for the wallet canister. This backup could be used to restore accounts and signers, ensuring that all users can recover their shared wallet in case of any issues. This would be particularly useful for wallets with multiple signers, such as those used by couples, families, or businesses.

**Use Case 3: Timelock Encryption**

To enhance the security of transactions, I'm considering implementing a password protection feature in B3Wallet. Before a transaction can be signed by a signer, they would need to enter a password. This password could be encrypted with a time-based restriction, ensuring that the transaction remains confidential and can only be processed within a specific timeframe.

**Feedback on the vetKeys API**

So far, I've found the vetKeys API to be well-designed and powerful. It offers a lot of flexibility and potential for enhancing the security and functionality of B3Wallet. I'm looking forward to exploring it further as I consider implementing these features.

**Demo and Documentation**

You can check out the current live version of B3Wallet at [b3wallet.live](https://b3wallet.live/). The source code for B3Wallet is also available on the [B3Wallet GitHub repository](https://github.com/B3Pay/b3-wallet). I will continue to update the live version and the repository as I work on implementing these features and enhancements.

I'm excited about the potential of the vetKeys API and I'm looking forward to seeing how it can enhance B3Wallet and other applications in the Internet Computer ecosystem. I welcome any feedback or suggestions from the community.

Best, 
Behrad

-------------------------

sardariuss | 2023-07-14 03:32:20 UTC | #3

The other day with some friends we were thinking about implementing on the IC the equivalent of an interac in canada (i.e. a transfer of money where the receiver has to find the correct answer to the question the sender asked in order to get the money). With vetkeys we could encrypt the question and answer with the principal of the recipient (IBE use case). Could this be a good candidate for this bounty?
Also I havent checked all the links yet, will the first API be available on motoko or its only in rust?

-------------------------

rabbithole | 2023-07-14 09:44:58 UTC | #4

[quote="sardariuss, post:3, topic:21294"]
will the first API be available on motoko or its only in rust?
[/quote]

you can use `vetkd_system_api` canister in motoko, you can specify vetkd_system_api dependency in dfx.json

```
"main": {
    "dependencies": ["vetkd_system_api"],
    "main": "backend/main.mo",
    "type": "motoko"
},
"vetkd_system_api": {
    "type": "custom",
    "candid": "backend/vetkd_system_api/vetkd_system_api.did",
    "wasm": "backend/vetkd_system_api/vetkd_system_api.wasm.gz",
    "shrink": false
}
```
in `main.mo`, it is enough to import the canister and call its methods
```
import VETKD_SYSTEM_API "canister:vetkd_system_api";
```


[details="Спойлер"]
You may also need types:
```
module {
    type CanisterId = Principal;

    public type VetKDCurve = {
        #bls12_381;
    };

    public type VetKDKeyId = {
        curve : VetKDCurve;
        name : Text;
    };

    public type VetKDPublicKeyRequest = {
        canister_id : ?CanisterId;
        derivation_path : [Blob];
        key_id : VetKDKeyId;
    };

    public type VetKDPublicKeyReply = {
        public_key : Blob;
    };

    public type VetKDEncryptedKeyRequest = {
        derivation_id : Blob;
        encryption_public_key : Blob;
        key_id : VetKDKeyId;
        public_key_derivation_path : [Blob];
    };

    public type VetKDEncryptedKeyReply = {
        encrypted_key : Blob;
    };
};

```
[/details]

You can see an example of encrypted notes with vetKD at [the link](https://github.com/dfinity/examples/blob/master/motoko/encrypted-notes-dapp-vetkd/src/encrypted_notes_motoko/main.mo)

-------------------------

patnorris | 2023-07-25 11:28:07 UTC | #5

Thank you for this exciting feature. I think it's very powerful as this allows for a great UX and is something that (to the best of my knowledge) neither other blockchains and, even more importantly, traditional cloud infrastructure can provide.

I'd like to use vetKeys for the browser-based AI assistant I'm working on (first prototype: https://x6occ-biaaa-aaaai-acqzq-cai.icp0.io/) to encrypt the user's chats when storing them in the backend canister (and thus have a completely private AI chatbot powered by the IC).

If you have any feedback on my proposed idea to use vetKeys, I'd be happy to hear it. While this might not be the most novel or creative idea how to leverage vetKeys, I'm excited to integrate it as I've been looking for a way to guarantee privacy to users.

-------------------------

patnorris | 2023-08-11 16:00:50 UTC | #6

If anyone is looking to use vite instead of webpack, I found this plugin easy to work with and straightforward to integrate ic-vetkd-utils with it: https://github.com/nshen/vite-plugin-wasm-pack (I've also tried this one but wasn't really having much luck with it: https://github.com/Menci/vite-plugin-wasm). This branch has my implementation, so could serve as another example: https://github.com/patnorris/DecentralizedAIonIC/tree/firstClientSideEncryption

-------------------------

patnorris | 2023-08-11 16:31:06 UTC | #7

These are a few questions that came to mind during development so far, would be great to get your input on them:
Once vetKeys are released in production, in which ways will the integration be facilitated? Will there be a library to use in Motoko and Rust? On the frontend, will there be an npm package? If so, what would that package include (e.g. only ic-vetkd-utils or also code like the CryptoService here: https://github.com/dfinity/examples/blob/master/motoko/encrypted-notes-dapp-vetkd/src/frontend/src/lib/crypto.ts)?

I deployed the branch with my current implementation (https://github.com/patnorris/DecentralizedAIonIC/tree/firstClientSideEncryption) to the mainnet and after login it takes ca 18 sec for the Crypto Service to be initiated. Does this seem right? Do you think this could be sped up somehow? After vetKeys are released to production, do you foresee this initiation time to change?

Are there any recommendations you can give how the user (of an app integrating vetKeys) should/could be informed about the encryption? So far, I haven't been able to come up with any additional risk/disadvantage for the user (compared to storing the data "in plain" on the IC), besides maybe the wait time til the crypto service is initiated and that no dev could help them with data recovery in case the user loses access to the account tied to the principal. Do you see any additional risks/disadvantages for the users?

Which other security considerations or best practices are especially important for devs here? I saw you included this security checklist in the example repo (https://github.com/dfinity/examples/blob/master/motoko/encrypted-notes-dapp-vetkd/security-checklist.md), are there any others to add specific to vetKeys?

And some general initial feedback on the integration work; I think the encrypted notes example repo was great and it made it pretty easy to integrate the needed code into mine. The only real blocker I had was getting the wasm from ic-vetkd-utils to work with vite (which I had already been working with) but once I started using vite-plugin-wasm-pack (see comment above), it worked right away. I hadn't paid attention initially that there isn't any vetkd_system_api canister deployed yet on the IC but once understood/properly read, deploying that was also pretty swift and worked without any debugging. Thanks!

-------------------------

NathanosDev | 2023-08-14 14:38:00 UTC | #8

> If anyone is looking to use vite instead of webpack

Thanks for sharing this!

I took an alternative approach that I'll share too. I was able to skip the plugin by setting up a local library using PNPM workspaces. This should also work with NPM or Yarn workspaces. The library is only 3 files.

`Cargo.toml`:
```toml
[package]
name = "vetkd-utils"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
ic-vetkd-utils = { git = "https://github.com/dfinity/ic", rev = "39a0e5858f8b3028252783c742b49f3eb924c287" }
```

`package.json`:
```json
{
  "name": "vetkd-utils",
  "private": true,
  "scripts": {
    "build": "wasm-pack build --target web --release"
  },
  "module": "pkg/vetkd_utils.js",
  "types": "pkg/vetkd_utils.d.ts"
}
```

`src/lib.rs`
```rust
pub use ic_vetkd_utils::*;
```

With this I was able to `import { TransportSecretKey } from 'vetkd-utils'`. This has the advantage of easily being able to update the code commit that's referenced without having to build and distribute the WASM file manually.

> Will there be a library to use in Motoko and Rust

It's a system API, so it will be callable via the Management Canister interface with `cdk-rs` (I don't know what the equivalent is for Motoko, but it should work similarly).

> On the frontend, will there be an npm package

My understanding is that `ic-vetkd-utils` (or some version of it) will be published to NPM.

>  it takes ca 18 sec for the Crypto Service to be initiated

18 seconds is a long time. One thing you could do is merge multiple calls into one. There's a call for the public key and another call for the private key that could be merged. I don't know your app logic well, but maybe there's some other update calls on application boot that could be merged too.

Another thing you could do is cache the keys locally. This needs to be done with care though and you need to be careful of XSS attacks getting access to the keys.

I haven't implemented this myself yet and I'm not a security expert so I can't advocate for how bullet proof (or not) that this solution is, but what I was thinking to do was load the II keys via a web worker (or through an IIFE if web workers don't work), store the II keys in non-extractable crypto key storage, then load the vetKeys from the canister inside the web worker, keep the vetKeys in memory in the web worker but encrypt them and store them in local storage so they can be decrypted with the II keys when the user returns.

-------------------------

patnorris | 2023-08-17 18:56:03 UTC | #9

Thanks, that's a cool approach. Do you have a repo online that implements the local library? Would be interested to take a look.

Yeah, 18 sec is a bit, so definitely worthwile for me to look more into how I can optimize it. I'll post it here if I find something.

Storing the vetKeys encrypted in local storage between sessions sounds like an interesting idea. If I understand correctly, we would thus only have to generate new ones in case none are in the local storage and the tradeoff would be that we might have an additional attack vector (not sure how risky it is either though as the vetKeys are encrypted).

-------------------------

NathanosDev | 2023-08-18 08:55:44 UTC | #10

> Do you have a repo online that implements the local library?

It's not open source, but it's literally just those 3 files that I posted in this file structure. If it's not clear I can put together a separate repo with that setup.

```
- lib/
  - vetkdutils/
    - src/
      - lib.rs
    - package.json
    - Cargo.toml
- src/
  - frontend/
    - package.json (reference "vetkdutils" here)
- package.json
```

> we would thus only have to generate new ones in case none are in the local storage and the tradeoff would be that we might have an additional attack vector

Yes exactly.

> not sure how risky it is either though as the vetKeys are encrypted

I believe XSS is the biggest risk because an attacker could potentially get access to the II keys that are stored in the IndexedDB and then just decrypt everything.

A slightly updated approach that I'm thinking of is using a user provided "pin" to encrypt everything instead of the II credentials. Or to just make the user log in with II every time they leave and come back. 1st approach is harder to implement but more annoying for users. A pin should be easy enough to input quickly.

> Yeah, 18 sec is a bit, so definitely worthwile for me to look more into how I can optimize it. I’ll post it here if I find something.

I'll be interested to see if you find anything!

-------------------------

patnorris | 2023-08-18 14:17:11 UTC | #11

Cool, only needing the 3 files you posted is indeed a nicely simple approach then :)

I don't know enough detail about it but maybe the "pin" could also be the fingerprint sensor or other hardware II is using. So to decrypt their data, users would be asked to confirm via fingerprint or another sensor.

Sounds good, hopefully will find a couple of optimizations.

-------------------------

NathanosDev | 2023-08-18 14:27:27 UTC | #12

>  maybe the “pin” could also be the fingerprint sensor or other hardware II is using

That would be awesome. It would be possible to derive an asymmetric encryption key with WebAuthn using the PRF extension: https://w3c.github.io/webauthn/#prf-extension. This is very new though so I think it will take some time to be implemented.

-------------------------

patnorris | 2023-08-21 15:51:06 UTC | #13

I was able to speed up the initiation time for the Crypto Service by parallelizing some of the calls in its init() function (as you also suggested):
Initializing the wasm (for ic-vetkd-utils) took between 0.5-2 sec, I'm doing this when the app is loaded now (instead of having it as part of the overall init chain).

The two time-relevant functions in Crypto Service's init are encrypted_symmetric_key_for_caller and symmetric_key_verification_key, each takes 8-10 sec. The other functions are pretty much negligible here (i.e. sub 100ms). So when making these two calls in parallel and awaiting them both, we can get to 8-10 sec overall init time (after the user logs in).

I'm wondering if encrypted_symmetric_key_for_caller and symmetric_key_verification_key could be further sped up by making these calls directly to the vetkd_system_api canister (instead of calling the backend canister which then calls vetkd_system_api). Is or will this be possible?

-------------------------

NathanosDev | 2023-08-22 10:23:30 UTC | #14

Good to hear about your speed ups.

So you parallelized on the frontend, interesting. I did it slightly differently, by making a single endpoint on the backend canister that would return both keys:
```rust
#[update]
#[candid_method]
async fn get_key_pair(transport_public_key: Vec<u8>) -> GetKeyPairDto {
    let principal = assert_principal_not_anonymous();
    let user_id = assert_has_user_id(principal).expect("user_id not found");

    let public_key_request = VetKDPublicKeyRequest {
        canister_id: None,
        derivation_path: vec![b"key".to_vec()],
        key_id: bls12_381_test_key_1(),
    };

    let (public_key_response,): (VetKDPublicKeyReply,) = call(
        vetkd_system_api_canister_id(),
        "vetkd_public_key",
        (public_key_request,),
    )
    .await
    .expect("call to vetkd_public_key failed");

    let private_key_request = VetKDEncryptedKeyRequest {
        derivation_id: user_id.into_bytes().to_vec(),
        public_key_derivation_path: vec![b"key".to_vec()],
        key_id: bls12_381_test_key_1(),
        encryption_public_key: transport_public_key,
    };

    let (private_key_response,): (VetKDEncryptedKeyReply,) = call(
        vetkd_system_api_canister_id(),
        "vetkd_encrypted_key",
        (private_key_request,),
    )
    .await
    .expect("call to vetkd_encrypted_key failed");

    GetKeyPairDto {
        public_key: hex::encode(public_key_response.public_key),
        private_key: hex::encode(private_key_response.encrypted_key),
    }
}
```

Your approach may actually be faster. I'll try it out too to compare.

> could be further sped up by making these calls directly to the vetkd_system_api canister

It will be a management canister interface so it will only be callable from your canister. From an access control perspective, it should be hidden behind your backend canister anyway so you can decide who should get access to what key. Otherwise anyone could derive any key they want if it was open to the frontend.

-------------------------

senior.joinu | 2023-08-22 16:35:19 UTC | #15

Getting this error message `Uncaught (in promise) invalid encrypted key: verification failed` while executing the following frontend function:

```ts
export async function getAes256GcmKey() {
    const seed = window.crypto.getRandomValues(new Uint8Array(32));
    const tsk = new vetkd.TransportSecretKey(seed);

    const ekBytes: Uint8Array = await backend.encrypted_symmetric_key_for_caller(tsk.public_key());
    const pkBytes: Uint8Array = await backend.symmetric_key_verification_key();

    return tsk.decrypt_and_hash(
        ekBytes,
        pkBytes,
        Principal.fromText(backendCanisterId).toUint8Array(),
        32,
        new TextEncoder().encode("aes-256-gcm")
    );
}
```
 
against the following backend:
```rust
#[update]
async fn encrypted_symmetric_key_for_caller(encryption_public_key: Vec<u8>) -> Vec<u8> {
    debug_println_caller("encrypted_symmetric_key_for_caller");

    let user_principal = caller();

    let request = VetKDEncryptedKeyRequest {
        derivation_id: user_principal.as_slice().to_vec(),
        public_key_derivation_path: vec![b"symmetric_key".to_vec()],
        key_id: bls12_381_test_key_1(),
        encryption_public_key,
    };

    let (response,): (VetKDEncryptedKeyReply,) = ic_cdk::api::call::call(
        vetkd_system_api_canister_id(),
        "vetkd_encrypted_key",
        (request,),
    )
    .await
    .expect("call to vetkd_encrypted_key failed");

    response.encrypted_key
}

#[update]
async fn symmetric_key_verification_key() -> Vec<u8> {
    let request = VetKDPublicKeyRequest {
        canister_id: None,
        derivation_path: vec![b"symmetric_key".to_vec()],
        key_id: bls12_381_test_key_1(),
    };

    let (response,): (VetKDPublicKeyReply,) = ic_cdk::api::call::call(
        vetkd_system_api_canister_id(),
        "vetkd_public_key",
        (request,),
    )
    .await
    .expect("call to vetkd_public_key failed");

    response.public_key
}

fn bls12_381_test_key_1() -> VetKDKeyId {
    VetKDKeyId {
        curve: VetKDCurve::Bls12_381,
        name: "test_key_1".to_string(),
    }
}

fn vetkd_system_api_canister_id() -> CanisterId {
    CanisterId::from_str(VETKD_SYSTEM_API_CANISTER_ID).expect("failed to create canister ID")
}

fn debug_println_caller(method_name: &str) {
    ic_cdk::println!(
        "{}: caller: {} (isAnonymous: {})",
        method_name,
        ic_cdk::caller().to_text(),
        ic_cdk::caller() == candid::Principal::anonymous()
    );
}
```

The [example project](https://github.com/dfinity/examples/tree/master/rust/vetkd) was working just fine for me. The code above is based on that example and is only slightly different from it - instead of using hex encoded strings I pass raw blobs around. Can this be the source of an issue?

UPD:
Tried to move back to passing hex encoded strings, but getting the same error.

UPD1:
Found the problem. It is [in this line](https://github.com/dfinity/examples/blob/master/rust/vetkd/src/app_frontend_js/src/index.js#L98). Not in the line itself, but in how client's principal is named `app_backend_principal` for some reason. I tried to put backend canister's principal in it. 

Everything is good now. Thanks!

-------------------------

patnorris | 2023-08-23 17:00:56 UTC | #16

Cool, thanks for sharing. It'll be interesting to see which speed ups we get with the different approaches. 

A while back, I wanted to make calls on the backend canister in parallel and wrote something like this:
let executingFunctionsBuffer = Buffer.Buffer<async ?Entity.Entity>(entityIds.size());
    for (entityId in entityIds.vals()) { 
      executingFunctionsBuffer.add(get_entity(entityId)); 
    };
    let collectingResultsBuffer = Buffer.Buffer<Entity.Entity>(entityIds.size());
    var i = 0;
    for (entityId in entityIds.vals()) {
      switch(await executingFunctionsBuffer.get(i)) {
        case null {};
        case (?entity) { collectingResultsBuffer.add(entity); };
      };      
      i += 1;
    };
    return collectingResultsBuffer.toArray(); 

does this actually make the calls in parallel (and thus speed up the execution as the canister can await all calls at the same time)? Could this be something to be used here as well (so making the two calls to get the two keys in parallel)?
The main difference I can see is that the two return types are different here (public_key_response and private_key_response) vs. having multiple of the same call as in my example, so not sure if it can be implemented easily.

-------------------------

NathanosDev | 2023-08-25 15:38:15 UTC | #17

This is not my forte, but I've asked internally for help understanding this.

> does this actually make the calls in parallel

You can handle those concurrently, but not in parallel. So it could be that making the calls in parallel on the frontend would be better. I'll try that out at some point.

-------------------------

timk11 | 2023-08-26 16:22:58 UTC | #18

@NathanosDev 
> I took an alternative approach that I’ll share too. I was able to skip the plugin by setting up a local library using PNPM workspaces. This should also work with NPM or Yarn workspaces. The library is only 3 files.

I gave this a try in my project, then added this to my main `package.json` (there isn't one in the `frontend` folder):
```
"dependencies": {
    ...
    "vetkd-utils": "file:./vetkd_utils"
  },
```

However, this gives me an error
```
ERROR in ./src/group_sharing_frontend/src/index.js 4:0-49
Module not found: Error: Can't resolve 'vetkd-utils' in '/home/timk/ic/group_sharing/src/group_sharing_frontend/src'
resolve 'vetkd-utils' in '/home/timk/ic/group_sharing/src/group_sharing_frontend/src'
  Parsed request is a module
  using description file: /home/timk/ic/group_sharing/package.json (relative path: ./src/group_sharing_frontend/src)
    Field 'browser' doesn't contain a valid alias configuration
    resolve as module
      /home/timk/ic/group_sharing/src/group_sharing_frontend/src/node_modules doesn't exist or is not a directory
...
```

Line 4 of `index.js` is
`import { TransportSecretKey } from "vetkd-utils";`

File structure is like so:
```
├── src
│   └── group_sharing_frontend
│        └── src
│             └── index.js
├── vetkd_utils
│   ├── Cargo.toml
│   ├── package.json
│   └── src
│       └── lib.rs
└── package.json
```

Not sure what I'm doing wrong there. Any ideas?

-------------------------

NathanosDev | 2023-08-26 21:22:35 UTC | #19

You need to use some form of workspaces to make this work. NPM, PNPM or Yarn workspaces should all work, but they may require a slightly different configuration. I used a PNPM workspace.

A workspace will link "vetkd-utils" into your node_modules so that you can import it in your frontend project.

-------------------------

timk11 | 2023-08-27 07:37:14 UTC | #20

Thanks! PNPM is new to me, but I found some information and followed all the steps. When trying to deploy I now get this:
```
ERROR in ./src/vetkd_utils/src/lib.rs 1:4
Module parse failed: Unexpected token (1:4)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
> pub use ic_vetkd_utils::*;
```
I haven't so far been able to find what I need to change in `webpack.config.js` in order to resolve this.

-------------------------

b3hr4d | 2023-08-27 08:35:42 UTC | #21

Add this to your webpack.config.js file may fix your problem.
```
  experiments: {
    asyncWebAssembly: true,
  },
  module: {
    rules: [
      {
        test: /\.wasm$/,
        type: "webassembly/async", // This is the key part
      },
      // other roles...
    ],
  },
```

-------------------------

rabbithole | 2023-08-27 12:17:25 UTC | #22

[quote="timk11, post:18, topic:21294"]
Any ideas?
[/quote]
I use `rxjs` in my application, maybe my approach will work for you. 
If you use `typescript` add `custom.d.ts` file and write:
```
declare module 'vetkd_user_lib/ic_vetkd_utils' {
    export class TransportSecretKey {
        constructor(seed: Uint8Array);
        free(): void;
        public_key(): Uint8Array;
        decrypt_and_hash(
            encrypted_key_bytes: Uint8Array,
            derived_public_key_bytes: Uint8Array,
            derivation_id: Uint8Array,
            symmetric_key_bytes: number,
            symmetric_key_associated_data: Uint8Array
        ): Uint8Array;
    }
}
```
I did the loading of the wasm module from bytes as follows:
```
import { fromFetch } from 'rxjs/fetch';
import { map } from 'rxjs/operators';
import { TransportSecretKey, initSync } from 'vetkd_user_lib/ic_vetkd_utils';

export function loadWasm() {
    return fromFetch('vetkd_user_lib/ic_vetkd_utils_bg.wasm', {
        selector: response => response.arrayBuffer()
    }).pipe(
        map(buffer => {
            const module = new WebAssembly.Module(buffer);
            return initSync(module);
        })
    );
}
```
The `loadWasm` operator I call in the web worker:
```
// Actually i use state manager and do something like
// state.connect('wasmLoaded', loadWasm().pipe(map(() => true)));
// but you can just subscribe to loadWasm
loadWasm().subscribe(); 
```

-------------------------

timk11 | 2023-08-27 16:23:10 UTC | #23

Thanks for the pointers! The webpack changes solved part of the problem. I've been working on this for a while and have copied in vetkd stuff to my code from various sources, so rather than trying to trace back through the changes I started afresh and replaced all my vetkd content with the tgz and src/system_api from https://github.com/dfinity/examples/tree/master/motoko/vetkd. This made the project deployable (again) so now I'm sifting through the finer details and will hopefully have it debugged in time for the deadline.

-------------------------

NathanosDev | 2023-08-27 21:40:55 UTC | #24

If PNPM is causing problems then it may be better to leave that for after the deadline, but if you decide to give it another shot, sharing your project will make it easier to know what's wrong. You shouldn't need any changes to Webpack or Typescript declaration files to make this approach work.

-------------------------

timk11 | 2023-08-28 00:15:09 UTC | #25

I found PNPM really good to use. I ended up making a few tweaks. The full set of changes were as follows:

vetkd_utils/Cargo.toml: unchanged from yours

vetkd_utils/package.json:
```
{
  "name": "vetkd-utils",
  "private": true,
  "scripts": {
    "build": "wasm-pack build --target web --release"
  },
  "module": "pkg/vetkd_utils.js",
  "types": "pkg/vetkd_utils.d.ts",
  "main": "src/lib.rs"    [added this line]
}
```

vetkd_utils/src/lib.rs:
```
#[no_mangle]
pub use ic_vetkd_utils::*;
```

package.json (main) - added:
```
  "dependencies": {
    "vetkd-utils": "workspace:*",
    ...
  }
```

webpack.config.js - added:
```
module.exports = {
  experiments: {
    asyncWebAssembly: true,
  },
  optimization: {
  module: {
    rules: [
      { test: /\.rs$/, use: [
        {loader: 'wasm-loader'},
        {loader: 'rust-native-wasm-loader', options: {release: true}}
      ]},
      { test: /\.wasm$/, type: "webassembly/async",},
    ]
  },
  ...
}
```
This made the project deployable, but I then started getting
```
Uncaught runtime errors:
ERROR
vetkd_utils__WEBPACK_IMPORTED_MODULE_3__.TransportSecretKey is not a constructor
get_aes_256_gcm_key@http://localhost:8080/index.js:24970:15
```
The line referred to here was
`  const tsk = TransportSecretKey(seed);`.
Changing it to
`  const tsk = vetkd_utils.TransportSecretKey(seed);`.
gave
`vetkd_utils__WEBPACK_IMPORTED_MODULE_3__.TransportSecretKey is undefined`.

I couldn't see the problem from looking at the Rust source code. If this worked well for you without making all these changes then I figured it must be an error (or errors) within the numerous small changes I've made to the provided code as I've been working on this. I can share this whole version of the project if you like but for now I've put this aside and am using the vetkd components from examples/motoko/vetkd. Once I have it working it fully I might try switching your method back in.

-------------------------

HeisenbergLin22 | 2023-08-28 11:03:15 UTC | #27

We only decided to work on the bounty a few days ago. The submission deadline for the bounty is August 31st, but we don’t think we’ll be able to deliver at this time since there are only a few days left. Do you think we could extend the delivery submission deadline by 4 weeks? Thanks.

-------------------------

domwoe | 2023-08-28 11:28:49 UTC | #28

Awesome that you'd like to join the bounty.

In the recent ckBTC Point-of-Sale bounty we had an extension of one week. If there is a general request from participants to extend the deadline by a week, then we'd be open to it. A 4-week extension, however, could not be considered.

-------------------------

NathanosDev | 2023-08-28 11:33:59 UTC | #29

I see based on your Webpack config that you are expecting to import the `.rs` file directly, but that's not the case. The `build` script from `vetkd_utils/package.json` will output JavaScript and WASM files.

If you manually run the `wasm-pack build --target web --release` command inside the `vetkd_utils` folder then you should see that the files are output to the `vetkd_utils/pkg` folder. This will be normally run by PNPM anyway, but running it manually first can help debug any issues with the command.

I didn't need the `main` field, but I'm using Vite. If you need the `main` field for Webpack, it shouldn't point to the `src/lib.rs` file, but to the `pkg/vetkd_utils.js` file instead.

With that in mind, the `/\.rs$/` rules that you have in `webpack.config.js` are not necessary, since you'll be importing JS files, not RS files. The other WASM configuration may be necessary, I'm not sure since I didn't try this setup with Webpack.

One last point, I have three package.json files. It sounds like you have two. Mine is setup like this:
```
- lib/
  - vetkdutils/
    - src/
      - lib.rs
    - package.json
    - Cargo.toml
- src/
  - frontend/
    - package.json (reference "vetkdutils" here)
- package.json
```

I don't think that's an issue, but in case the above points don't fix your problem, it may also be worth checking. To make `dfx build` work with a nested `package.json`, you need to supply a custom build step:

```json
{
  "canisters": {
    // ...
    "frontend": {
      "dependencies": ["backend"],
      "frontend": {
        "entrypoint": "src/frontend/src/index.html"
      },
      "source": ["src/frontend/dist"],
      "type": "assets",
      "build": ["pnpm -F frontend... build"]
    },
    // ...
  },
  // ...
}
```

-------------------------

timk11 | 2023-08-28 13:27:02 UTC | #30

I'd like to see the bounty deadline extended by a week if possible.

-------------------------

timk11 | 2023-08-28 13:55:21 UTC | #31

Yes, that's right. I only had two package.json files. I think I've made it all somewhat more complicated than it needed to be. I'll have a good look through that to get my head around it.

I'm making good headway with the alternative approach, borrowing from examples/motoko/vetkd. Most of the functionality is now working, except that I'm now getting `invalid encrypted key: verification failed` errors whenever I try to encrypt or decrypt.

Question: In these two functions -
```
    public shared ({ caller }) func symmetric_key_verification_key() : async Text {
        let { public_key } = await vetkd_system_api.vetkd_public_key({
            canister_id = null;
            derivation_path = Array.make(Text.encodeUtf8("symmetric_key"));
            key_id = { curve = #bls12_381; name = "test_key_1" };
        });
        Hex.encode(Blob.toArray(public_key));
    };

    public shared ({ caller }) func encrypted_symmetric_key_for_caller(encryption_public_key : Blob) : async Text {
        let { encrypted_key } = await vetkd_system_api.vetkd_encrypted_key({
            derivation_id = Principal.toBlob(caller);
            public_key_derivation_path = Array.make(Text.encodeUtf8("symmetric_key"));
            key_id = { curve = #bls12_381; name = "test_key_1" };
            encryption_public_key;
        });
        Hex.encode(Blob.toArray(encrypted_key));
    };
```
\- is it permissible to change "symmetric key" to something else? I've gone with
```
  public shared({ caller }) func symmetric_key_verification_key(role: Role): async Text {
    let { public_key } = await vetkd_system_api.vetkd_public_key({
      canister_id = null;
      derivation_path = Array.make(Text.encodeUtf8(toText(role)));
      (etc)
```
and similarly for the second function, having previously defined `type Role = { #Admin; #Manager; #User }` and a `private func toText` function. Is this likely to upset the whole process?

-------------------------

b3hr4d | 2023-08-28 19:19:31 UTC | #32

No problem from me. I'm excited to see more projects embracing this revolutionary new feature!

-------------------------

hawk | 2023-08-28 19:38:41 UTC | #33

Hello. I would like to participate in this bounty and I have implemented Secret Oracle in Rust, which most likely falls under the category of Group Sharing in the use case defined by domwoe. This is my first time participating in a bounty, so I would appreciate feedback on whether my demo meets your expectations.
https://github.com/0xhawk/secret-oracle

-------------------------

b3hr4d | 2023-08-28 19:55:32 UTC | #34

Great job on getting started with your project! I noticed that it's similar to the example from the demo post. To enhance your project, consider focusing on improving the user interface. Adding your own creative touch to the design can make a significant difference.

By the way, if the bounty gets extended for one more week, it could provide you with a bit more time to refine and enhance your project.

Keep up the good work, and I'm looking forward to seeing your project evolve!

-------------------------

domwoe | 2023-08-29 08:47:07 UTC | #35

@hawk Awesome project! Please refer to the acceptance criteria.

[quote="domwoe, post:1, topic:21294"]
## Acceptance Criteria

* Uses the vetKey API
* Falls into one of the use case categories
* Provide feedback on the suggested system API (does it address your needs? A few sentences are enough)
* Demo application deployed to the IC
* Video Pitch/Demo (max. 4min)
* Proper Readme, see [here ](https://github.com/dfinity/grant-rfps/blob/main/repo-checklist.md#blue_book-create-an-informative-readme)
* Open Source license (MIT or Apache-2.0)
[/quote]

From what I see, you're missing:

* Provide feedback on the suggested system API (does it address your needs? A few sentences are enough)
* Demo application deployed to the IC
* Video Pitch/Demo (max. 4min)

-------------------------

domwoe | 2023-08-29 08:50:15 UTC | #36

I suggest we postpone the deadline to **September 10th**. I'll update the official deadline if there's no objection until tomorrow.

-------------------------

NathanosDev | 2023-08-29 08:58:04 UTC | #37

From @franzstefan 

> This is definitely permissible, yes. `"symmetric_key"` was just an example derivation path we used, but it could be anything. What’s important is that the same bytes are used when calling `vetkd_system_api.vetkd_public_key` and `vetkd_system_api.vetkd_encrypted_key`.

Are you sure in your case now that you're using the same `role` value for `derivation_path` when calling `vetkd_system_api.vetkd_public_key` as you are for `public_key_derivation_path` when calling `vetkd_system_api.vetkd_encrypted_key`?

-------------------------

ais | 2023-08-29 14:37:08 UTC | #38

If you're allowed to give extensions, am I allowed to give bonus points for a super nice UI? :slight_smile:

-------------------------

domwoe | 2023-08-29 14:39:31 UTC | #39


Sure, it's the first evaluation criteria as it should be for a crypto heavy application :slight_smile: 

[quote="domwoe, post:1, topic:21294"]
## Evaluation Criteria

* Design/UX
* Functionality
* Code qualit
[/quote]

-------------------------

conorseed | 2023-08-29 22:44:14 UTC | #40

@domwoe - I notice that part of the acceptance criteria is that there's a demo app deployed to the IC. This is probably a stupid question and I'm probably completely missing something here, but isn't the vetKD api still to be implemented on the IC? Which means, the demo wouldn't be functional?

-------------------------

cyberowl | 2023-08-30 00:03:29 UTC | #41

You can deploy the canister `vetkd_system_api` and it should work, but yeah I mean it should not be used in prod applications until mainet launch of `vetkd_system_api`. However, it is good for demo.

-------------------------

NathanosDev | 2023-08-30 08:51:47 UTC | #42

This definitely works :) I've tried it.

-------------------------

senior.joinu | 2023-08-30 13:56:06 UTC | #43

But it should be fine to submit a little bit early, right?

## Submission category
**Identity Based Encryption** - we're gonna encrypt user's digital documents using an encryption key derived from user's Metamask address.

## Project
Kwic - digital document based proof of personhood system. More info in the repo and demo video.

**Live on the IC:**
https://nfgqb-myaaa-aaaak-ae5rq-cai.icp0.io/

Please, make sure you only access this website with your desktop. The mobile version is not ready.
Also, make sure you have Metamask browser extension installed (maybe other web3 providers would also work, but idk). Let me know if you have any troubles following the scenario from the pitch video (attached below).

**Github repo:**
https://github.com/seniorjoinu/kwic
The repository contains some short clues on how to implement each feature from this demo, but let me know if you need a more detailed overview.

## Demo video
https://www.youtube.com/watch?v=awKZAPZeAdI

## VetKeys feedback
I believe this is truly the most powerfull feature you've released this year. It will enable a lot of crazy stuff in the future. The API is simple and easy to use, but requires more documentation of what parameter does what exactly.

**P.S.**
This is my first use-case bounty, so I don't know what is the expected quality of the project - should it just demonstrate a single working scenario (how I did) or should it be a ready-to-use MVP. Let me know, if the project should be improved to be accepted as a submission to this bounty.

-------------------------

conorseed | 2023-08-30 23:45:17 UTC | #44

# 📝 Introducing FormThing: End to End Encrypted Forms on the Blockchain

A proof of concept enabling you to create beautiful, fully accessible forms and control your own data.

This could be entered in to either of the **IBE** or **Group Sharing** categories - I'll let the judges decide where it best fits as I'm not quite sure!

![screenshot|690x409](upload://ltlLiNIRl1DJqtLrhNargPFj8dc.jpeg)

## 👋 Introduction

FormThing was created for Web3 companies to "do forms" the Web3 way:

- Login via Web3 wallet ([Internet Identity](https://identity.ic0.app/))
- Create and manage forms as needed
  - Manage user access to forms and submissions
  - Turn submissions on or off (active / inactive form)
- Share public URL to created forms for submissions
- Store your data on the blockchain instead of trusting it to the big boys (Google Forms, Typeform etc). Form submissions:
  - Are End-to-end encrypted
  - Only readable by who you choose to give access
  - Cannot be read by the blockchain nor the smart contract
  - Protected from spam by a simple nonce system
  - Exportable to CSV to do with as you please

**Full information about how it all works can be found in the Github repo linked below.**

## 🔗 Helpful Links
* [Walkthrough Video](https://vimeo.com/859550637/7d0b647223)
* [Github Repo](https://github.com/conorseed/formthing_poc)
* [Frontend Demo](https://6w54s-qaaaa-aaaan-qeaba-cai.icp0.io/)
* [Backend API](https://a4gq6-oaaaa-aaaab-qaa4q-cai.raw.icp0.io/?id=676xo-giaaa-aaaan-qeaaq-cai)

## 🔑 vetKey system API
This was easy to use and addresses the needs for this use case. I was [initially concerned](https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560/124?u=conorseed) after looking at the demos and playing with using `symmetric_key` as the `derivation_path`, until ya'll [pointed me in the right direction](https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560/127?u=conorseed) and [updated the demos and vetkd_utils](https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560/129?u=conorseed) to include `ibe_encryption`. Once I'd wrapped my head around that, it was extremely simple to then gate-keep who gets access to derive a given key. 

## 💬 Feedback
Please reach out to me if you have any feedback - I'd love to hear it!

*Edit 1: Update video link*
*Edit 2: Add in vetKey system API feedback*

-------------------------

rabbithole | 2023-09-02 21:44:49 UTC | #45

## Rabbit Hole

[Rabbit Hole](https://rabbithole.app) is an encrypted file service that runs fully on-chain and allows you to keep your files safe and secure. All files that you throw into the rabbit hole will be encrypted and placed in the storages of the decentralized Internet Computer. The data is encrypted with your private key, which only you have, which excludes any unauthorized access. Now you are the full owner of your data.

![screen|678x500](upload://kbW9Gi2Nv3dtGZjKFz9Gu7pnyG6.jpeg)


If possible, I would like to apply in the following categories:

**IBE** - the user stores files in encrypted form. The user's principal is used as the `derivation_id`, the `derivation_path` contains the file identifier.
**Group Sharing** - the user can share files to any other users by selecting them from the list. It is also possible to make the file public via a link.
**Timelock** - when sharing a file, the user can optionally specify a date until which the encrypted key will not leave the canister.
*For fairness, I note that this is still IBE. The restriction is based on the current time on the node and the field in the metadata of the shared file ([link on the post](https://forum.dfinity.org/t/threshold-key-derivation-privacy-on-the-ic/16560/111?u=rabbithole)). Perhaps a timeslot-based implementation would be better suited to participate in this category, so that the `derivation_id` is formed from the value of the timeslot.*

## :link: Links
* [Rabbithole.app](https://rabbithole.app)
* [Demo video](https://youtu.be/ZAf8h6CFrMk)
* [Repository](https://github.com/rabbithole-app/rabbithole)

## :eyes: What's next?
Collaboration of several users in one log is the next goal of the application roadmap. The user can create a journal and add other users to it and assign different rights for each user (read/write/etc.).

I've marked completed and upcoming tasks in the repository in the [readme](https://github.com/rabbithole-app/rabbithole#readme) file to better reflect the current development status.

## :key: vetKey API
I've been waiting for this feature since the discussion about it started. Only 2 methods for a developer, but so much magic and enormously important work inside. From impatience, I tried to start using it back in early July, and then trying to figure out the difference between `key_id`, `derivation_id`, `derivation_path` almost drove me crazy. The appearance of examples in the official repository has greatly improved the situation. This is an incredibly powerful feature, the team provides unique opportunities for developers. I hope as many devs as possible hear about it and join us. In the future, I would like to get a library for Motoko, with which it will be possible to work with cryptography.

## :warning: Disclaimer:
*The application is under active development and uses the vetKeys feature, which is not yet implemented on the IC system interface. I **do not recommend** using the app to store sensitive data until further notice. I reserve the right to update user's canisters in any mode (upgrade or reinstall). Use this application only to test the capabilities of the [Internet Computer](https://internetcomputer.org).*

If you have ideas, wishes, feedback (or no invitation code :eyes:) - I will be glad to receive a message from you.

-------------------------

conorseed | 2023-09-02 23:07:22 UTC | #46

Super cool 😎 Might need to collab with Rabbit Hole to get encrypted file uploads for [FormThing](https://formthing.com) going! Could it work for other canisters to interact with Rabbit Hole?

-------------------------

timk11 | 2023-09-03 15:00:31 UTC | #47

I checked carefully and I'm pretty sure I'm using the same `role` value. Here's the code I'm using:

`index.js`:
```
// Function to update encrypted content for the user's role
document.getElementById("updateContent").addEventListener("submit", async (e) => {
  e.preventDefault();
  const roleInput = document.getElementById("role_input4").value;
  const fetched_symmetric_key = await get_aes_256_gcm_key(roleInput);
  const ciphertext = await aes_gcm_encrypt(document.getElementById("content_input").value, fetched_symmetric_key);
  await actor.addContent(ciphertext, JSON.parse(roleInput));
});

async function get_aes_256_gcm_key(roleInput) {
  const seed = window.crypto.getRandomValues(new Uint8Array(32));
  const tsk = new vetkd.TransportSecretKey(seed);
  const ek_bytes_hex = await actor.encrypted_symmetric_key_for_caller(tsk.public_key(), JSON.parse(roleInput));
  const pk_bytes_hex = await actor.symmetric_key_verification_key(JSON.parse(roleInput));
  return tsk.decrypt_and_hash(
    hex_decode(ek_bytes_hex),
    hex_decode(pk_bytes_hex),
    app_backend_principal.toUint8Array(),
    32,
    new TextEncoder().encode("aes-256-gcm")
  );
};

async function aes_gcm_encrypt(message, rawKey) {
  const iv = window.crypto.getRandomValues(new Uint8Array(12)); // 96-bits; unique per message
  const aes_key = await window.crypto.subtle.importKey("raw", rawKey, "AES-GCM", false, ["encrypt"]);
  const message_encoded = new TextEncoder().encode(message);
  const ciphertext_buffer = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv: iv },
    aes_key,
    message_encoded
  );
  const ciphertext = new Uint8Array(ciphertext_buffer);
  var iv_and_ciphertext = new Uint8Array(iv.length + ciphertext.length);
  iv_and_ciphertext.set(iv, 0);
  iv_and_ciphertext.set(ciphertext, iv.length);
  return hex_encode(iv_and_ciphertext);
};
```
`main.mo`:
```
  public shared({ caller }) func symmetric_key_verification_key(role: Role): async Text {
    let { public_key } = await vetkd_system_api.vetkd_public_key({
      canister_id = null;
      derivation_path = Array.make(Text.encodeUtf8(toText(role)));
      key_id = { curve = #bls12_381; name = "test_key_1" };
    });
    Hex.encode(Blob.toArray(public_key))
  };

  public shared ({ caller }) func encrypted_symmetric_key_for_caller(encryption_public_key : Blob, role: Role) : async Text {
    let caller_blob = Principal.toBlob(caller);
    let { encrypted_key } = await vetkd_system_api.vetkd_encrypted_key({
      derivation_id = Principal.toBlob(caller);
      public_key_derivation_path = Array.make(Text.encodeUtf8(toText(role)));
      key_id = { curve = #bls12_381; name = "test_key_1" };
      encryption_public_key;
    });
    Hex.encode(Blob.toArray(encrypted_key));
  };
```
\
**Update** - Solved it! Within the "login" function, I changed
`app_backend_principal = await Actor.agentOf(actor).getPrincipal();`
to
`app_backend_principal = identity.getPrincipal();`.

I noticed this variable was holding the same value and length (a one-element array) as the anonymous identity even after logging in with II. This change fixed it and the error stopped occurring.

-------------------------

rabbithole | 2023-09-03 08:25:02 UTC | #48

[quote="conorseed, post:46, topic:21294"]
Could it work for other canisters to interact with Rabbit Hole?
[/quote]
Unfortunately, this is not supported in this version, but I thought about this possibility and would like to move some logic to separate client libraries. Thank you!

-------------------------

icarus | 2023-09-03 11:51:04 UTC | #49

So far this bounty **BNT-8 - vetKeys - Enabling Privacy Preserving Applications on the IC** is proving to be a great generator of interesting and useful examples of IC mini-dapps. I think all the submitting developers should win something and I know everyone and the IC are winners with this one!

-------------------------

patnorris | 2023-09-06 17:12:53 UTC | #50

## Browser-based AI Chatbot Served From The IC - Now With State-of-the-Art Privacy

DeVinci is the browser-based AI chatbot app served from the Internet Computer. You can chat with the AI model loaded into your browser so your chats remain fully on your device. If you choose to log in, you can also store your chats on the Internet Computer and reload them later.

## On vetKeys

DeVinci uses vetKeys to encrypt all user chats before they are being stored. The logged in user's Principal is being used for this. When the user wants to reload or preview a chat, the messages are first being decrypted. Thus, vetKeys enables DeVinci to store fully private chats and to offer a private, decentralized AI chat app.

Try DeVinci with the vetKeys encryption enabled [here](https://khpys-xiaaa-aaaap-abj3a-cai.icp0.io/)

Note, this isn't the DeVinci "production" app though (see below).

## Feedback

I’ve been excited about vetKeys as I haven’t seen anything like it; privacy with great UX and something that (to the best of my knowledge) neither other blockchains or, even more importantly, traditional cloud infrastructure can provide. In general, I could see this feature enabling the IC to offer “privacy-as-a-service” to all kinds of Web2 and Web3 apps.

Integrating the vetKeys API: The encrypted notes example repo was great and it made it pretty easy to integrate the needed code into mine. The only real blocker I had was getting the wasm from ic-vetkd-utils to work with vite (which I had already been working with) but once I started using vite-plugin-wasm-pack, it worked right away. I hadn’t paid attention initially that there isn’t any vetkd_system_api canister deployed yet on the IC but once understood/properly read, deploying that was also pretty swift and worked without any debugging. So the integration work was straightforward and working with this new feature was really pleasant, especially as vetKeys were running perfectly right from the start once integrated and the API only had few functions that needed to be used.

Speed of initializing encryption service: I brought the time down to ca 10 sec (by making the calls from the frontend in parallel) but it would be great if this could be decreased further. Do you think this could be sped up somehow? After vetKeys are released to production, do you foresee this initiation time to change?

Combining vetKeys with local storage: as it came up in this thread and I find it interesting; to which extent would you recommend approaches that cache the keys (e.g. to not have to initialize them again)? Which optimizations might work well with vetKeys?

Recommendations and best practices: I think it’d be great if you could release a primer on a few general security aspects around vetKeys. E.g. Are there any additional risks/disadvantages for the users and could they be mitigated? Are there any best practices or guidelines devs should follow specific to vetKeys?

I hope that vetKeys will be released soon such that I can release my integration to production as well. Thank you.

## Categories

IBE & Open / Blue skies

## Readme

Please find [the Readme here](https://github.com/patnorris/DecentralizedAIonIC)

## References

* [DeVinci showcase stage with vetKeys integration](https://khpys-xiaaa-aaaap-abj3a-cai.icp0.io/)

* [Video](https://drive.google.com/file/d/1bWQVAOTZnNyMm2gc3AIlqd0RK4_WNB7J/view?usp=sharing)

* [Feature branch with vetKeys changes](https://github.com/patnorris/DecentralizedAIonIC/tree/firstClientSideEncryption)

* [Forum post: Browser-based AI Chatbot Served From The IC](https://forum.dfinity.org/t/browser-based-ai-chatbot-served-from-the-ic/22263)

* [DeVinci "production" app without vetKeys integration (but hopefully soon released :) )](https://x6occ-biaaa-aaaai-acqzq-cai.icp0.io/)

## Note:

DeVinci is running live on the Internet Computer. The "production" stage doesn't have the vetKeys changes integrated yet though - that's only on the showcase stage (as noted above). You can give the "production" DeVinci a try here: [https://x6occ-biaaa-aaaai-acqzq-cai.icp0.io/ ](https://x6occ-biaaa-aaaai-acqzq-cai.icp0.io/) For the showcase stage with vetKeys integration, please see here: [https://khpys-xiaaa-aaaap-abj3a-cai.icp0.io/ ](https://khpys-xiaaa-aaaap-abj3a-cai.icp0.io/)

Please let me know if you have any feedback, thanks :)

-------------------------

lukevoz | 2023-09-06 18:32:41 UTC | #51

# Nostric - a simple Nostr client running on the ICP

Hello, I am submitting our project for the vetKeys bounty. We developed a very simple Nostr client running on the ICP and implemented vetKeys so we can securely store private keys in the backend of the application. This is great from security perspective as well as user experience for Nostr users as they do not need to handle their private keys manually and use some chrome extensions to store them and sign each messages.

Nostric currently supports these features:
* Generate PK, SK
* Create a profile
* Update profile
* NIP-01 kind:1 Post publish
* NIP-01 kind:0 User Metadata publish

# Links
Link to the GitHub repo [here](https://github.com/lukasvozda/nostric). 
Link to the presentation video [here](https://www.youtube.com/watch?v=T2Nukasj7jw).
Link to the frontend canister running in production [here](https://caab5-7yaaa-aaaah-qdbwq-cai.icp0.io).

# Category
We are submitting to the IBE category.

# Feedback

Overall developer experience: We struggled at the beginning trying to run sveltekit project with all the dependencies and current version of DFX and js-agents. Would be cool if there is someone responsible for keeping [these templates](https://github.com/dfinity/examples/blob/master/svelte/sveltekit-starter/README.md) up to date as it would make life easier for new developers in the ecosystem.

vetkey API feedback: It was fairly easy to include vetkd_system_api canister in our project and start using it so the experience was great in this regard. It would be cool if there is some documentation saying what the text parameters  in the key_id or derivation path mean.

# Note
If you have any feedback or questions regarding to this project, we will be happy to talk!

-------------------------

v1ctor | 2023-09-08 21:19:38 UTC | #52

# **medpx** - Keep your electronic medical prescriptions safe, under your control

![medpx-front|690x484](upload://qGDKmXUVg6lu2VJtTw66MIDde7x.png)


This is my entry. It stores medical prescriptions in electronic form, on the blockchain, using cryptography to ensure nobody can access them – unless the owner (patient) allows that.

It depends on VetKeys to encrypt/decrypt patients medical prescriptions. Only the doctor (creator), the patient and users (third-parties) allowed by the patient can access and decrypt the prescriptions. Doctors must use their smart cards (containing X.509 certificates) to signup and also to sign prescriptions.

The app was made specifically for this bounty.

Only in my country, Brazil, more than 28 million electronic prescriptions are created per month using a single, closed-source, proprietary app, that allows anyone to access a prescription if they use a simple 6-digits hex code or if they scan a QR-code, that gives the patients no control over their data.

## Links
- Demo site: https://66ksk-6iaaa-aaaan-qd7qa-cai.icp0.io/
- Video: https://youtu.be/LcRG9248a4k
- Source-code: https://github.com/av1ctor/medpx

## Category
It falls under multiple categories: 
- IBE: doctor creates a encrypted prescription that can be shared by the patient with third-parties like drugstores, hospitals etc
- Group sharing: patient can create groups of users and share the prescriptions with those groups, anyone part of the group can access and decrypt the data
- Timelock: patients can define a date limit when access to the prescriptions will end

## Feedback
The VetKeys API, as proposed, was really easy to use, as it follows the ECDSA API. The examples were simple to follow. The hardest part was getting the utils JS library to work with NPM + webpack, but @nathanosdev posts on this thread helped a lot.

There's a chicken-egg problem I faced and that I see happening with most entries in this bounty: nobody is checking for user permission when vetkd_encrypted_key() is called. That can be a major cause of cycle draining DDoS attacks, as that API method won't be cheap to invoke. To prevent that, I had to create prescriptions in two stages: first the prescription is created in a pre-stage by a caller (a doctor). Then the same caller will ask for the encrypted key for that prescription. The key will only be generated and returned if there's permission to access that prescription. Then, after encrypting (using the key returned by VetKeys) and signing (using a X.509 certificate) the prescription at client side, the 2nd stage canister method will be called to complete creating.

-------------------------

cyberowl | 2023-09-10 12:44:56 UTC | #53

# Capsule - A Time Capsule / Deadman Switch for Files

Deadman Switch Feature: Life is unpredictable, and there's wisdom in being prepared. Our Deadman Switch activates when you are unable to check-in within a pre-determined time frame, making pre-set files public. Whether it's a heartfelt letter, encrypted passwords, or critical documents, rest assured that your voice will be heard even if you can't be there to speak.

Time Capsule Feature: Embrace the magic of time travel with our digital Time Capsule. Save photographs, wills, videos, or any digital memento and set a date for its future unveiling. It's like burying a treasure for your future self or loved ones to find, allowing you to communicate across time and remind them of special moments, life lessons, or just how much you care.

### Category
Timelock Encryption

### Images

![Screenshot 2023-09-09 at 7.10.58 PM|690x401](upload://sSoRD2jnjOrwzWXwPRfYyWiBxTK.jpeg)
![Screenshot 2023-09-09 at 7.05.27 PM|690x399](upload://2cQSIk4J7tX9Wzhyc8n2oSa43F6.jpeg)

### Links
App:
https://np5oc-vyaaa-aaaag-abwia-cai.icp0.io/

Code:
https://github.com/cybrowl/capsule

Video: 
https://drive.proton.me/urls/Z6R1TBB4F4#BFHlFCJUqoZz
(video is not great since I had to edit to keep it at 4min)

### Feedback
Establishing a clean code client connection using ic-vetkd-utils presented its own set of challenges but with feedback from forum it was solved. @nathanosdev posts helped. While the API is user-friendly, a more detailed insight into the inner workings of each field would have been appreciated. I believe this detailed information should be readily available within the codebase, as learning through practical examples resonates with me the most.

Up until now, it has catered to my requirements effectively. Segmenting the encryption and decryption processes posed some difficulty, especially since the provided example catered only to text. However, overall, its performance has been commendable.

-------------------------

b3hr4d | 2023-09-10 15:21:58 UTC | #54

# Introducing B3Note: Revolutionizing Note-Sharing through Witness-Like Encryption on the Internet Computer

![b3-note|690x393](upload://3pWbNH8ug8kkaeDKGsHSXYMdvJV.jpeg)


## Overview

I'm thrilled to introduce B3Note, an innovative application that capitalizes on the Internet Computer's capabilities. B3Note elevates the standard for secure and anonymous note-sharing. It not only enables users to write and share notes anonymously without the need for a login but also incorporates a unique form of encryption similar to Witness Encryption. This adds another layer of security and functionality to the platform.

Additionally, I've developed [B3Utils](https://github.com/B3Pay/b3_utils), a Rust crate that serves as a comprehensive helper, streamlining the work with stable memory, timers, logging, and more on the Internet Computer. This crate includes powerful and unique features, such as the amazing vetkd capabilities. B3Utils is open-source and available for anyone to use, making it easier to implement functionalities similar to those found in B3Note. It demonstrates capabilities that other blockchains can only dream of.

## Use Cases

### Open/Blue Skies with a Focus on Witness-Like Encryption

One of B3Note's standout features is its encryption mechanism, which operates in a manner similar to Witness Encryption. This approach enables secure multi-party computation, anonymous credentials, and intricate access control systems. Furthermore, it allows us to verify anonymous users directly on-chain, marking a significant leap forward in decentralized technologies.

### IBE (Identity-Based Encryption) with Generated Public Keys

B3Note employs IBE for secure note-sharing based on generated public keys. This eliminates the need for traditional identifiers like email addresses or usernames and removes the complexities associated with pre-shared keys.

### Timelock Encryption

B3Note also incorporates the concept of Timelock Encryption to provide an added layer of security and functionality. Notes created by anonymous users expire after 1 hour, and shared links for those notes are also only available for the same time frame. This aligns well with the notion of Timelock Encryption, where encrypted data can only be accessed for a specific period.


## Key Features

* **Anonymous Usage**: B3Note can be used anonymously, with no login required.
**Limited Notes for Anonymous Users** : Anonymous users can create up to 5 notes, each with a 1-hour timeout, after which the notes are automatically deleted. Additionally, any generated share link will also expire after 1 hour.
* **Canister Global Timer**: A global timer is used to clean up expired users and one-time keys, enhancing system efficiency and security.
* **Secure Sharing with On-Chain Verification**: Notes can be securely shared through a simple link that contains the signature of your public key. This signature is verifiable on the blockchain and pairs with the note's unique ID to confirm access to the decryption key.
* **Auto Deletion**: Notes are automatically deleted after the first read or if they remain unread for an hour.
* **Advanced Encryption**: A witness-like encryption mechanism ensures that only authorized users can access the notes.
* **Timelock Encryption**: Encrypted Decryption Key, Notes, and shared links come with a built-in expiry feature, aligning with the concept of Timelock Encryption for temporary secure access.

## Live Demo and Source Code

https://youtu.be/13s_mcNkG3E

* **[B3Note Live Demo](https://4lidq-zqaaa-aaaap-abkbq-cai.icp0.io/)**
* **[B3Note GitHub Repository](https://github.com/B3Pay/b3-note)**
* **[b3_utils GitHub Repository](https://github.com/B3Pay/b3_utils)**

I invite everyone to experience B3Note and delve into its features. Your feedback would be invaluable as we continually develop and enhance this project.

---

### Feedback on the vetKD System API:

I found the vetKD system API to be quite flexible and powerful for most use cases. However, for my specific application, B3Note + B3Wallet, I needed the ability to sign messages using the transport secret key for on-chain verification. To address this, I extended the ic-vetkd-utils library to include a `sign` function.

This function hashes an input message to a curve point in G2, multiplies it by the secret key, and returns the serialized point. This allows us to sign unique note identifiers with private keys, which can then be verified on-chain using pairing functions. Here's a snippet of the function:

```
pub fn sign(&self, input: &[u8]) -> Result<Vec<u8>, String> {
    let hashed_input = augmented_hash_to_g2(&G1Affine::generator(), input);
    let signed_input = hashed_input.mul(self.secret_key);
    let signed_input_bytes = signed_input.to_affine().to_compressed();
    Ok(signed_input_bytes.to_vec())
}
```

This addition has significantly enhanced the security and verification aspects of B3Note and possibly B3Wallet.


🎉 **Special B3Note Challenge: Win a Gift!** 🎉

To celebrate the launch of B3Note, I'm hosting a fun game. I've created a secure, encrypted note using B3Note's anonymous note-sharing feature. The first person to click the link and decrypt the note will find instructions on how to claim a special gift of **5 ICP tokens**!

Ready? [Click here to decrypt the note and claim your gift!](https://4lidq-zqaaa-aaaap-abkbq-cai.icp0.io/withoutii?id=14&signature=b783e87852f11bddad4aef27b39f69ad39c83801954c5466c17bc7d9e858cf28789960164207e09fc6944b6618ca9c3f066c82bcc479434ce0c0a1e14d94c2f2f87aac55a1cd6e76903d97fcd6e87905e617b5989550ca0395d09cf2178d7889#)

Remember, the link will expire after 1 hour or as soon as someone claims the prize, so act fast!

-------------------------

timk11 | 2023-09-10 14:22:22 UTC | #55

Can anyone help me solve this bug?

I'm working on an app that will allow content to be encrypted for members of a gaming community with different content for different user levels. The top levels are owners and admins. The first time the app is opened in a browser, the canister owner and a specified principal (the anonymous principal for the local/test version) are appointed as the first two "owners". A master key is created and then encrypted for each user who is added to the platform. This is then decrypted in order to add or read content and for encrypting the master key whenever owners or admins add a new user. Encryption works fine, but when I try to decrypt the key I get an `Uncaught (in promise) Error`.

Here are the relevant code sections:
```
// Function to appoint Owners when the canister is run for the first time
const init_status = await actor.checkInitStatus();
console.log("init_status =", init_status);
if (init_status == false) { //const startup = async () => {
  const randvals = window.crypto.getRandomValues(new Uint8Array(32));
  const randtext = new TextDecoder("utf-8").decode(randvals);
  let msk = await get_aes_256_gcm_key_from_text(randtext, "master_key");
  let temp_key = await get_aes_256_gcm_key_for_canister_owner();
  let encrypted_msk = await aes_gcm_encrypt(new TextDecoder("utf-8").decode(msk), temp_key);
  const intialised = await actor.initialise(encrypted_msk);
  console.log("intialised =", intialised);
  // For local deployment and testing
  temp_key = await get_aes_256_gcm_key_from_text("2vxsx-fae", "Owner");
  encrypted_msk = await aes_gcm_encrypt(new TextDecoder("utf-8").decode(msk), temp_key);
  let owner2_added = await actor.addSecondOwner("2vxsx-fae", encrypted_msk);
  // For deployment to IC (comment 3 lines above, uncomment next 3 lines and replace with your own principal ID)
  // temp_key = await get_aes_256_gcm_key_from_text("mypri-ncipa-lid", "Owner");
  // encrypted_msk = await aes_gcm_encrypt(new TextDecoder("utf-8").decode(msk), temp_key);
  // let owner2_added = await actor.addSecondOwner("mypri-ncipa-lid", encrypted_msk);
  console.log("owner2_added =", owner2_added);
  msk = null;
  encrypted_msk = null;
};
```

```
// Function to appoint new Admin (Owner-only function)
document.getElementById("appointAdmin").addEventListener("submit", async (e) => {
  e.preventDefault();
  const userId = document.getElementById("user_id5").value;
  const callerRole = await actor.getUserRole(app_backend_principal.toText());
  const decrypt_key = await get_aes_256_gcm_key(JSON.stringify(callerRole[0]));
  const caller_enc_msk = await actor.getEncryptedMSK(app_backend_principal.toText());
  const _msk = await aes_gcm_decrypt(caller_enc_msk, decrypt_key);    // CODE STOPS RUNNING HERE
  const encrypt_key = await get_aes_256_gcm_key_from_text(userId, '{"Admin":null}');
  const _encrypted_msk = await aes_gcm_encrypt(_msk, encrypt_key);
  await actor.appointAdmin(userId, _encrypted_msk);
  // Get and display the updated role for the user
  const updatedRole = await actor.getUserRole(userId);
  document.getElementById("aa_result").innerText = "Role: " + JSON.stringify(updatedRole);
});    // THIS IS LINE 122
```

```
async function aes_gcm_decrypt(ciphertext_hex, rawKey) {
  const iv_and_ciphertext = hex_decode(ciphertext_hex);
  const iv = iv_and_ciphertext.subarray(0, 12); // 96-bits; unique per message
  console.log("iv =", iv);
  const ciphertext = iv_and_ciphertext.subarray(12);
  console.log("ciphertext =", ciphertext);
  const aes_key = await window.crypto.subtle.importKey("raw", rawKey, "AES-GCM", false, ["decrypt"]);
  console.log("aes_key =", aes_key);
  console.log(typeof aes_key);                         // CODE STOPS RUNNING HERE
  let decrypted = await window.crypto.subtle.decrypt(
    { name: "AES-GCM", iv: iv },
    aes_key,
    ciphertext
  );
  console.log("decrypted =", decrypted);
  return new TextDecoder().decode(decrypted);
};
```

From the console output it can be seen where the code stops running:

![image|690x368](upload://vDUbt9DaXhtJtIBRiCfxFtQCGaU.jpeg)

No further error details are given in the output. Line 122 is at the end of the `appointAdmin` function as shown above. When `await` is removed from
`let decrypted = await window.crypto.subtle.decrypt(`
the `decrypted` variable is logged like so:

![image|671x346](upload://3rNcBVGNaaWjfQgiXdnko3ugLHu.png)

There's a Motoko backend but I can't find any issue there. (I can provide it if anyone wants to see it.) I've checked through everything carefully. The `iv` values match between the encryption and decryption stages. This all worked fine when I tried it in simpler examples without the full functionality. I'm at a loss as to what's going wrong here.

-------------------------

kamalbuilds | 2023-09-10 14:03:35 UTC | #56

Hi @domwoe A 1 week extension would be a great benefit for our team as well. As the feature is new and we have encountered many bugs hindering the process of developement. Thanks

-------------------------

b3hr4d | 2023-09-10 14:51:38 UTC | #57

Congrats to @Berg for being the first to access the note.
 
![winner-b3note|690x377](upload://8IMPnkIxVapYwqRnWBcITtsNw8v.jpeg)

Thanks to all the participants.

-------------------------

domwoe | 2023-09-10 14:52:49 UTC | #58

[quote="kamalbuilds, post:56, topic:21294, full:true"]
Hi @domwoe A 1 week extension would be a great benefit for our team as well. As the feature is new and we have encountered many bugs hindering the process of developement. Thanks
[/quote]

Hi @kamalbuilds, the deadline has already been extended by more than a week. The original deadline was Augst 29.

-------------------------

timk11 | 2023-09-11 10:10:19 UTC | #59

(Kind of) solved it. 

I switched from AES-GCM to AES-CTR, which I know is a less secure mode, but for whatever reason it now works.

-------------------------

timk11 | 2023-09-11 13:40:32 UTC | #60

Oh ###!! I just realised I mixed up the closing date of this with my other major deadline this week. I've finally (just tonight) solved the bugs that have been plaguing me for weeks. I was aiming for this time tomorrow. Is it still possible to make a submission?

-------------------------

timk11 | 2023-09-11 17:21:25 UTC | #61

In any case I'm going to have call it quits for today because it's after 3am where I am. I've based my project around https://github.com/dfinity/examples/tree/master/motoko/vetkd and made several changes to enable storage and retrieval of content for role-based groups within a larger assortment of users (such as a gaming community). There were also a handful of apparent bugs that I've now all but fixed. `TextEncoder("utf-8").encode()` seemed to create some ambiguity and incorrect decryption of encrypted keys, but I've found what seems to be a very effective workaround.

-------------------------

domwoe | 2023-09-11 19:25:04 UTC | #62

Hey @timk11,

we'll definitely evaluate your submission.

-------------------------

domwoe | 2023-09-12 05:57:26 UTC | #63

Hey @hawk,

can you provide a video pitch/demo and a demo application deployed to the IC?

-------------------------

hawk | 2023-09-12 06:50:34 UTC | #64

Hey @domwoe,
Thanks for the reminder. I will decline this bounty as UI won't be ready in time, but will start preparing to incorporate vetKeys in the main product :)

-------------------------

timk11 | 2023-09-17 14:21:41 UTC | #65

![image|690x165](upload://4oafpgJ0SGu0qN5kz8ulhZGlKQx.jpeg)

# GuildNotes
**An app for encrypting and sharing role-based content within a gaming community.**

GuildNotes enables gaming communities to share content with players. Different content is able to be accessed by different levels of players. Users within the app are ranked as Owner, Admin, Conqueror, Explorer or Player. The app features two frontends - an Admin Dashboard for Owners and Admins to manage content and access, and an End User Interface for all levels of players to access role-specific content.

**Category - Group sharing**

**Repository -** https://github.com/timk11/guildnotes
**Video demo -** https://www.youtube.com/watch?v=bC5XSoSd0Dk
**IC deployed version:** *(updated links)*
**&#160;&#160;&#8226; Admin dashboard -** https://qb7ig-qiaaa-aaaao-a2h3a-cai.icp0.io/
**&#160;&#160;&#8226; End user interface -** https://qg6os-5qaaa-aaaao-a2h3q-cai.icp0.io/

**Feedback**
The vetKeys feature is great and was easy to set up using the provided demo versions. Modifying it to perform a different function of this sort was a major undertaking, and one I would personally put into the "very hard" category. Part of this is me, given I only came to the IC earlier this year with little knowledge of web design. It's been a huge but fascinating learning curve!
I based my design on the ic/examples/motoko/vetkd version. I tried a few different approaches to get it deployable and working. Lots of debugging along the way. In the final stretch a few specific features needed changing:

- AES-GCM worked with the `aes_gcm_encrypt` function but not with `aes_gcm_decrypt`. I ended up switching to AES-CTR, which I know is less secure but is now working well.
- `TextEncoder("utf-8").encode()` did not work for encrypting and then decrypting a key. The key is 32 bytes. When returned as a string the decrypted key looked the same as the equivalent original version, but when transformed into a BufferArray the array length came out as some longer odd number, usually the same (incorrect) result each time it was tried. My eventual solution was to swap out TextEncoder/Decoder and replace them with `hex_encode` and `hex_decode` respectively.
- `hex_encode` from the example version consistently gave an error message (bytes.reduce is not a function). An alternative solution I found on Stack Overflow is in the repo.

Overall a very exciting feature. Having to do so much debugging was a good chance to get my head around a lot of the finer details and I look forward to seeing how this all shapes up, and contributing further if there are opportunities.

-------------------------

yejikim | 2023-09-12 13:58:01 UTC | #66

Received! Can you also share the link to the demo application deployed to the IC?

-------------------------

timk11 | 2023-09-12 14:58:48 UTC | #67

I'm having trouble deploying it at the moment. I keep getting `tcp connect error: Network is unreachable (os error 101)` or it just stays stuck on `Creating canister...`. Could it be a cycles issue? I thought I sent ICP to my wallet but the cycles balance hasn't changed.

-------------------------

jennifertran | 2023-09-13 09:26:00 UTC | #68

Can you please create a new forum thread on the issue?

-------------------------

timk11 | 2023-09-13 14:06:09 UTC | #69

**GuildNotes** is now deployed. I've put the URLs in my previous message above.

I have a new problem in that the page displays correctly but does not function, giving these errors:
```
qtz77-4yaaa-aaaao-a2hya-cai.icp0.io/:1  
Refused to execute script from 
'https://qtz77-4yaaa-aaaao-a2hya-cai.icp0.io/src/index.js' 
because its MIME type ('text/html') is not executable, 
and strict MIME type checking is enabled.
```
```
index.js:2  Uncaught (in promise) TypeError: 
Failed to execute 'compile' on 'WebAssembly': 
Incorrect response MIME type. Expected 'application/wasm'.
```
I've started a new thread for this topic at https://forum.dfinity.org/t/how-to-solve-mime-type-errors-in-deployed-canisters/22998. Any advice would be gratefully received.

-------------------------

timk11 | 2023-09-17 14:18:13 UTC | #71

**GuildNotes** has been re-deployed.

The canister URLs have changed. The new ones are:
**• Admin Dashboard -** ~~`https://rctba-eqaaa-aaaao-a2h5q-cai.icp0.io/`~~
**• End User Interface -** ~~`https://rxuqn-fyaaa-aaaao-a2h6a-cai.icp0.io/`~~

Still having a couple of issues. Internet Identity login is working for the End User Interface but not for the Admin Dashboard. However, I've registered the anonymous identity as an Owner, so you'll have this role when you first open the page and be able to add and read content, assign roles, etc.

-------------------------

timk11 | 2023-09-17 14:18:38 UTC | #72

**GuildNotes** is now fully working!

The canister URLs have changed (again). The new ones are:
**• Admin Dashboard -** https://qb7ig-qiaaa-aaaao-a2h3a-cai.icp0.io/
**• End User Interface -** https://qg6os-5qaaa-aaaao-a2h3q-cai.icp0.io/

I've registered the anonymous identity as an Owner, so you'll have this role when you first open the page and be able to add and read content, assign roles, etc.

-------------------------

senior.joinu | 2023-09-20 14:14:21 UTC | #73

Sorry for being a little bit off-topic.
I'm trying to put my finger on how vetkeys work more in-depth. 
So far it seems like I understand (at least at high level) all the steps, except for the ElGamal one. 
![screenshot|690x183](upload://r82bU3btHRIN0zDtDExvxlfj4Cy.png)
([this article](https://internetcomputer.org/blog/features/vetkey-primer))

I didn't read any of the sources provided in the article - too much in-depth for me :)

This is how I understand the protocol:
1. The user wants to derive some secure entropy from their identity, so they make a call to a canister, providing their public encryption key (transfer key).
2. The canister sees this request, decides that the user is allowed to do that and passes the transfer key with the user's identity to a system call.
3. This system call makes all the nodes to simultaneously grab their BLS private key share and use it to sign the user's identity, to obtain a BLS signature share.
4. Each node then encrypts this BLS signature share using the transfer public key.
5. Each node then somehow (probably through p2p) passes this encrypted signature share to a current consensus leader.
6. The leader combines all encrypted signature shares into an encrypted signature and puts it in a block as a system call response.
7. Once the block is in execution, the canister receives the encrypted signature and transfers it back to the user.
8. The user (and only they) is able to decrypt the signature, using their private transport key.
9. The user is also able to verify that the signature was produced by the subnet to which they were originally requesting, and not someone else, since this is just a signature and we have a public key of the subnet.
10. The user reinterprets this signature as entropy and uses it as they wish.

The problem I have is in step 6. 
Each node produces a signature share that is meant to be combined with BLS scheme. Then each node encrypts its signature share, so each node now has a piece of ElGamal cyphertext, which should no longer have the same qualities. I mean, these cyphertexts are no longer valid BLS signatures, so they can't be combined. But the round leader combines them somehow and moreover, the user decrypts this combined cyphertext and somehow gets the BLS-combined signature out of it.

Can someone please explain what I got wrong and how it works in reality. Thanks a lot!

-------------------------

andrea | 2023-09-21 16:39:41 UTC | #74

[quote="senior.joinu, post:73, topic:21294"]
Each node produces a signature share that is meant to be combined with BLS scheme. Then each node encrypts its signature share, so each node now has a piece of ElGamal cyphertext, which should no longer have the same qualities. I mean, these cyphertexts are no longer valid BLS signatures, so they can’t be combined. But the round leader combines them somehow and moreover, the user decrypts this combined cyphertext and somehow gets the BLS-combined signature out of it.
[/quote]

Great question! The main trick here is that the (ElGamal) encryption scheme used is additively homomorphic, which is just a way to say that you can add ciphertexts together to obtain an encryption of the sum of the messages. 

The messages encrypted by each node are shares of a BLS signature `S_i`. When they are on cleartext, you can reconstruct the full signature by computing a linear function of the shares, something like: 
`S:= a_1*S_1+a_2*S_2+..` where the `S_i` are shares of the BLS signatures (i.e. they are group elements on the EC BLS12_381) and the `a_1` are scalars (i.e. integers modulo the order of the group). Since the encryption scheme allows to you add ciphertexts together, given the encrypted signature shares you can apply the linear function directly to the ciphertexts to get an encryption of the combined signature.

There is one more subtlety: the combiner cannot decrypt the messages inside the ciphertexts, so if one signature share is wrong, also the combined (encrypted) signature will be wrong. Fortunately, the scheme enables verification of encrypted signatures while they are still encrypted, so the combiner can verify the shares before combining them. In addition to the homomorphic property of the encryption scheme, this is possible thanks to the bilinearity of the pairing operation of the BLS curve. At an high level the pairing operation let you combine 2 group elements to form another group element: `pairing(G1, G2)->G3`. The pairing is also used to verify BLS signatures, via the following verification equation:
`pairing(S,B)=pairing(M,PK)`, where `S` is the signature, `B` is fixed group element, `M` is the hash of the message and `PK` is the public key.

The following is not fully correct, it's more to give an intuition of what is happening: If you encrypt both sides of the verification equation you obtain `Enc(pairing(S,B))=Enc(pairing(M,PK))`. Thanks to the various linear properties, the left-hand side is also equal to `pairing(Enc(S), B)`, which essentially means that it can be computed given the encryption of the signature. The right-hand side can be compute from all public info (i.e. the message, the public key and the encryption key). This allows you to verify that the encrypted signature is actually correct. Again, this is a bit of a simplification, so don't take it literally.

If you are interested in understanding the details, @ais is planning to do a followup article more focused on the scheme we are planning to integrate. This should be more easy to parse than the research paper!

-------------------------

ais | 2023-09-21 18:31:42 UTC | #75

Hi guys, 

We first want to thank you so much for the submissions. We're really impressed by the amount of thought and effort you put into them. We also had a lot of fun looking at them, trying to see if they're secure or not ;) and particularly watching the demo videos - they're great! 

As it was a 'contest' bounty, we had to choose some way to divvy up the prize pool. Now we have some view on this, we'd like to **announce the winners at the next Public Global R&D meeting** on Wednesday September 27th at 17:30 CET. 
It will not be live streamed this time, so if you participated in the bounty and would like to join, **ping me** and I'll send you a Zoom invite. For everyone else, you can catch the recording the next day. We'll also make the announcement here in the forum.

I know you care about the bounty, but the most interesting part for us was seeing the parts that you all understand very clearly, and the parts that are misunderstood. We learned a lot. I'm collating all those points and will share them with you here, and with a followup to the primer article, and updated documentation. It's not easy to get such feedback if people don't properly engage. You all did, and we're super grateful. Thanks already for your contributions to the privacy landscape :heart:

-------------------------

rabbithole | 2023-09-21 17:40:49 UTC | #76

[quote="ais, post:75, topic:21294"]
if you’d like to join, **ping me** and I’ll send you a Zoom invite.
[/quote]
Please send me an invitation to a meeting, this is my favorite series :slightly_smiling_face:

P.S. I definitely love what I have to deal with when developing my application and programming canisters in general. A few years ago I lost interest in programming, perhaps it was due to the bull market that generously rewarded early holders, or perhaps the work itself was uninteresting and did not make me feel proud of what I was doing. I quit my job and devoted my free time to studying IC, damn it was difficult, but at the same time I became interested. Regardless of the market situation, opinions in chats, I just continue to build and enjoy the process! And all this thanks to the DFINITY team! Thank you for inspiring us and creating unique opportunities! :fire:

-------------------------

senior.joinu | 2023-09-21 20:48:06 UTC | #77

Thanks a lot!
Can't say I did understand everything, but it is a lot clearer now!

-------------------------

senior.joinu | 2023-09-22 11:44:43 UTC | #78

I was trying to understand why this feature seems so exiting to me and realized that this is actually the first thing in Web3 ever that Web2 eagerly needs, but was unable to get all this time. Meaning that all the previous Web3 stuff, like tokens and NFTs was cool, but very questionable from the perspective of a typical Web2 company. Like "yeah, tokens seem fun, but we already have Stripe for payments, which works million times faster and is compatible with our jurisdiction". 

Web3 stack is typically chosen only for the use-cases with very specific requirements. Regular Web2 apps don't need Web3 tech, because they are fine without it. And most of them, when given a choice "do you want to build your app on AWS or on blockchain", would choose the first, especially for some performance-critical applications.

But this feature is different. Imagine yourself as a developer of some privacy-enabled app, like WhatsApp (this statement is controversal, but anyway). Like, you want people to have e2e encrypted chats, but in order to achieve that you need to solve a whole bunch of engineering complexities related to key management. And you have no other choice other than to store these keys on your own servers or on some third party servers, which is either hard or expensive. 

With VETKeys (and II) this is actually easier and cheaper to spin up a simple canister with one little endpoint for key derriviation, than to handle key management by hand. It is easier to stick with Web3, than with Web2.

-------------------------

senior.joinu | 2023-09-22 12:06:35 UTC | #79

One can even integrate VETKeys in a regular client-server system. Even without Internet Identity or any other key management system. The server authorizes users with regular login/password and then operates as a proxy between clients and the VETKeys canister (so only the server has to manage the key pair to communicate with the IC). Even if the server is comprimised, no data will leak, since every generated entropy (from logs or caches) will be e2e encrypted with a client's transport key.

-------------------------

patnorris | 2023-09-22 16:38:10 UTC | #80

Thank you for the opportunity! As I'm interested in releasing the vetKeys integration in my app to production, I wondered when vetKeys will be released. Is there a date for this already? And in case you found any security vulnerabilities while looking through the apps, will you be able to share these (with the respective projects) so we can fix them before release?

-------------------------

hokosugi | 2023-09-24 02:20:38 UTC | #81

It is my understanding that vetKey's ID is not only Internet Identity, but also web2 ID and maybe even the private key inside the social security card. It would be interesting to have an extension that allows E2EE messages with Google ID or Apple ID. The previous YouTube video explained that there is a sufficient number of signatures per second that can be done, but is it possible to scale the BLS signatures enough to withstand the number of processes for web2 enterprises, not web3?

-------------------------

ais | 2023-09-27 15:44:10 UTC | #82

Encrypted files, encrypted forms, encrypted notes, Nostr Clients and key management, deadman's switches, private AI, medical privacy, key derivation and credentials, and privacy for our gamers.. We didn't imagine you'd give us so much!

**Announcing the winners** 
First, thanks to everyone for the consideration and participation. Even if you didn't manage to submit something this time, we're really grateful that there are so many interesting ideas and applications floating around. Thanks a lot also for the continued discussion. 

**Accepted submissions**
There were a list of acceptance criteria that projects needed to meet. These included using the proposed vetKeys system API, deploying an app to the IC, and recording a demo video, among other things. There were 9 submissions in total that satisfied the acceptance criteria. We list them below. 
|Project Name|Description|Participant|
| --- | --- | --- |
|Kwic|digital document based proof of personhood system. More info in the repo and demo video.|[senior.joinu](https://forum.dfinity.org/u/senior.joinu)|
|FormThing|End to End Encrypted Forms on the Blockchain|[conorseed](https://forum.dfinity.org/u/conorseed)|
|Rabbit Hole|an encrypted file service that runs fully on-chain|[rabbithole](https://forum.dfinity.org/u/rabbithole)|
|Browser-based AI Chatbot Served From The IC|Now With State-of-the-Art Privacy|[patnorris](https://forum.dfinity.org/u/patnorris)|
|Nostric|a simple Nostr client running on the ICP|[lukevoz](https://forum.dfinity.org/u/lukevoz)|
|medpx|Keep your electronic medical prescriptions safe, under your control|[v1ctor](https://forum.dfinity.org/u/v1ctor)|
|Capsule|A Time Capsule / Deadman Switch for Files|[cyberowl](https://forum.dfinity.org/u/cyberowl)|
|B3Note|Revolutionizing Note-Sharing through Witness-Like Encryption on the Internet Computer|[b3hr4d](https://forum.dfinity.org/u/b3hr4d)|
|GuildNotes|An app for encrypting and sharing role-based content within a gaming community.|[timk11](https://forum.dfinity.org/u/timk11)|

There were 4 categories that submissions fell into based on where they best contributed. Submissions were then assessed based on design/UX, functionality, and code quality. Ultimately, all accepted submissions get part of the bounty. 
It was not an easy exercise to participate here and given the amount of effort that everyone put in, it was deemed that **everybody's a winner**. 
*Plot twist*: we didn't restrict the submissions to one category, so if a project nailed the functionality in several categories, we allowed it. Below you'll see the rankings of the submissions and the respective prize amounts in USD.  

| IBE | Group Sharing | Timelock  | Blue Skies | 
| --- | --- | --- | --- |
|🥇FormThing ($4000)| 🥇medpx ($2500)| 🥇Capsule ($4000)|🥇Kwic ($3000) |
🥈B3Note ($2000)|🥈FormThing ($2000)|🥈Rabbithole ($2000)|🥈Nostric ($2000)|
| | 🥉Rabbithole ($1000)| |🥉AI Chatbot ($1000)|
| | 💪Guildnotes ($500) | | 

Over the coming days we'll give some feedback and comments that arose when we were reviewing the submissions. We also learned a lot, so we'll give a summary of that and outline how the next steps will be influenced. @domwoe will reach out the the winners about the $$. 

Congratulations to the winners and thanks once again everyone for the participation!

-------------------------

Artemi5 | 2023-09-27 15:50:37 UTC | #83

Very interesting feature.. Congratulations to all bounty winners

-------------------------

ais | 2023-09-28 17:07:31 UTC | #84

Hi guys, for those who didn't make it to the live session yesterday, the recording on this month's Global R&D is now live and you can see the bounty announcements [here](https://youtu.be/PPEI_frweJE?t=82&si=xsDUHSuAcBPzB3_K). 

Thanks and congratulations again :)

-------------------------

domwoe | 2024-02-07 18:34:01 UTC | #85

Hey everybody,

If you are interested in leveraging vetKeys in your projects, please fill out this quick survey.

https://dfn.typeform.com/to/D4RxWoy1

Thank you :pray:

-------------------------

conorseed | 2024-02-07 20:05:05 UTC | #86

Just completed the survey @domwoe :)

-------------------------


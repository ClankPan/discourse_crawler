benji | 2023-03-14 17:20:43 UTC | #1

# NFT Token Standard Working Group

We at DFINITY are dedicated to providing better developer experiences and driving adoption. Along with members of our great community, we created the first Fungible Token Standard ICRC-1. The standard is seeing increasing adoption and is paving the path for easier integrations. We're looking to further our efforts by creating a working group for an NFT standard, and we'd like to call out to all members of our community to participate and to contribute.

# Summary
- Call for participation open to everyone
- Starting with weekly meetings:
Tue 29nd Nov, @ 17:00 CET ([calendar](https://calendar.google.com/calendar/u/0?cid=Y19jazBncjc5YmtnY29vaWNuMXA4N21vMWVyb0Bncm91cC5jYWxlbmRhci5nb29nbGUuY29t))
The meetings will be bi-weekly after the initial phase.
- GitHub will be used as main discussion board. Link will follow shortly.

# Goal
The goal of this working group is to create a baseline NFT standard to facilitate development and integration. Extensions can be foreseen for the future.

# Organisation
This working group is derived from the Ledger & Tokenization Working Group, but we decided to form a new working group because this standard potentially appeals to a different audience. We will follow the format of the Ledger & Tokenization Working Group.

-------------------------

Embark | 2022-12-01 17:07:33 UTC | #2

Thats very interesting! What can we do to participate?

We would like to contribute to make physical assets tokenizable according to the romano-germanic civil law that is currently being ammended in some countries.

-------------------------

benji | 2022-12-02 15:33:06 UTC | #3

Hi, you can participate by participating in the WG meetings.

-------------------------

jorgenbuilder | 2022-12-14 22:13:34 UTC | #4

**Regarding Transaction History**

The working group is currently assessing metadata to be associated with transaction history. Here I advocate we should strive for feature parity with CAP, as the incumbent with overwhelming capture.

That Psychedelic steps back at the same time this group attempts to standardize transaction history presents an opportunity to ship an implementation with very broad near-term impact. As a caveat, of course CAP isn't perfect, and we should be comfortable when differing from it.

**General Lessons From CAP**

- Motoko and Rust libraries make it trivial to add tx history to your canister.
- Hugely flexible data model is future-proof and extensible, but means unreliable data.

**Transaction History Events**

CAP employs an incredibly flexible data model, allowing developers to store basically anything they want:

```motoko
public type Event = {
    time : Nat64;
    operation : Text;
    details : [(Text, DetailValue)];
    caller : Principal;
};
public type DetailValue = {
    #I64 : Int64;
    #U64 : Nat64;
    #Vec : [DetailValue];
    #Slice : [Nat8];
    #Text : Text;
    #True;
    #False;
    #Float : Float;
    #Principal : Principal;
};
```

Developers made typos and forgot to add certain values, so the data was very inconsistent as a result.

The flexible model also provides extensibility, which may be a critical property. Consider the exercise of trying to determine a finite set of operations: ICRC has *mint*, *transfer*, and *burn*, but what about *sale* and *list*? Can we reliably predict future use cases, such as *rent*, *delist*, *fractionalize*, and so on? Should the standard leave room to support innovative tx history use cases?

**Some Real CAP Event Types**

I would recommend adding the "sale" event type to ICRC, considering the importance of marketplaces to the NFT ecosystem (sorry if this is already included, couldn't find the reference.) Here's an example CAP event:

```
// Sale (BTC Flower)
{
  "time": 1670588669701,
  "operation": "sale",
  "details": [
    [
      "to",
      {"Text": "58a0fcbd3ae8d5589f9b7e3208b979867b44d04b8d4d1bfe2ede9f641973243f"}
    ],
    [
      "from",
      {"Principal": "jqazm-bdzbj-hnq3o-yexug-vqu3v-jonju-7ngcp-4yzbw-jyux4-lqejy-mae"}
    ],
    [
      "price_decimals",
      {"U64": 8}
    ],
    [
      "price_currency",
      {"Text": "ICP"}
    ],
    [
      "price",
      {"U64": 18000000000}
    ],
    [
      "tokend_id",
      {"Text": "jz2z7-3akor-uwiaa-aaaaa-beaag-maqca-aaaq7-a"}
    ]
  ],
  "caller": "s4d6r-c23m5-5gapy-myo3t-7pgtm-pdf6g-3nepw-hfcnc-2ohyg-p6qqq-rae"
}
```

A "mint" event can also have a purchase price associated with it, as we see with this example:

```
// Sale (BTC Flower)
{
  "time": 1670588669701,
  "operation": "sale",
  "details": [
    [
      "to",
      {"Text": "58a0fcbd3ae8d5589f9b7e3208b979867b44d04b8d4d1bfe2ede9f641973243f"}
    ],
    [
      "from",
      {"Principal": "jqazm-bdzbj-hnq3o-yexug-vqu3v-jonju-7ngcp-4yzbw-jyux4-lqejy-mae"}
    ],
    [
      "price_decimals",
      {"U64": 8}
    ],
    [
      "price_currency",
      {"Text": "ICP"}
    ],
    [
      "price",
      {"U64": 18000000000}
    ],
    [
      "tokend_id",
      {"Text": "jz2z7-3akor-uwiaa-aaaaa-beaag-maqca-aaaq7-a"}
    ]
  ],
  "caller": "s4d6r-c23m5-5gapy-myo3t-7pgtm-pdf6g-3nepw-hfcnc-2ohyg-p6qqq-rae"
}
```

Some projects opted to add the "memo" field:

```
// Transfer (Cronics)
{
  "time": 1670345256752,
  "operation": "transfer",
  "details": [
    [
      "token",
      { "Text": "oz5mx-cykor-uwiaa-aaaaa-b4aaq-maqca-aacq3-a" }
    ],
    [
      "to",
      { "Principal": "icdsn-5xpay-zrct4-of2q2-hyhrs-ftoyx-se5w7-xhzri-psrh4-ksiyr-bqe" }
    ],
    [
      "from",
      { "Principal": "tetgr-gbsy6-6hauq-s64fd-4qbcs-tkzqq-gmn26-3u5am-6bmn5-g2wi4-xqe" }
    ],
    [
      "memo",
      { "Slice": { "0": 0, "1": 0, "2": 0, "3": 0, "4": 0, "5": 0, "6": 0, "7": 0, "8": 0, "9": 0,"10": 0,"11": 0,"12": 0,"13": 0,"14": 0,"15": 0,"16": 0,"17": 0,"18": 0,"19": 0,"20": 0,"21": 0,"22": 0,"23": 0,"24": 0,"25": 0,"26": 0,"27": 0,"28": 0,"29": 0,"30": 0,"31": 0 } }
    ],
    [
      "balance",
      { "U64": 1 }
    ]
  ],
  "caller": "tetgr-gbsy6-6hauq-s64fd-4qbcs-tkzqq-gmn26-3u5am-6bmn5-g2wi4-xqe"
}
```

Looking forward to the next discussion! I hope this provides some useful reference.

-------------------------

benji | 2023-02-14 17:04:32 UTC | #5

As the NFT Working Group is coming close to having a consensus on the minimal standard, I would invite all members of the community to review and post comments here on the forum, as well as under the github issue.
https://github.com/dfinity/ICRC/issues/7

The draft text of the standard is here: https://github.com/dfinity/ICRC/blob/repo-init/ICRCs/ICRC-7/ICRC-7.md

Latest slide on pending issues: https://docs.google.com/presentation/d/1kCy2pVOMbvH2j6gutmNWk7q-bvTRKdrqtsgPG4_MjVk/edit#slide=id.g125c3b1bfa8_0_0

The next WG meeting is on Feb 28, please participate if you're interested.

-------------------------

benji | 2023-03-14 17:20:20 UTC | #6

Hi IC NFT People! I'd like to re-iterate some points we brought up during the recent working group meeting. There are a few things we'd like to explore for the ICRC-7 standard:

1. A GraphQL interface for canister metadata: We propose creating a GraphQL interface for canister metadata to provide a flexible and efficient way for developers to query information about a canister's state. This is important since NFT metadata can be quite large in size.

2. JSON HTTP interface for the canister: We suggest implementing a JSON HTTP interface for canisters to enable developers to interact with canisters over the web without needing agentjs. This would allow developers to use a wide range of programming languages and tools to build applications for NFTs on the IC. References [here](https://nges7-giaaa-aaaaj-qaiya-cai.raw.ic0.app/10.json) and [here](https://github.com/sagacards/legends-nft).
3. Transaction history similar to [ICRC-3](https://github.com/dfinity/ICRC-1/tree/roman-icrc3/standards/ICRC-3) and compatible with CAP if possible.

4. Permit transfer similar to [ICRC-2](https://github.com/dfinity/ICRC-1/blob/main/standards/ICRC-2/README.md).

If you have specific comments or insights regarding those points please don't hesitate to contribute.

-------------------------

cymqqqq | 2023-03-16 08:14:25 UTC | #7

Hi there, I want to know when we can deploy nft canisters based on icrc-7 standard on IC? :grinning:

-------------------------

benji | 2023-03-16 13:07:45 UTC | #8

Soon™ :grinning:
Realistically next steps are: a reference implementation, potentially make some modifications to the draft standard in the process, and vote on the standard.

-------------------------

yvonneanne | 2023-05-11 06:50:22 UTC | #9

Hi everyone
What's the status of the standard, reference implementation etc? What are the main obstacles problems and blockers?

-------------------------

skilesare | 2023-06-20 04:21:02 UTC | #10

I'm sorry for the delay on this one...I was able to take some time of with my youngest son while my older kids were away at camp and the managed to get in a week away with my wife which is a bit of a rarity these days...thanks for the patience.

I took a stab at ICRC8 as I promised to the working group a month or so ago, a more robust NFT standard that aims to use the power of the IC to fix some of the inherent problems in "standard" NFTs that we've inherited from Ethererum.

So far I've just tackled the query side of things as I think that gives us plenty to talk about in this week's meeting:

https://github.com/skilesare/ICRC/blob/patch-1/ICRCs/ICRC-8/icrc8.mo

-------------------------

alanscarpellini | 2023-07-17 12:39:09 UTC | #11

Hi everyone!
just added few considerations/issues on the standard in the Github issues page (https://github.com/dfinity/ICRC/issues/7). I think there are still some open issues to think about. 
At the moment I'm working on a Motoko implementation of the ICRC-7 standard (well, the draft). I hope to make it available to everyone as soon as possible.

-------------------------

infu | 2023-07-17 15:29:03 UTC | #12

I assume TransferError.TemporarilyUnavailable can be used to protect against DoS attacks ?
The implementation could for example allow only X transfers per hour and return a TemporarilyUnavailable error if exceeding.

-------------------------

skilesare | 2023-07-17 21:37:47 UTC | #13

Hey all,

I made some changes and added the updated functions to the ICRC8 proposal...not sure if there will be time to talk about it tomorrow or not.

https://github.com/skilesare/ICRC/blob/patch-1/ICRCs/ICRC-8/icrc8.mo

I decided to include a general mirror of the ICRC7 8 transfer, transferFrom, and approve flow even though, in my opinion, they break NFTs.😬 It will be up to the implementation to decide if they want to implement these.

-------------------------

skilesare | 2023-07-17 21:42:00 UTC | #14

A few notes on our implementation of ICRC7 for the origyn nft here:  https://github.com/dfinity/ICRC/issues/7#issuecomment-1638924431

Icrc7 Implementation Notes

Last week we implemented the current draft of the ICRC7 standard into the ORIGYN NFT. 

While we have been working with the working group to help develop ICRC7, ORIGYN foundation has taken a stance since the beginning that we think that the general principles behind ICRC7 exacerbate the inherent issues with NFTs that arose out of the limitations of the Ethereum architecture and that the group should instead focus on an NFT standard that utilizes the full potential of the IC ecosystem. 

The group is now discussing that with ICRC8 and we’re progressing well.  Since the group wanted to do a more eth-like standard in ICRC7, we participated and contributed to its development as best as we felt the standard could be developed.  We have every intention of supporting whatever standards are approved, just as we already support the EXT standard and the DIP721 standard.  In that spirit, we undertook to implement the ICRC7 standard into the existing implementation of the origyn_nft standard.  As is usually the case, some issues with a system won’t be seen until you actually try to implement it. In that spirit, the following is our implementation report of ICRC7 which we hope will be helpful in finalizing the standard.

**icrc7_owner_of query** - It seems odd that this does not have a result response.  Since it is possible to request the owner of a token_id that does not exist, the best we could do was trap if the token doesn’t exist.  It may make more sense for this function(and perhaps the other query functions that let you request a response for a token id that may not exist to have a return type of 

{
#Ok(return_type);
#Err({
#NotFound;
#GenericError({
message: Text; 
error_code: Nat})
};
}

**Metadata Limitations** - We’ve proposed elsewhere the ICRC16 standard for recursive, candid like, extensible metadata.  We’d repropose it be considered here. We recently updated it so that can be a supertype of the ICRC3 transaction event type metadata and it makes sense to do the same here. Because we didn’t really have the control we wanted here(for example, we have a manager array and with no way to return a manager we were faced with having to have list of “com.origyn.manager.1”,“com.origyn.manager.2”,“com.origyn.manager.X…”.  There is also not a Principal type which is odd considering how much principals are used in the IC(you can convert to Blob, but it is going to be really messy to read on transaction logs).  Text is another option but takes more space).  We chickened out and have one “metadata” field that is the json text representation of our nested, recursive metadata.

**Versions evolve** - The icrc7_supported_standards has a return of vec [(Name, URL)].  It may be that some standards evolve and thus end up with a version number. (we are already on origyn_nft v0.1.5 which does have some differences).  We think this schema can support that with different URLs, but a version field might be worth a second consideration.

**No way to get all token IDs** - the collection metadata query does not return the token ids and there is no other query function to do so.  We’d recommend an ircr7_token_ids( opt {skip: Nat; take: Nat}) to allow paginating IDs.  I think there is an assumption that tokenids will be sequential and from 0 to total_supply-1, but this is not how we implement it.  Origyn_nft has text based token_ids for readability and human cognition and recognisability.  We convert these strings to a Nat when we implement ICRC7 or DIP721 and they are not sequential.

**Is_atomic in transfer args** - We do a number of potentially async functions when transferring around NFTs, including KYC, paying royalties, recognizing deposits, etc.  Atomicity is not something we can support, and we’d argue that any sufficiently interesting or complex system with real-world utility is going to have the same problem on the IC.  Encouraging that atomicity is possible/reliable is creating a very hard-to-untie knot for developers. This can become especially troublesome for generic 3rd party services that may assume you have atomicity when you actually don’t.  We chose to reject any request for transfer where atomicity is requested.

**Multiple token transfers but singular response** - We keep separate ledgers for each token id.  We could support batch transfer requests(and in fact do support this in the origyn_nft standard), but each transfer will have its own response.  The fact that the standard assumes a singular response from this function is odd.  As a result, we are currently rejecting any request for more than one token_id at a time.

**Approve** - Origyn NFTs see an existing escrow of tokens as the approval of a transfer as a market transaction.  As a result, this function doesn’t have enough information in the event args to make sense to an origyn_nft and we trap automatically.

**Metadata unification** - The Collection metadata is hard coded to an object type, but the NFT metadata is extensible.  Perhaps the Collection metadata should use the same format as NFT metadata?

**Royalties** - royalties were awkward to implement.  We support a menu of royalty recipients and distinguish between primary and secondary markets.  ICRC7 lets you pick one pay-to-account and one amount.  We chose to sum up the secondary royalties and created a sub-account on the canister to direct these two. We can, in the future create a system for distributing anything sent to this account, but given that all transfers happen through our in-nft market mechanism the royalties would be auto-distributed.  As a result, anything sent here was probably done by mistake. We’ll propose a better way to report this info in ICRC8, and there may not be a solution here because the demand is for simplicity.  One solution might be to just move this to collection metadata if it is adjusted to be extensible considering this standard is just asking marketplace to honor this and there is no actual assumed enforcement mechanism.


**Supply Cap** - We don’t really have this concept(supply is controlled by the minter, so if you built some kind of capped supply you’d need to program that in the minting contract). We return null.

-------------------------

infu | 2023-07-19 11:40:22 UTC | #15

Few notes for what we want the spec to contain:

add: `icrcX_metadata_bulk([nat])` in case a canister receives 100 NFTs and wants to fetch all of them. Making 100 queries instead of 1 will make it hard to accomplish. Actually. scratch that, it's not enough. 

In general, I believe it's a good idea to allow other canisters to "sync" the NFTs they want and work with locally. What will that look like:

`icrcX_tokens_meta_of(Account, last_checkpoint, limit) : (vec (nat, Metadata)) query;`
Notice you get the metadata too, not only the token id. Last_checkpoint points to index last_updated+id. You get only `limit` results and if you receive less than then the limit, then it's the last page, if not you keep on pulling more. This means, if an account has 1000 Nfts and you send it one, it doesn't have to fetch them all again, it will get only what got changed. That kind of sync is used by RxDB and is pretty easy to handle on the IC. Easy to implement that index with RxMoDb. 

Similarly:
`icrcX_metadata_sync(last_checkpoint, limit) : (vec (nat, Metadata)) query;` returns a list of all NFTs and their Metadata ordered by last updated. Another canister can use that to copy the whole NFT memory and keep it synced cheaply. Once everything is copied, it will only get what's changed and won't have to fetch everything again. 

Not 100% sure about the next one:
`icrcX_metadata_all_indexes() : [Text]`
`icrcX_metadata_indexed(index_name:Text, ?lastid, limit) : (vec (nat, Metadata)) query;` Will do something similar, but allow the NFT canister to keep custom indexes. This is helpful for UIs when they want to get all NFTs with a certain ordered attribute.

Metadata:
Since we can now serialize from and to Candid. I wonder if we shouldn't just keep normal candid data structures inside the canister and when giving them to the outside world, have the option to serialize them to blob. UIs in JS can easily handle dynamic meta schema. Canisters can't, so for them blobs are better. They will be able to store the metadata without knowing what it is. If they know what the schema is, they can parse and work with it. An NFT can actually be split into multiple meta schemas [(MicroSchemaId, Blob)]. Micro schema IDLs will be stored on-chain and also standardized. This way a group of games can agree on a micro_schema for various item types like avatars, swords, etc. Then a canister that wants to work with these will fetch and add them to their code. Decode the blob and use them. Additionally, NFTs collections can add micro schema blobs to their NFTs without the need to update canisters. That's something Candy solves partially right now. I guess what it doesn't solve is, well - if you receive Candy and you don't know what's inside - perhaps you don't have the schema for working with game items for a certain game - then you still can't really work with the Metadata. You can traverse it, but not do anything meaningful. You can only work with what the fields you know about. Multiple micro schemas will let you work with what you know and let you ignore what you don't know the same way as Candy. You can also have a Candy micro schema and just put it all inside. I guess it's something that needs experimenting with. I may create another ICRC standard with all these ideas. Maybe we will converge on a later version.

If we add `[MicroschemaId]` field in the above queries, the client will be able to request what it wants exactly. A game can do something like this:
icrcX_tokens_meta_of(Account, ['author','managers','vehicle-v3'], last_checkpoint, limit) : (vec (nat, Metadata)) query;
And receive:
"author", { author: ..., license: ... },
"managers", [ {principal, permissions}, {principal, permissions} ],
"vehicle-v3", { model: ..., year: ..., parts: ... ,attachments:... }

-------------------------

infu | 2023-07-19 13:00:16 UTC | #16

I think ICRC8 is pretty powerful and allows the NFT canister to do more than just be a ledger. It's what I am doing with Anvil too, the marketplace functionality is inside, not in another canister. 

How will this functionality get handled in what I have in mind:
Let's take the Dutch auction functionality in ICRC8 for example:

It adds:
![image|482x430](upload://lHvktCSXdaVhBGr2j71OL3Ca4tT.png)
and
![image|464x56](upload://cussHvIrgZ2IFsCNk9stlEr0Wq1.png)
to AskFeature (Which is something like the micro schema)
As far as I can tell It adds transactions type too
![image|682x288, 75%](upload://aLsX9QQ3prGQJhZrieEu8QZsgkN.png)
![image|497x500](upload://t7A5G4uGeLMdmS1H4euKlUlVPsD.png)
and actor functions
![image|690x20](upload://2n20e6b6JjLag6zJAiH1d1aeeGC.png)
![image|690x25](upload://124SHfRRBqnRNVIrQNWHurqyOiI.png)
![image|690x36](upload://erekLaPOH1mUrsWBLqYfCYp15jc.png)

But then that's not the only auction type. Here are different ones:

![image|548x500](upload://oFV9IDYSUc25DjnfHdOYu70sOSv.png)

On one side, it's good to focus on something that works and let it spread across the whole ecosystem. On another, it's disabling innovation. You will need another standard to add another type of auction.

One way to solve this is by keeping the ledger inside one canister and also providing other auxiliary canisters which sync the ledger and provide these functions. They can be still owned by the creator of the ledger canister, but also someone who doesn't want to develop their Dutch auction, can buy a license for a canister doing it and attach it to their ledger. (We will have to check implementation specifics to know if it will be secure and fast tho) Then you will need standards for each auction canister too. 

Another way - have micro schemas/ micro standards that work inside IcrcX (not sure what number to put) and provide:
- additional transactions
- additional functions
- additional metadata

IcrcX is made so it can contain and work with these without knowing them. The canister implementation can know their schemas and work with them, but the standard doesn't need to. For the standard, they are blobs and pointers to what these blobs mean.

So in theory you should be able to split ICRC8 into one IcrcX and ~10 micro schemas and get the same functionality inside one canister.

With something like what Neutron is doing - compiling multiple modules inside one canister, you can probably offer good dev experience (they won't need to reimplement everything on their own) and it will allow devs to provide modules and upgrades. If these aren't pluggable modules, the implementations may differ and even tho there is a standard, things may work differently. But then you will have to do these systems for each IC language.

If the functionality is added in auxiliary canisters, then you have to deal with asynchronicity, and multiple canisters, but your NFT can be a mix of Rust with Motoko and Azle.

If the functionality comes from 3rd party canisters, then again you deal with asynchronicity, but also you add another party that needs trust & takes a cut from the tokens going thru it. These contracts can be immutable and take fees from usage or only add NFT collections which pay a fee, but if things change or there are bugs, you will need to spawn another canister. Your immutable canister can't benefit from IC CDK improvements. You can't handle the whole ecosystem with one canister, so you will need a swarm. If you want to make that small piece of functionality SNS-controlled, then we are going to end up with hundreds of small-cap DAOs which someone can take over and break the whole thing. 
A lot of strategic trade-offs to be made. Let me know what you prefer.

-------------------------

skilesare | 2023-07-19 15:34:12 UTC | #17

We talked a lot about this on the last call.  The main point of contention was around ICRC7 having approvals or not.  For Fungies we separate this into ICRC1 and ICRC2(mostly as a legacy of the ICP ledger).  You can get a bit overboard with this as I could argue that transfer is not needed for soulbound NFTs. So should we split every thing into different numbers?

Well, there are no standards police and I'd argue that the end state justifies what ever we want to do.  The suggestion was to leave ICRC7 as it is and define some "supports" hints in the standard that a developer can deliver to wallets that might want to know something about what is supported and what isn't.  ie:

icrc7_no_transfer
icrc7_no_approval.

If you query 'ICRC7_supports' and you get these, you should not make the transfer and approve options available.

I'd say the same is true for ICRC8(which we are just at the beginning of). Likely we'd need to have a few support entries for different marketplace features.

ICRC8_wait_for_quiet
ICRC8_dutch
ICRC8_royalties

ICRC8 also calls for some definition around metadata...we have opinionated metadata entries in origyn_nft(like how royalties are defined, other system variables) and those likely need to be defined as well so you can tell a canister or service if they should be looking for these items(Maybe we can use ICRC16 schema for part of this that @ZhenyaUsenko has been developing).

So a standard is more than just the definitions of the actor functions and types.  We may need to define metadata schemas, support definitions, etc.

As far as those other sales types go we can add them...maybe they aren't ICRC8, but a set of them may be ICRC9, and with the ask system using variants, they can just be additions of the variants without having to add any more functions.  A dev will be able to use aggregated types I think to:

public type AskFeature = ICRC8.AskFeature and ICRC9.AskFeature(Do ands combine variants as well as properties?  I hope so.).

As far as your microschema metadata-of function goes, there is a bit of this already in the icrc8_nft_info:

```
public type NFTFieldRequest = {
    #current_ask;
    #current_offers : (?Nat, ?Nat); //skip, take
    #metadata: Text; //candypath
    #transaction_count;
    #transactions: (?Nat, ?Nat);
    #owner;
    #managers;
    #allocated_storage;
    #available_storage;
    #minted_date;
    #burned_date;
  };
```

The fields that need pagination have them....and as it comes to metadata, it allows a candypath to select different things, so likely the standard would need to define the paths that should be available, which are optional, etc...likely they should have corresponding names and can be added to the 'supports' query as well.  (There may be a better solution for supports than just a vec of Text...one thing I'd been thinking of was versioning....some of these icrcs may need to evolve...or maybe we need to be hardened and if you're going to replace 8 with 8-1 and if you need to go grab the next ICRC available(say 325) and don't do versioning.

There is definitely a path forward here that is neutrony...but maybe not full neutron?  If these features can be built openzepplin style then I could see a tool where you just check the features you need and it spits out some starter code.  But I do also like the thought of being able to construct with features....we'd have to think about the kernel a bit and how data sharing works.

-------------------------

infu | 2023-07-19 15:50:45 UTC | #18

[quote="skilesare, post:17, topic:16566"]
public type AskFeature = ICRC8.AskFeature and ICRC9.AskFeature
[/quote]

Ok, this will work for Metadata I suppose, if a canister doesn't know about all of the features, since they are variants. 
Adding other icrc* functions will also work.
But having variants in TransactionRecord that the client doesn't know about, won't that produce an error in Motoko?
Maybe if 
`#transactions: (?[TransactionRecord], Nat);` becomes 
`#transactions: (?[?TransactionRecord], Nat);`
The ones you don't know about will probably become null after deserialization.
If all these work, I suppose no need to have blobs around.

-------------------------

skilesare | 2023-07-19 15:52:08 UTC | #19

I need to look at the new stuff that they did for ICRC3 and likely adopt that syntax...I think it avoids this issue.

-------------------------

tokuryoo | 2023-08-07 05:42:44 UTC | #20

[github - ICRC-7.md](https://github.com/dfinity/ICRC/blob/main/ICRCs/ICRC-7/ICRC-7.md)

>  If a tokenId doesn't exist or if the caller principal is not permitted to act on the tokenId, then the tokenId would be added to the Unauthorized list. If is_atomic is true (default), then the transfer of tokens in the token_ids list must all succeed or all fail.

What is the default value for is_atomic? I think true is safer, so the default should be true.
However, considering the following scenario, it might be better if the default were false."
What do you think?

[https://forum.dfinity.org/t/call-for-participation-nft-token-standard-working-group-status-updated/16566/14](https://forum.dfinity.org/t/call-for-participation-nft-token-standard-working-group-status-updated/16566/14)
>**Is_atomic in transfer args** - We do a number of potentially async functions when transferring around NFTs, including KYC, paying royalties, recognizing deposits, etc. Atomicity is not something we can support, and we’d argue that any sufficiently interesting or complex system with real-world utility is going to have the same problem on the IC. Encouraging that atomicity is possible/reliable is creating a very hard-to-untie knot for developers. This can become especially troublesome for generic 3rd party services that may assume you have atomicity when you actually don’t. We chose to reject any request for transfer where atomicity is requested.

-------------------------

benji | 2023-08-10 09:10:03 UTC | #21

During the last WG meeting we decided to remove the `is_atomic` feature, because this would require the transfer method to be fully synchronous, which limits its use cases (eg. the transfer method might need async checks before performing the transfer).

The specs would be updated accordingly.

-------------------------

Ivan | 2023-08-16 13:46:16 UTC | #22

Can insiders give any update on this?

-------------------------

benji | 2023-08-16 17:35:00 UTC | #23

We've discussed and decided on almost all issues uncovered during the implementation phase (still a couple of minor issues pending). The final draft for community review will be released in about 2 weeks.

-------------------------

dieter.sommer | 2023-09-11 14:08:24 UTC | #24

Dear NFT WG Members!

In the meeting tomorrow, Tuesday Sep 12, 17:00-18:00 UTC+2 time, we want to discuss the following agenda items:
- Initiating the voting for ICRC-7
- Other pending discussions, e.g., regarding the extended token standard

Talk to you tomorrow!

-------------------------

ivan_uncensored | 2023-09-21 06:52:28 UTC | #25

Can you give us progress update on NFT standards @benji @dieter.sommer ?


Why is it taking DFINITY years to create an NFT standard? What is holding DFINITY back? Does the growth team want us to go to Entrepot for DFINITY endorsed "NFTs"??



**If DFINITY fails to address these issues immediately, we will be creating Topics addressing the issue directly, instead of posting in replies.**

-------------------------

ivan_uncensored | 2023-09-21 07:12:45 UTC | #26

Umm.. its been more than 2 years? 35 days since update to be precise

Discussions have started in 2021.

https://forum.dfinity.org/t/ic-nft-a-new-nft-standard-provide-full-traceability-and-verifiability/8433

https://forum.dfinity.org/t/assigned-bnt-5-icrc-7-nft-implementation-rust-or-motoko/19414
- July 21

https://forum.dfinity.org/t/non-fungible-token-nft-standard-community-consideration/6157

-------------------------

dieter.sommer | 2023-09-21 07:30:38 UTC | #27

The basic NFT standard is very close to completion and some remaining issues need to be addressed that popped up last minute in the community. Once those issues are addressed, the standard can go into WG voting and, once successful, NNS voting. So the WG is very close to finishing the basic NFT standard ICRC-7.

-------------------------

ivan_uncensored | 2023-09-21 10:39:16 UTC | #28

Very close to completion is not completion.



How many days does it take DFINITY to build a basic feature that should have been built since the genesis if at all it cared about building World Computer.



The discussions started two years ago. Now NFT ecosystem on ICP is practically dead. Ironic for a Metaverse chain. 

**Props to the Growth team and state of the art marketing by DFN /s.** 🤣



I’m beginning to think its not a mistake but a deliberate choice made by DFINITY. Creating dependencies and cartel like environment for rugging users and builders



No offense to @benji @dieter.sommer

-------------------------

dieter.sommer | 2023-09-25 16:43:02 UTC | #29

For tomorrow's WG meeting, the goal is to tie up the loose ends and then go into WG voting as soon as we can. Based on the discussions in the recent WG meeting, please find the [update of the draft](https://github.com/dfinity/ICRC/pull/33/files) here (link contains the diff to the previous version discussed in the meeting of Aug 29).

Here's a laundry list of [open issues](https://docs.google.com/document/d/1CRXbXUy4mia_cEErA3tmEL_dx2HTfc64nkaewZscwdo/edit) that need to be tackled, some of them have optimistically been addressed in the draft already.

Hope to see many of you in tomorrow's meeting!

-------------------------

dieter.sommer | 2023-09-26 14:56:29 UTC | #30

The latest working draft of ICRC-7 with some more updates can be found here:
[ICRC-7 draft latest](https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md)
[Diff August 17 <> latest](https://github.com/dfinity/ICRC/compare/9acbcde..9c5cf71)


Talk to you later!

-------------------------

Artemi5 | 2023-09-27 16:35:15 UTC | #31

Whoa, Ivan is rude..

hey @dieter.sommer how many more drafts until deployment of an NFT standard on Internet Computer?


Hope this helps :+1: 

https://ethereum.org/en/developers/docs/standards/tokens/erc-721/

-------------------------

dieter.sommer | 2023-09-28 15:11:53 UTC | #32

I did another round of editing over the standard:
[Draft](https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md)

There are some open issues marked with // FIX ...

Some main ones we should quickly conclude on:
* Should we replace the current record-based metadata with one analogous to ICRC-1, where we have a generic map-like structure that can hold any metadata? I think the general agreement was yes, the only drawback is that then the Account for the royalties recipient would need to be encoded as blob which is more tedious to use.
* Are people fine with the way batch calls are modelled in terms of their return value? The idea is to have a vector or records in the return, where each record contains the token id as first element and the corresponding response or error as variant in the second element.
* Do we need a QueryError type as part of a potential error response for queries, or can we skip this and use only system errors in the query case, which would greatly simplify the API.

Would be great to get some feedback so we can finalize the document shortly!

-------------------------

Artemi5 | 2023-10-09 08:36:07 UTC | #33

Good Morning Beautiful people of DFINITY


Our team has allocated 15 Hours this week to manage DFINITY OPs and speed up the process of creation of an NFT standard which is 3 years overdue.


Hope everyone had a good vacation and got plenty rest


Progress updates on NFT Standard?

-------------------------

dieter.sommer | 2023-10-09 17:15:30 UTC | #35

Dear WG members!

Tomorrow Oct 10, 2023 we would like to finalize the ICRC-7 draft and start voting on it!

The draft has been substantially refined according to the recent discussions in the WG and additional considerations like, for example, the following:
* Polishing
* Making the specification clearer, removing ambiguity
* Making the use of batch / non-batch methods consistent
* Unifying the responses according to API patterns

Please find the most recent draft [here](https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md).

And find a diff to the earlier draft of August 17 [here](https://github.com/dfinity/ICRC/compare/9acbcde..5c3ccb6).

The draft still contains a number of items labelled “FIX” that we need to discuss and make a decision on in order to can finalize ICRC-7.

Hope to see many of you in tomorrow’s meeting!

-------------------------

dieter.sommer | 2023-10-16 11:00:01 UTC | #36

Dear Working Group!

The changes agreed in the recent WG meeting have been implemented in the ICRC-7 draft. In our opinion the draft is now stable. It is time now for the WG to have a final look over it and next to start the voting on it.

[ICRC-7 current draft](https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md)
[Diff to version of the WG meeting of Oct 10](https://github.com/dfinity/ICRC/compare/5c3ccb6..1a7d2c9)

@skilesare, @sea-snake, @cryptoschindler, Matthew, all, please have a look over the draft and let us know whether you have any remaining comments.

**Updates:**
* Minor edit addressing sea-snake's comment on `nat32` for `take`
* Readibility edits to break remaining long method signature into multiple lines

-------------------------

skilesare | 2023-10-16 14:46:41 UTC | #37

This is looking pretty good. I'll raise one issue here that may be worth thinking about(although since the items are all vecs it may not be an issue.

Do we need to review if any of the Value types or Error types need to be opt Value or opt XXX_Error for reasons expressed in this thread:  https://forum.dfinity.org/t/icdevs-org-voting-incident-report-and-stable-api-discussion/23510

Are there any places where this would make pseudo-compatibility with an evolution of this standard easier?  The result would be that nulls would be returned in place of future Value(ICRC16) or XXX_Error(If we want to add errors in ICRC8 or some other standard) that don't match the exact variants offered without breaking compatibility. Canisters can choose how to handle unknown nulls.

I may be overthinking this. Perhaps the NNS team can weigh in here with an opinion? cc @sasuki

-------------------------

cryptoschindler | 2023-10-16 17:50:51 UTC | #38

some thoughts i had when reading the draft:
* should we add an entry to the metadata that enumerates the generic errors by a specific implementation? together with a specific endpoint to query for them?
* should we have endpoint for single token queries? e.g. `icrc7_get_approval`
* transaction deduplication section mentions ICRC1
* **icrc7_collection_metadata**
  * seems cumbersome, try assembling ICRC7 suggested fields
  * why not follow cap and have (Text,Value) tuple or vec record { text; Value } at the top level
  * do we need to prefix suggested metadata fields with icrc7 as well?
* **icrc7_token_metadata**
  * doesnt specify Metadata type
  * what is the behaviour if token id does not exist? will it just not be in the response or will there be an explicit error?
  * should this be compliant with behaviour of icrc7_owner, meaning return a Result
* **icrc7_owner_of**
  * says null is returned if token doesnt exist, but lists variant with Err case that contains NonExistingTokenId
* **icrcr7_balance_of**
  * why not 0 instead of null
* **icrc7_tokens & icrc7_tokens_of**
  * should we add default value for take to metadata and create own method to query? like for batch size and approvals?
* **icrc7_approve_tokens**
  * multiple approvals can exist for the same `token_id` but different `spender` s and `subaccount`
    * ^ what does this mean? different spender already suggest difference subaccount?
  * emphasize that spender subaccount is arbitrary as we only check principal when actual transfer happens
  * what error do we throw if the token id doesn't exist? 
  * in what case do we throw `TemporarilyUnavailable`?
  * `expires_at` semantic should be explained
* **icrc7_approve_collection**
  * text seems wrong, duplicate response text 
  * candid method has the wrong name, candid types are missing 
* **icrc7_transfer**
  * here we say if the token doesn't exist, we throw `Unauthorized`. should this be adapted to the above methods where i raised the issue?
   * do we need deduplication? if the token id is transfered, calling transfer should already throw `Unauthorized` :thinking: 
  * we should add the `created_at_time` hint for the `approve` methods as well
* **icrc7_revoke_token_approvals**
  * mention that only owner can revoke approvals
  * mention what happens when token does not exist
  * why is spender `opt`?
* **icrc7_revoke_collection_approvals**
  * why does this return a vector? should be analaogue to `approve_collection`, so either add it there as well or remove for both
  * should be called `icrc7_revoke_collection_approval` instead of `approvals`
  * candid types are missing
* **icrc7_revoke_all_collection_approvals**
 * this should either contain more information in the return type, so that it is clear to which collection wide approval the response belongs (e.g. via `from_subaccount` and `spender`) or fail/succeed atomically and only return one result instead of a vector
* **icrc7_is_approved**
  * typo in `ac`

-------------------------

sea-snake | 2023-10-16 18:10:58 UTC | #39

[quote="cryptoschindler, post:38, topic:16566"]
icrc7_collection_metadata
[/quote]

Yeah I remember we discussed this in the meeting, I've also mentioned it in the [PR](https://github.com/dfinity/ICRC/pull/33) now.

-------------------------

kayicp | 2023-10-17 00:34:07 UTC | #40

hi can somebody explain to me why `Principal : principal;` is not included?
is it because of the `Account` type?

![image|690x381](upload://ph5jw6mhkXAkXBk3gfqJwDYnRLD.png)

-------------------------

skilesare | 2023-10-17 02:24:40 UTC | #41

Principals can be easily represented with a blob. I like having a specific type and offering intentionality and suggested ICRC16 which has all candid types, but the group went with simplicity(which is the intent of this first nft standard, so I didn't push back too hard).

-------------------------

dieter.sommer | 2023-10-17 06:30:21 UTC | #42

[quote="skilesare, post:37, topic:16566"]
Do we need to review if any of the Value types or Error types need to be opt Value or opt XXX_Error for reasons expressed in this thread: [ICDevs.org Voting Incident Report and Stable API Discussion ](https://forum.dfinity.org/t/icdevs-org-voting-incident-report-and-stable-api-discussion/23510)
[/quote]

@skilesare, good question! This would only concern the variant return types, where the variants would need to be made optional so that in case of an extension of the variant clients don't break. The cases that are potentially concerned are all similar in that they have an `Ok` with the transaction index and an `Err` with different variants and a `GenericError`. The `Ok` seems to me to be pretty much what we would ever want in this standard, the `Err` already as the `GenericError` so that one could argue that not more is needed. So I'd argue we can go without making the variants in those cases optional.

Other opinions?

-------------------------

dieter.sommer | 2023-10-17 07:14:18 UTC | #43

[quote="cryptoschindler, post:38, topic:16566"]
some thoughts i had when reading the draft:
[/quote]

Thanks a lot, will be going through them and fix the ones that do not need discussion and put the others up for discussion.

-------------------------

benji | 2023-10-17 13:13:30 UTC | #44

[quote="cryptoschindler, post:38, topic:16566"]
emphasize that spender subaccount is arbitrary as we only check principal when actual transfer happens
[/quote]

That is not true. We check both spender AND subaccount at transfer.

-------------------------

dieter.sommer | 2023-10-18 13:25:34 UTC | #45

Hi @cryptoschindler!

Thanks a lot for your thorough review that gave us very valuable feedback! Here's a response to your points, some of them have been resolved, others still need decisions in the group, see my open points concluding the post.

> * should we add an entry to the metadata that enumerates the generic errors by a specific implementation? together with a specific endpoint to query for them?
Do we already have generic errors defined by now? Don’t think so. If so, it would make sense.

> * should we have endpoint for single token queries? e.g. `icrc7_get_approval`

I thought the idea was to have just batch methods.

The only difference in usage when using the non-batch methods would then be to not require the vector for the `token_ids`, but a single argument. The opt parameters for pagination can be left out. Considering this, they are not really necessary.

Implementation wise it would not be a big thing to add those methods. 

Thoughts?

> * transaction deduplication section mentions ICRC1

Good catch! Changed to ICRC-7.

> * **icrc7_collection_metadata**
>  * seems cumbersome, try assembling ICRC7 suggested fields
>  * why not follow cap and have (Text,Value) tuple or vec record { text; Value } at the top level
>  * do we need to prefix suggested metadata fields with icrc7 as well?

Changed to `vec record { text; Value }` which was my intention following the discussion, but must have missed this change originally.

We should use the same namespacing mechanism as defined for [ICRC-1 metadata](https://github.com/dfinity/ICRC-1/tree/main/standards/ICRC-1#key-format) and use the `icrc7` namespace in analogy.

> * **icrc7_token_metadata**
>  * doesnt specify Metadata type
>  * what is the behaviour if token id does not exist? will it just not be in the response or will there be an explicit error?
>  * should this be compliant with behaviour of icrc7_owner, meaning return a Result

This was a remainder when we have the `Metadata` type.
Switched to `Value`.

For a non-existing token id we have the following options:
* Return no value
* `null` value for metadata; this requires to make the `metadata` optional
* Return an error (like for some other queries)

We should align the behaviour for all relevant interfaces. We had errors contained in the queries using a variant, but then removed them as the API was rather convoluted. That’s an important point to address.

> * **icrc7_owner_of**
>  * says null is returned if token doesnt exist, but lists variant with Err case that contains NonExistingTokenId

Like above, we should consolidate the error handling for queries.

> * **icrc7_balance_of**
>  * why not 0 instead of null

`null` gives the caller more information, namely that the token does not exist. But 0 would be appropriate as well.

> * **icrc7_tokens & icrc7_tokens_of**
>  * should we add default value for take to metadata and create own method to query? like for batch size and approvals?

Yes, it’s there now.

> * **icrc7_approve_tokens**
>  * multiple approvals can exist for the same `token_id` but different `spender` s and `subaccount`
>    * ^ what does this mean? different spender already suggest difference subaccount?
>  * emphasize that spender subaccount is arbitrary as we only check principal when actual transfer happens
>  * what error do we throw if the token id doesn’t exist?
>  * in what case do we throw `TemporarilyUnavailable`?
>  * `expires_at` semantic should be explained

Made the subaccount aspect clearer and changed it to `from_subaccount`s.

We also check `subaccount`, not just `principal`.

Error handling should be unified for all query methods.

> * **icrc7_approve_collection**
>  * text seems wrong, duplicate response text
>  * candid method has the wrong name, candid types are missing

Thanks, copy-paste error. Text is fixed.

The method uses the same Candid type as another one where the type is defined. I wondered whether we should repeat the types, but that may lead to inconsistencies, thus may not be the best idea. Maybe refer to where the type is defined. What’s your opinion?

> * **icrc7_transfer**
>  * here we say if the token doesn’t exist, we throw `Unauthorized`. should this be adapted to the above methods where i raised the issue?
>  * do we need deduplication? if the token id is transfered, calling transfer should already throw `Unauthorized` :thinking:
>  * we should add the `created_at_time` hint for the `approve` methods as well

Yes, we need to unify the error responses for all applicable methods.

Deduplication: Very good question. Reading your thoughts and rethinking this, I think we might not strictly need it because of the non-fungibility of tokens. However, it is something that may still make some things nicer: E.g., a double-submitted approve does not create two blocks, but only one.

> * **icrc7_revoke_token_approvals**
>  * mention that only owner can revoke approvals
>  * mention what happens when token does not exist
>  * why is spender `opt`?

Mentioned, good point.

The `opt` is intended to revoke approvals for the respective token for all spenders (and subaccounts) in case left empty.

In that case, we can ask the question whether we can remove the `icrc7_revoke_all_token_approvals` method probably as it is covered by this one. It adds the removal of all approvals for all tokens, however, which this cannot do. Removed it is the value is diminished.

> * **icrc7_revoke_collection_approvals**
>  * why does this return a vector? should be analaogue to `approve_collection`, so either add it there as well or remove for both
>  * should be called `icrc7_revoke_collection_approval` instead of `approvals`
>  * candid types are missing

The method can revoke multiple approvals in case the opt parameters are not provided. Thus, the name is fine. The signature has been fixed, but is still a vector: Each revoked approval is reflected as one response in the vector. Does that make sense to you?

> * **icrc7_revoke_all_collection_approvals**
>  * this should either contain more information in the return type, so that it is clear to which collection wide approval the response belongs (e.g. via `from_subaccount` and `spender`) or fail/succeed atomically and only return one result instead of a vector

Both `revoke_all` methods have been removed as they are handled with the `opt` parameters in the other `revoke` methods.

> * **icrc7_is_approved**
>  * typo in `ac`

Fixed.

**Overall, the main open points now are the following:**
* Error handling for query calls needs to be made consistent
  * Error variant with an error type per query or a generic error type for all queries could make sense if people think this adds value. It complicates the API, though, compared to the current one.
* How to handle non-existing tokens consistently
  * Error
  * Null fro response
* `TemporarilyUnavailable`: Do we need this or can we remove it from the standard?
* Using `icrc1` namespace for existing metadata fields defined in ICRC-1?

-------------------------

sea-snake | 2023-10-18 14:06:08 UTC | #46

[quote="dieter.sommer, post:45, topic:16566"]
We should align the behaviour for all relevant interfaces. We had errors contained in the queries using a variant, but then removed them as the API was rather convoluted. That’s an important point to address.
[/quote]

I personally like to keep errors out of queries, data is either there or it isn't. Compared to calls, we're not mutating any state where things can go wrong.

-------------------------

sea-snake | 2023-10-18 14:12:38 UTC | #47

[quote="dieter.sommer, post:45, topic:16566"]
Deduplication: Very good question. Reading your thoughts and rethinking this, I think we might not strictly need it because of the non-fungibility of tokens. However, it is something that may still make some things nicer: E.g., a double-submitted approve does not create two blocks, but only one.
[/quote]

In theory it's not needed since a token can only be sent once but in the weird edge case you (user A) sent a token to user B and you buy it back a few seconds later (in)directly from user B. Then re-submitting the transfer would incorrectly send the token to user B. I doubt this happens in real life applications with end users but it could happen with some web 2 services that frequently move around tokens in some automated process.

-------------------------

sea-snake | 2023-10-18 14:35:43 UTC | #48

[quote="dieter.sommer, post:45, topic:16566"]
`TemporarilyUnavailable`: Do we need this or can we remove it from the standard?
[/quote]

As far as I remember correctly this was also there for two usages besides the account migration:
- ability to rate limit calls per accounts/tokens/something
- if ICRC-8 intend to built upon ICRC-7, this would be for example used to indicate token cannot be transferred

How does ICRC-1 handle account migration in e.g. the ICP ledger?

Adding `TemporarilyUnavailable` just to support migrations seems a bit over complex for clients, now they also need to handle this data response while the information of this response type doesn't have any valuable data to handle this edge case.

Maybe it makes more sense to define fallback behavior for each method e.g. icrc7_owner_of could return an account with owner = canister principal and subaccount = icp account hash. In theory the canister could even handle incoming tokens for these accounts and assign them to the correct user, basically supporting the old icp account hash without the need to keep two lists of owners formats in memory.

-------------------------

dieter.sommer | 2023-10-18 16:35:31 UTC | #49

[quote="sea-snake, post:46, topic:16566"]
I personally like to keep errors out of queries, data is either there or it isn’t. Compared to calls, we’re not mutating any state where things can go wrong.
[/quote]

That was the reason that most queries currently don't have an error variant. I find the API with this much simpler than with an error variant as in the case of update calls.

[quote="sea-snake, post:47, topic:16566"]
In theory it’s not needed since a token can only be sent once but in the weird edge case you (user A) sent a token to user B and you buy it back a few seconds later (in)directly from user B. Then re-submitting the transfer would incorrectly send the token to user B. I doubt this happens in real life applications with end users but it could happen with some web 2 services that frequently move around tokens in some automated process.
[/quote]

Agreed, the case you sketch here is an edge case. Accidental resubmission in mobile apps due to connectivity issues, the main reason why we need deduping for fungible tokens, will likely not be an issue in NFT ledgers. Even if ownership is transferred forth and back, this is an edge case. I don't have a strong opinion on whether we should keep or not keep deduplication.

-------------------------

dieter.sommer | 2023-10-23 14:28:14 UTC | #50

Dear Working Group!

We did another thorough iteration over the draft.

[ICRC-7 most recent draft](https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md)
[Diff of version of 20231023 to version of 20231016](https://github.com/dfinity/ICRC/compare/1a7d2c9..7fd2110)

@skilesare, @sea-snake, @cryptoschindler, Matthew, all, please have another thorough look over the draft.

**Aspects addressed:**

* Items discussed in the recent WG meeting of Oct 10
* Comments by @cryptoschindler and @sea-snake and related follow-up discussions
* Overall polishing and making the text more consistent
* Wording, clarity

-------------------------

dieter.sommer | 2023-10-23 14:30:10 UTC | #51

**WG meeting tomorrow, Oct 24**

Dear Working Group!

For the meeting tomorrow the goal is to have a really final iteration over the standard draft and then get it into voting.

See my post above about the recent draft and a diff with the version of Oct 16.

-------------------------

cryptoschindler | 2023-10-25 00:03:33 UTC | #52

some questions i had:
- ~~why do we distinguish between `max batch size` for update and query calls, but not for the `default` and `max take values`?~~ -> **only exists for queries**
- ~~why is `icrc7_max_take_value` only specified for `paginated query methods`?~~ -> **only exists for queries, will be rephrased**
- ~~can we turn `icrc7_collection_metadata : () -> (metadata : vec record { key: text; value: Value } ) query` into `icrc7_collection_metadata : () -> (metadata: vec record {text;Value } ) query`~~ -> **done**
- can we rename `GetOwnerError` to `OwnerOfError` -> **unclear**
- ~~should we add an error for when the implementation specific `max batch size` is exceeded by the caller or should we trap? if we add an error, we have to restructure current return types and wrap them in result type ->~~ **add paragraph that implementation should trap if limits are exceeded**
  - see `icrc7_owner_of` for example, imagine max batch size is 30 but we submit 50 tokens. what is expected to happen? 
  - we should specify expected behaviour for all batch methods imo
  - same for `max take`
  - same for `max approvals`
- should we explictily document error variants and their meaning?

**icrc7_approve_tokens**
- explain semantic of `expires_at`
- i think we need a section explaining the reasoning behind having to specify `from_subaccount` when in theory it can be inferred from the `token_id`. something along what @benji said in todays call that you have to think in the granularity of `Account`s, not `Principals` (?) otherwise it feels unnecessary to explicitly specify it in some places
- why is `token_id` in the response optional?
- add `NonExistingTokenId` error
- semantics of `memo`
- semantic of not specifying `from_subaccount`
**icrc7_approve_collection**
- remove this, there is no notion of `token`
  >For the same token, spender, and subaccount triple a new approval shall always overwrite the old one.
- we shouldn't reuse `ApprovalError` here if we add `NonExistingTokenId` to it, as this variant doesn't make sense in the context of this method

**icrc7_transfer**
- why do we have to specify `from`,  shouldn't the ledger be able to infer this from `token_ids`
- remove `type` from `TransferArgs`
- add `NonExistingTokenId` error instead of using `Unauthorized`
- for `approval` we say `approval_response`, for `transfer` we say `transfer_result`, for `owner_of` we say `account`. we should be consistent with our naming in general 

**icrc7_revoke_token_approvals**
- `from_subaccount` in the response seems unnecessary (with new semantic discussed today)

**icrc7_revoke_collection_approvals**
- `from_subaccount` in the response seems unnecessary (with new semantic discussed today)

**icrc7_is_approved**
- `from_subaccount` should be optional

-------------------------

dieter.sommer | 2023-10-25 17:42:18 UTC | #53


Thanks for the thorough review and catching some more things!

Here is a first response, most things could be resolved. Some remain open as listed further below.

> can we rename GetOwnerError to OwnerOfError → unclear

* Done, no reason why not to rename as it is now more consistent.
* For making errors more consistent as discussed in the call: Maybe we should split `ApprovalError` to `ApproveTokensError` and `ApproveCollectionError`, which is more consistent and would capture both approve methods. Also see your comment further below which gets addressed with that.

> add paragraph that implementation should trap if limits are exceeded
> * see icrc7_owner_of for example, imagine max batch size is 30 but we submit 50 tokens. what is expected to happen?
> * we should specify expected behaviour for all batch methods imo
> * same for max take
> * same for max approvals

* Added.
* Other points should be addressed with some text added. Is that concrete enough in your view?

> should we explicitly document error variants and their meaning?

* Yes, I raised that question also some time back but no one has done it so far.
* Now done (should have addressed all of them by now, but need to double check).
* All error types should have overlapping fields now in same order.

> icrc7_approve_tokens
> * explain semantic of expires_at
> * i think we need a section explaining the reasoning behind having to specify from_subaccount when in theory it can be inferred from the token_id. something along what @benji said in todays call that you have to think in the granularity of Accounts, not Principals (?) otherwise it feels unnecessary to explicitly specify it in some places
> * why is token_id in the response optional?
> * add NonExistingTokenId error
> * semantics of memo
> * semantic of not specifying from_subaccount

All of the above should have been addressed now. We might still want to iterate over the motivation on why the `from_subaccount` is always needed.

> icrc7_approve_collection
> * remove this, there is no notion of token
>> For the same token, spender, and subaccount triple a new approval shall always overwrite the old one.
> * we shouldn’t reuse ApprovalError here if we add NonExistingTokenId to it, as this variant doesn’t make sense in the context of this method

Addressed everything.

One thing to note is that the semantics of approve tokens / approve collection differs also in that for an approve tokens, each token id can have an approval per spender, but only on the from_subaccount the token is on. The approve collection, however is different in that a caller can approve the collection for each pair of `(spender, from_subaccount)` if we define the semantics in a generic way. Open for discussion.

> icrc7_transfer
> * why do we have to specify from, shouldn’t the ledger be able to infer this from token_ids
> * remove type from TransferArgs
> * add NonExistingTokenId error instead of using Unauthorized
> * for approval we say approval_response, for transfer we say transfer_result, for owner_of we say account. we should be consistent with our naming in general

The `from` parameter makes the intent explicit, which is required. Think of a token being approved to multiple spenders, then one of them transfers it. Then the token looses its approval, but a transfer attempt by another previously authorized spender would try to transfer it from the wrong party. It would result in an `Unauthorized` in either case, but in the case without the explicit `from` a completely unintended transfer is attempted. Does that make sense?

`type` removed, good catch

Error variants updated, `Unauthorized` is still required as well.

> icrc7_revoke_token_approvals
> * from_subaccount in the response seems unnecessary (with new semantic discussed today)

Yes, removed it to reflect the new semantics.

> icrc7_revoke_collection_approvals
> * from_subaccount in the response seems unnecessary (with new semantic discussed today)
icrc7_is_approved

Yes, removed it to reflect the new semantics.

> from_subaccount should be optional

Yes!

Doing another iteration tomorrow and then you could have another one. Slowly we are converging to something nice.

**Open**

Can we agree that token-based approvals can have one per spender, while collection-based ones can have one per (spender, from_subaccount) pair? Also, the latter can be done without holding tokens. This has never been discussed, but may make sense as such approval persists if you add or remove tokens to the collection. Not allowing to make an approval when holding 0 tokens would be odd somehow.

Do we need deduplication? Once a tx has transferred a token, it is gone, so a duplicate would not harm. For approvals likewise, a duplicate creates another entry in the history and overrides the previous one with the same information. This is still open.

Do we need `NotMigrated` in other methods than `icrc7_owner_of`? Considering that approvals and transfers can derive the ICP address from the caller and `from_subaccount` those operations should work fine with not migrated tokens. What did we discuss in the meeting, my notes are unclear on this point.

-------------------------

skilesare | 2023-10-26 22:15:24 UTC | #54

https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md#icrc7_token_metadata

```
icrc7_token_metadata : (token_ids : vec nat)
    -> (vec record { nat; Value }) query;
```

I thought we had agreed that the return should be vec record { nat; opt Value }) so that we could return a null if one of the tokens requested didn't exist?  Otherwise, we'll have to trap if one of the values provided doesn't exist.  Or maybe we decided to trap?  If so we should update the description of that function to direct the expected behavior.

-------------------------

skilesare | 2023-10-26 22:38:52 UTC | #55

I'm messing with trying to do an actual implementation and I'm really regretting not having Bool in here:

```
// Generic value in accordance with ICRC-3
type Value = variant { 
    Blob : blob; 
    Text : text; 
    Nat : nat;
    Int : int;
    Array : vec Value; 
    Map : vec record { text; Value }; 
};
```

Should we say something about the best practice for returning boolean values?  Think of something like isTradeable?

#Text("true");
#Blob(Blob.fromArray([1]));
#Nat(1); //I think VB used to have bool false as -1...confusing

-------------------------

skilesare | 2023-10-26 22:39:45 UTC | #56

cc @mariop Do you remember why didn't we have bool in ICRC3 Value?

-------------------------

skilesare | 2023-10-27 14:23:30 UTC | #57

This line is a bit unclear if this is supposed to be a record with a property of balance or if it just returns a Nat:

```
icrc7_balance_of
Returns the balance of the account provided as an argument, i.e., the number of tokens held by the account. For a non-existing account, the value 0 is returned.

icrc7_balance_of : (account : Account) -> (balance : nat) query;

```

This is pretty consistent through the doc as most of the responses with just one value are put in () with a key name, but not in a record. I assume this is to convey the interpretation of the return and that returning just the type of the value is sufficient, but it is a bit confusing.  Please correct me if I'm wrong.

Over all it may be a good idea to put a canonical did file at the end of the description so people can check.

-------------------------

dieter.sommer | 2023-10-27 15:07:52 UTC | #58

[quote="skilesare, post:54, topic:16566"]
I thought we had agreed that the return should be vec record { nat; opt Value }) so that we could return a null if one of the tokens requested didn’t exist? Otherwise, we’ll have to trap if one of the values provided doesn’t exist. Or maybe we decided to trap? If so we should update the description of that function to direct the expected behavior.
[/quote]

Returning a null is the cleaner option and the draft is changed now.

-------------------------

dieter.sommer | 2023-10-27 15:27:26 UTC | #59

Hi Working Group members!

As discussed in the recent meeting, we wanted to do another iteration over the text. This has been done now and it has improved further.

https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md

@cryptoschindler, @skilesare, @benji, @sea-snake, all

-------------------------

skilesare | 2023-10-27 17:38:23 UTC | #60

Implementation note:

The spender on an Approval is an account and you can specify something with a non-null sub-account. This has no functional effect on other things as outlined in the spec and a spender calling transfer on behalf of another user would be calling from a principal and there is no functional distinction for the idea of a subaccount in the msg.caller. It is just a principal.

That being said, it is likely good to keep it an Account type as some future implementation may want to reward a spender and this sub-account would allow that ledger to send rewards to a specific sub-account.  This may be a confusing explanation, but it may be worth adding the intention and clarifying for an implementer trying to figure out how to revoke on the subaccount of the caller.

-------------------------

skilesare | 2023-10-27 18:07:31 UTC | #61

We don't explicitly say what the Ok return on approvals is. (I assume it is the index of the ledger entry created, but we should state it explicitly). Some ledgers use something like CAP for their leadger(which I think is a bad idea) and I'm not sure if they have Nat IDs or not.

We didn't explicitly say that we assume an icrc7 canister is keeping a ledger, but maybe we should as this response seems to assume that it is present.

```
icrc7_approve_collection : (ApprovalInfo)
    -> (approval_result : variant { Ok : nat; Err : ApproveCollectionError });

```

-------------------------

Apollon | 2023-10-30 09:13:13 UTC | #62

@skilesare glad to see your inputs in the thread. Could you tell us when we can expect this to go live? Or has it already? We don't follow DFINITY on Twitter since it is full of noise.


Appreciate any response and progress update.

-------------------------

skilesare | 2023-11-02 17:15:20 UTC | #63

In regards to deduplication....did we figure out a reason that we need it?  The nature of a non-fungible ledger seems to imply that dups are ineffective.

If I've transferred token 8 and try to a second time it will fail.

I can actually see it maybe being necessary in a flash defi sense on approvals:

**I approve an entire collection,**
**A sale is made,**
**I revoke the collection approval**
**Collection approval is replayed.**

I guess this could be done for tokes as well:

**I transfer a token**
**I buy it back**
**Transaction is replayed.**

I guess I'm talking myself into it, but we may need add to the spec that it needs to be done for approvals as well as transfers.

-------------------------

skilesare | 2023-11-05 20:19:40 UTC | #64

I'm correcting my own understanding on this one as there is a spender subaccount in the transfer args that must match.

-------------------------

skilesare | 2023-11-05 20:23:06 UTC | #65

We didn't really document what a canister should do on transfer if a "top level" error occurs.

If there are more than the acceptable number of items in a batch or if to == from...should we trap? If we want to return an error then we probably don't want to return an item in the vec for each item, especially in the to-large-batch scenario.

If the to == the from, as well,  you only need to return one item...maybe it is best to mention one should trap in these instances.

-------------------------

skilesare | 2023-11-06 17:04:14 UTC | #66

Just making a note for us to discuss if we need to de-duplicate the revoke args.  Could a malicious node replay to disrupt service?

-------------------------

skilesare | 2023-11-06 19:37:35 UTC | #67

Revoke approvals is kind of a mess:

```
icrc7_revoke_token_approvals: (RevokeTokensArgs)
    -> (vec record { token_id : nat; spender : Account; revoke_result : variant { Ok : nat; Err : RevokeTokensError } });

```

Since spender isn't null(I want to revoke all spenders) and there are errors that can exist that keep you from being able to identify a spender(Token Doesn't exist, Unauthorized), there isn't really a way to report that it applied to a spender.  I'd propose that the spender be changed to null in the response so that we can report a null spender. 

In addition, and similarly,  is it the expected behavior that we'll have multiple records reported back for a request to revoke all for a token ID?

example:

```

icrc7_revoke_token_approval({
     token_ids = [1,2]; 
     from_subaccount = null; 
     spender = null})

result: [
     {token_id = 1;
      spender = {owner= principal "a"; subaccount = null};
      revoke_result = #Ok(6);
     },
 {token_id = 1;
      spender = {owner= principal "b"; subaccount = null};
      revoke_result = #Ok(7);
     },
 {token_id = 2;
      spender = {owner= principal "a"; subaccount = null};
      revoke_result = #Ok(8);
     },
   {token_id = 2;
      spender = {owner= principal "b"; subaccount = null};
      revoke_result = #Ok(9);
     },
 {token_id = 2;
      spender = {owner= principal "c"; subaccount = null};
      revoke_result = #Ok(10);
     },
```

Of note here is that each spender identified gets a revoked record in the transaction log.  This is so the state could be theoretically reproduced from the ledger of the NFT.  This could easily bomb a ledger and cause it to grow quickly.

-------------------------

skilesare | 2023-11-06 20:50:26 UTC | #68

```
type TokenApproval = record {
    token_id : nat;
    approvalInfo : ApprovalInfo;
};
```

Should approvalInfo be a different case for consistency?

-------------------------

dieter.sommer | 2023-11-07 12:39:29 UTC | #69

@skilesare
If you mean using `approval_info`, yes, we should use that for consistency.
Fixed it just now.
Nice catch!

-------------------------

dieter.sommer | 2023-11-07 13:57:25 UTC | #70

Another issue that was pointed out by someone in the community is the following: The standard defines the method `icrc7_logo` to obtain the logo of the ledger. The concern pointed out is that the logo, if improperly used / displayed in a Web app, can allow for XSS attacks. Particularly SVG graphics are concerned as they, if improperly embedded, i.e., not within an image tag, allow for XSS. Would people agree to add a warning about this?

Proposed text to add:
“Security note: We strongly advise developers who display the logo of a token in a Web application to follow Web application security best practices to avoid attacks such as XSS and CSRF resulting from malicious image content provided by a ledger. As one particular example, images in the SVG format provide potential for attacks if used improperly.”

-------------------------

dieter.sommer | 2023-11-07 12:36:47 UTC | #71

In the call later today we would like to finalize ICRC-7 and discuss the remaining issues you have discovered, if any.

Once we agree to move forward, voting for the standard can be opened.

-------------------------

dieter.sommer | 2023-11-07 12:49:38 UTC | #72

[quote="skilesare, post:61, topic:16566"]
We don’t explicitly say what the Ok return on approvals is. (I assume it is the index of the ledger entry created, but we should state it explicitly). Some ledgers use something like CAP for their leadger(which I think is a bad idea) and I’m not sure if they have Nat IDs or not.

We didn’t explicitly say that we assume an icrc7 canister is keeping a ledger, but maybe we should as this response seems to assume that it is present.

```
icrc7_approve_collection : (ApprovalInfo)
    -> (approval_result : variant { Ok : nat; Err : ApproveCollectionError });
```
[/quote]

Actually, we do. There is a general paragraph further above that specifies that for all calls that create history, they return the transaction index in the success case.

> Methods that modify the state of the ledger have responses that comprise transaction indices as part of the response in the success case. Such a transaction index is an index into the chain of blocks containing the transaction history of this ledger. Access to the transaction history is not part of the ICRC-7 standard, but will be published as a separate standard, similar to how ICRC-3 specifies access to ICRC-1 and ICRC-2 historic blocks.

As you missed it, it might not be prominent enough and maybe should be added explicitly with the calls to which it applies.

-------------------------

dieter.sommer | 2023-11-07 12:55:44 UTC | #73

[quote="skilesare, post:63, topic:16566"]
In regards to deduplication…did we figure out a reason that we need it? The nature of a non-fungible ledger seems to imply that dups are ineffective.
[/quote]

You are of course right with your observation that the deduping is not required for rendering duplicate tx submissions ineffective. However, the other important aspect of deduping is to allow a mobile app that lost connection for a short duration to resubmit the tx and obtain the response, i.e., the transaction index for the created history block.

Interesting point you raise w.r.t. deduping for approvals, let's discuss in the meeting later.

-------------------------

dieter.sommer | 2023-11-07 13:59:49 UTC | #74

[quote="skilesare, post:65, topic:16566, full:true"]
We didn’t really document what a canister should do on transfer if a “top level” error occurs.

If there are more than the acceptable number of items in a batch or if to == from…should we trap? If we want to return an error then we probably don’t want to return an item in the vec for each item, especially in the to-large-batch scenario.

If the to == the from, as well, you only need to return one item…maybe it is best to mention one should trap in these instances.
[/quote]

The generic spec is again in the "Conventions" section in the beginning. But you are right, we might want to make this explicit with the methods and also make explicit the cases you mention above. The generic text is a catch-all that has this information implicit.

> All update methods have error variants defined for their responses that cover the error cases for the respective call. For query methods, error variants are only defined for methods for which specific errors need to be handled. Other query calls do not have error variants defined for their responses to keep the API simple. Both query and update calls can trap in specific error circumstances instead of returning an error.

-------------------------

dieter.sommer | 2023-11-07 13:37:11 UTC | #75

[quote="skilesare, post:67, topic:16566, full:false"]
Revoke approvals is kind of a mess:

```
icrc7_revoke_token_approvals: (RevokeTokensArgs)
    -> (vec record { token_id : nat; spender : Account; revoke_result : variant { Ok : nat; Err : RevokeTokensError } });

```

Since spender isn’t null(I want to revoke all spenders) and there are errors that can exist that keep you from being able to identify a spender(Token Doesn’t exist, Unauthorized), there isn’t really a way to report that it applied to a spender. I’d propose that the spender be changed to null in the response so that we can report a null spender.
[/quote]

Subtle and excellent point you make here. Would making `spender` in the response and adding the according text be enough to address this?

[quote="skilesare, post:67, topic:16566, full:false"]
In addition, and similarly, is it the expected behavior that we’ll have multiple records reported back for a request to revoke all for a token ID?

example:

```
icrc7_revoke_token_approval({
     token_ids = [1,2]; 
     from_subaccount = null; 
     spender = null})

result: [
     {token_id = 1;
      spender = {owner= principal "a"; subaccount = null};
      revoke_result = #Ok(6);
     },
 {token_id = 1;
      spender = {owner= principal "b"; subaccount = null};
      revoke_result = #Ok(7);
     },
 {token_id = 2;
      spender = {owner= principal "a"; subaccount = null};
      revoke_result = #Ok(8);
     },
   {token_id = 2;
      spender = {owner= principal "b"; subaccount = null};
      revoke_result = #Ok(9);
     },
 {token_id = 2;
      spender = {owner= principal "c"; subaccount = null};
      revoke_result = #Ok(10);
     },
```

Of note here is that each spender identified gets a revoked record in the transaction log. This is so the state could be theoretically reproduced from the ledger of the NFT. This could easily bomb a ledger and cause it to grow quickly.
[/quote]

What would be a viable alternative to keeping all approvals and approval revocations in the transaction log? If only approvals, but not their revocations, were stored in the log, or neither of them, then the ledger would not be auditable. This would not be acceptable from a security perspective.
Note that an implementation could batch multiple revocations into a single block, reducing storage overhead a bit. This is supported by the API here as the responses of multiple revocations could contain the same transaction index.

Rate limiting could solve the DoS issue you sketch:
* A canister should, according to the standard, limit the number of approvals per token and collection-level approvals per principal.
* If an implementation adds further rate limiting to how often approvals may be created / revoked for a token or an identity, the issue would be better addressed. An attacker with many principals could, of course, still create and revoke many collection-level approvals. Maybe an implementation can limit such operations to entities that own one or more NFTs of this collection.

Would the above solve the denial of service issue sufficiently?

-------------------------

skilesare | 2023-11-07 15:08:42 UTC | #76

[quote="dieter.sommer, post:75, topic:16566"]
If only approvals, but not their revocations, were stored in the log, or neither of them, then the ledger would not be auditable
[/quote]

I think it all needs to be in the ledger to 'recreate the state' via the ledger.  The one caveat to this is that once we get to uploading files, we probably don't want those in the ledger, but can instead use a hash of the file or data change(this leads to a data availability problem, but is likely less of an issue on the IC since we can store the files "forever").

As you mentioned, we can have the record be a batch record to save on some space, but it can still get big.  I like having individual records so I can easily build an index with all the records I need to retrieve when we add an icrcX_token_history endpoint.  We may want to leave this up to an implementation detail and state as much.  It becomes less of an implementation detail when we do the ICRCX discussion that defines the transaction log entries for NFTs in the same way that ICRC3 does for the ICRC1/2 transactions.  It may be fine to say we'll define it in the future.

While its in my head, when we do get tho that we may want a btapprove and xbtapprvoe, and an approve and xapprove op types that give intent as to if the record is batch or not.  A ledger could elect to never use batch if it wants to(or maybe never use the singular as the bt would have an array as one of the items and that array could have one item in it.

-------------------------

sea-snake | 2023-11-07 15:16:17 UTC | #77

I think file e.g. file hashes could be stored in token metadata. Updating existing token metadata is outside of the standard scope at the moment. If a extension standard does offer this, then these token metadata mutations could be part of the log as defined in that standard. Minting tokens and their metadata is not even in scope to begin with 😅

But considering that NFTs could be more than pictures/videos/other media but also e.g. domain names, I think concepts like files and metadata structure should stay out of scope of this base standard.

-------------------------

skilesare | 2023-11-07 15:17:04 UTC | #78

Yep...not trying to drag it in now...just recording for posterity as we'll eventually have to deal with it.  I've actually have been keeping some notes for a content ICRC that would be comparable.  I'll try to write it up when I get a chance.

-------------------------

cryptoschindler | 2023-11-07 17:48:22 UTC | #79

Here is a Motoko implementation of the "old" standard
https://github.com/noku-team/icrc7_motoko

-------------------------

kayicp | 2023-11-07 18:57:19 UTC | #80

hi i found an inconsistencies here
https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md#icrc7_approve_tokens

the function name differs
![image|690x112](upload://9Bu1dBg1gYfaetC5mC80RbwZOm2.png)
vs.
![image|632x91](upload://qua65UfL0Z4Q6WuFJsjSZABZtDc.png)

which name should we use? i prefer with the word `_tokens` since it's clearer and we have `_collection` too.

-------------------------

cryptoschindler | 2023-11-08 02:39:47 UTC | #81

The implementation is based on an earlier draft on the standard, hence the deviation. The working group will vote on the standard soon, then we will have some reference implementations to see if some minor things need to be changed and then we plan to submit the standard to the NNS for voting.

-------------------------

dieter.sommer | 2023-11-08 15:29:32 UTC | #82

Most of the comments resulting from the discussions of the WG meeting yesterday have been incorporated into the text. There are a few notes with a FIX label that still need to be addressed by the group. One of them is the best practices on encoding of types not part of the `Value` type in elements of this type.

This draft is very close to the final version with only minor changes expected.

[Most recent draft](https://github.com/dfinity/ICRC/blob/icrc7-wg-draft/ICRCs/ICRC-7/ICRC-7.md)

[Diff between draft discussed at recent meeting (30fdde7) and draft of 20231108 (6b2fddc)](https://github.com/dfinity/ICRC/compare/30fdde7..6b2fddc)

Please have a look at the changes and comment here in the forum or on GitHub!

-------------------------

dieter.sommer | 2023-11-08 15:31:21 UTC | #83

Hi @kayicp!

The current draft is expected to be very close to the final version of the standard. See my [comment above](https://forum.dfinity.org/t/call-for-participation-nft-token-standard-working-group-status-updated/16566/82) for the diff to the version discussed in the recent meeting. We don't expect any more material changes to how things work.

-------------------------

kayicp | 2023-11-08 15:35:12 UTC | #84

Hi Mr. Sommer, I appreciate this. In fact, I'm implementing it now. One more question tho, I know this shouldnt be asked, but pls humor me. We should implement our own mint and burn function, yes?

-------------------------

dieter.sommer | 2023-11-08 15:43:25 UTC | #85

[quote="kayicp, post:84, topic:16566"]
We should implement our own mint and burn function, yes?
[/quote]

Good and valid question! Yes, indeed, please implement those as you see fit! Mint and burn are not part of the standard to not constrain it unnecessarily.

B.t.w., it would be great to hear back from you if you run into hard- or / awkward-to-implement parts of the standard.

P.S.: Great to see that you are implementing this standard! :slight_smile:

-------------------------

dieter.sommer | 2023-11-08 16:02:45 UTC | #86

The discussion on how to model further types like `bool` in metadata has not been resolved yet in the current draft. Here’s a post to trigger a discussion on it.

For reference, here is the `Value` type:
```
type Value = variant { 
    Blob : blob; 
    Text : text; 
    Nat : nat;
    Int : int;
    Array : vec Value; 
    Map : vec record { text; Value }; 
};
```

**Proposed addition**

### Recommendations for Metadata Encoding

There is currently no standard available on how to encode metadata. Metadata attributes are expressed as elements of the `Value` type, which is a recursively-defined data structure which allows for computing hashes in a well-defined way, used for linking the transactions in the transaction log.

However, the `Value` type is a minimal type not covering all basic data types that metadata may need to express. A prominent example for this is the `bool` type. This recommendation expresses how to encode additional types. This encoding does not contain the type information but only the encoded value and thus requires the scheme to be know in order to decode the type.

#### `bool`

A `bool` is encoded as an element of type `Value` by encoding it is the `nat` variant of `Value` with `0` representing `false` and `1` representing `true`.

**\Proposed addition**

**Questions**
* Is this what we have in mind?
* Do we agree that we do not want the type be contained in the encoding? Otherwise something like encoding it as blob might be more appropriate, e.g. putting the following into a blob: `”1:bool”` for a `bool` with value `1`. This would be an encoding that allows to regenerate the schema from the encoding.

-------------------------

dieter.sommer | 2023-11-08 17:59:57 UTC | #87

Let's try to resolve the open here on the forum before the next meeting!

-------------------------

kayicp | 2023-11-09 06:37:30 UTC | #88

![image|690x402](upload://jIq4GrcWimxbLYJQByAWheLmV2l.png)

hi, regarding this... Instead of `prev`, I would like to suggest to use `from`.

Using `prev` means that it will **not** be included in the result (the word **not** is already a negative here),
while `from` can mean that it might be included in the result.

Not only that, we should also pass the optional next `token_id` as `next` variable so the next request can use its `from` parameter.

for example (simplified for brevity)
```
tokens: [(id, metadata)] = [
  (1, larry), 
  (2, jake), 
  (3, arwald), 
  (4, hugh), 
  (5, ruru),
  (6, raj),
  (7, puddi)
]; 

public shared query func icrc7_tokens(from: Nat, take: Nat32) : async { 
  tokens: [Nat], next: ?Nat 
} {
  // implementation skipped
};

-- // let's test
icrc7_tokens(0, 5); 
// result = { tokens = [1, 2, 3, 4, 5]; next = ?6; };

// the `next` (6) can be use now
icrc7_tokens(6, 5);
// result = { tokens = [6, 7]; next = null; };

```

what do you guys think?

also, why is the take have to be `Nat32` as per highlighted?

-------------------------

cryptoschindler | 2023-11-09 10:29:15 UTC | #89

Can't we just add the missing basic types to `Value`?

-------------------------

kayicp | 2023-11-09 16:45:33 UTC | #90

I found something awkward.
The `approval: ApprovalInfo` object is singular but if the caller specified the `created_at_time`, the `TooOld` and `CreatedInFuture` will be placed in every elements in the result array? doesnt look pretty to me that's all

![image|690x352](upload://mPfmmVYgG2cewvlsF1czki9ebjw.png)

I think it will be better if we separate the `approval: ApprovalInfo` errors and the tokens' errors array.
Maybe something like this?
```
public shared func icrc7_approve_tokens(
  token_ids: [Nat],
  approval: ApprovalInfo,
) : async {
  #RequestRejected : { // for if the approval object is invalid
    #TooOld; #CreatedInFuture; #SelfApproval; #BeyondBatchMaxLimit;
  };
  #Result : [{ #Ok; #Unauthorized; #NotExist; }]
} {
  // check caller and approval.spender
  // check created_at_time
  // check max_approvals_per_token
  // throw #RequestRejected error

  // begin forlooping each token and validating
  // populate the result array with errors if any
};
```

... or maybe I didnt correctly understand the approval flow?

-------------------------

dieter.sommer | 2023-11-09 17:36:50 UTC | #91

[quote="kayicp, post:88, topic:16566"]
hi, regarding this… Instead of `prev`, I would like to suggest to use `from`.

Using `prev` means that it will **not** be included in the result (the word **not** is already a negative here),
while `from` can mean that it might be included in the result.

Not only that, we should also pass the optional next `token_id` as `next` variable so the next request can use its `from` parameter.
[/quote]


Hi @kayicp!

The intended semantics of the `prev` parameter is that values larger than it are returned, the `prev` value itself excluded. The reason is that this is the required meaning when enumerating all elements of the ledger.

Using `prev` for your example:
* You make a first call `icrc7_tokens(0, 5); ` and get back `{ tokens = [1, 2, 3, 4, 5]; next = ?6; }`; now you know that `5` is the largest element in this response.
* Next, you make the call `icrc7_tokens(5, 5);`, where the first `5` is exactly the largest response of the previous call. Then you get back `{ tokens = [6, 7]; next = null; }`. The fact that the number of returned values is smaller than the `take` parameter means there are no further values.

The proposed approach just uses the largest value from the previous request as `prev` and the response starts with elements larger than this, but it not included as we already have received it. So the `prev` approach seems to work as intended. It was the simplest approach we could think of. Disclaimer: We have not implemented it yet, so maybe your point is based on working with it.

What is not clear to me: Do you think that there is an issue with the semantics of `prev` or do you think the `from` / `next` approach is just nicer in general or nicer to work with?

[quote="kayicp, post:88, topic:16566"]
also, why is the take have to be `Nat32` as per highlighted?
[/quote]

No strong feeling about it. What do you think would make more sense? `nat64` or `nat`? `nat32` is a little bit constraining, but 4 billion elements is a lot for a single ledger. But I also thought about this same issue some time back, but then did not make a change proposal.

Do you think we should rediscuss this in the group?

-------------------------

dieter.sommer | 2023-11-09 17:35:18 UTC | #92

I also thought that this would be nice, but remembering the discussions on ICRC-3, where this type is defined, the goal was to have this rather minimal. And I think that it is fixed now. My preference would also be to have it in this type.

More generally: `Value` is a low-level type used for the implementation of the tx log, so maybe using something higher-level for the API would have been a good idea.

ICRC-1 uses an even simplified and less general variation of `Value` for its metadata.

Maybe this is something we need to come back to?

-------------------------

kayicp | 2023-11-09 17:37:41 UTC | #93

[quote="dieter.sommer, post:91, topic:16566"]
do you think the `from` / `next` approach is just nicer in general or nicer to work with?
[/quote]

yes to me it will be prettier and consistent with the StableRBTree by CanScale.
https://github.com/canscale/StableRBTree/blob/main/src/StableRBTree.mo#L228

but sure i dont really have a problem with `prev` method :smiley:

-------------------------

dieter.sommer | 2023-11-09 17:39:56 UTC | #94

I see! Consistency is good usually, so we may want to come back to this.

-------------------------

kayicp | 2023-11-09 17:46:44 UTC | #95

[quote="dieter.sommer, post:91, topic:16566"]
`nat32` is a little bit constraining
[/quote]

i see. i was just wondering if there's really a reason behind it. again, if possible, i would just use `nat` because it's just prettier and I wont have to use `Nat32.toNat(take)` to remove the yellow squiggly lines when i compare it with a `nat` in vscode :stuck_out_tongue: . Again, no big deal..

-------------------------

infu | 2023-11-09 17:50:43 UTC | #96

[quote="skilesare, post:17, topic:16566"]
We talked a lot about this on the last call. The main point of contention was around ICRC7 having approvals or not.
[/quote]

I am still wondering what is the use case of approvals in ledgers. Had reached a need for it for a moment, but then forgot what it was. I think we should also provide some info on why these approvals are needed and their use cases in both fungible and nonfungible.

If Dfinity allows me to run all the workgroup videos through AI transcription + summary, that may provide some insights. I've watched only one, but I'm not sure if they are all public.

-------------------------

dieter.sommer | 2023-11-09 17:54:07 UTC | #97

[quote="kayicp, post:90, topic:16566"]
I found something awkward.
The `approval: ApprovalInfo` object is singular but if the caller specified the `created_at_time`, the `TooOld` and `CreatedInFuture` will be placed in every elements in the result array? doesnt look pretty to me that’s all
[/quote]

That would be the same for the transfer function, right?

The problem you point out is essentially that the `TooOld` and `CreatedInFuture` errors are for the whole request and not related to individual tokens. The cleanest way to handle this would be a "top-level" error being returned for the request. This would, however, make the API overall more complex.

One way to handle it would be analogous to what is proposed for [ICRC-4](https://github.com/skilesare/ICRC-1/blob/Icrc4/standards/ICRC-4/readme.md#icrc4_transfer_batch), which is also what you propose.
```
icrc4_transfer_batch: (TransferBatchArgs) -> (variant { Ok : [(TransferArg, variant {Ok: Nat, Err: TransferError})]; Err : TransferBatchError });
```
Here, there is a top-level error and then an error per token. This is conceptually nicer, but also complicates the API. I think the reason to go for this was to have a simpler API. But now that you bring it up when implementing, there may be a point in changing.

The group should definitely have another discussion on this one. It would effect essentially all the update APIs as we would want to be consistent. Also consistency with ICRC-4 might be a good point.

-------------------------

skilesare | 2023-11-09 17:55:36 UTC | #98

[quote="dieter.sommer, post:86, topic:16566"]
However, the `Value` type is a minimal type not covering all basic data types that metadata may need to express. A prominent example for this is the `bool` type. This recommendation expresses how to encode additional types. This encoding does not contain the type information but only the encoded value and thus requires the scheme to be know in order to decode the type.
[/quote]

So my current strategy is to store the metadata as Candy (0.3.0alpha is at https://github.com/icdevs/candy_library/tree/0.3.0-alpha/src). This lets me store a class at the top level which gives me the ability to mark properties as immutable or not(which is pretty important with these blockchain things).

When the candy comes out and must be converted to a Value I'm using this function(if we think nat is better than blob I can easily change it).


source: https://github.com/icdevs/candy_library/blob/22ffae877ac1d7d1082537f3701f028782728f42/src/conversion.mo#L1964
```
///converts a candyshared value to the reduced set of ValueShared used in many places like ICRC3.  Some types not recoverable
  public func CandySharedToValue(x: CandyShared) : ValueShared {
    switch(x){
      case(#Text(x)) #Text(x);
      case(#Map(x)) {
        let buf = Buffer.Buffer<(Text, ValueShared)>(1);
        for(thisItem in x.vals()){
          buf.add((thisItem.0, CandySharedToValue(thisItem.1)));
        };
        #Map(Buffer.toArray(buf));
      };
      case(#Class(x)) {
        let buf = Buffer.Buffer<(Text, ValueShared)>(1);
        for(thisItem in x.vals()){
          buf.add((thisItem.name, CandySharedToValue(thisItem.value)));
        };
        #Map(Buffer.toArray(buf));
      };
      case(#Int(x)) #Int(x);
      case(#Int8(x)) #Int(Int8.toInt(x));
      case(#Int16(x)) #Int(Int16.toInt(x));
      case(#Int32(x)) #Int(Int32.toInt(x));
      case(#Int64(x)) #Int(Int64.toInt(x));
      case(#Ints(x)){
         #Array(Array.map<Int,ValueShared>(x, func(x: Int) : ValueShared { #Int(x)}));
      };
      case(#Nat(x)) #Nat(x);
      case(#Nat8(x)) #Nat(Nat8.toNat(x));
      case(#Nat16(x)) #Nat(Nat16.toNat(x));
      case(#Nat32(x)) #Nat(Nat32.toNat(x));
      case(#Nat64(x)) #Nat(Nat64.toNat(x));
      case(#Nats(x)){
         #Array(Array.map<Nat,ValueShared>(x, func(x: Nat) : ValueShared { #Nat(x)}));
      };
      case(#Bytes(x)){
         #Blob(Blob.fromArray(x));
      };
      case(#Array(x)) {
        #Array(Array.map<CandyShared, ValueShared>(x, CandySharedToValue));
      };
      case(#Blob(x)) #Blob(x);
      case(#Bool(x)) #Blob(Blob.fromArray([if(x==true){1 : Nat8} else {0: Nat8}]));
      case(#Float(x)){#Text(Float.format(#exact, x))};
      case(#Floats(x)){
        #Array(Array.map<Float,ValueShared>(x, func(x: Float) : ValueShared { CandySharedToValue(#Float(x))}));
      };
      case(#Option(x)){ //empty array is null
        switch(x){
          case(null) #Array([]);
          case(?x) #Array([CandySharedToValue(x)]);
        };
      };
      case(#Principal(x)){
        #Blob(Principal.toBlob(x));
      };
      case(#Set(x)) {
        #Array(Array.map<CandyShared,ValueShared>(x, func(x: CandyShared) : ValueShared { CandySharedToValue(x)}));
      };
      case(#ValueMap(x)) {
        #Array(Array.map<(CandyShared,CandyShared),ValueShared>(x, func(x: (CandyShared,CandyShared)) : ValueShared { #Array([CandySharedToValue(x.0), CandySharedToValue(x.1)])}));
      };
      //case(_){assert(false);/*unreachable*/#Nat(0);};
    };
```

Options are a bit squirly and there are a couple of items that you can't really go backwards on.

I believe the value type gets its genesis from this: https://internetcomputer.org/docs/current/references/ic-interface-spec#hash-of-map

-------------------------

skilesare | 2023-11-09 18:01:08 UTC | #99

[quote="infu, post:96, topic:16566"]
I am still wondering what is the use case of approvals in ledgers.
[/quote]

For fungies they make the deposit flow a lot cleaner...I don't actually take your tokens until I provide the service I have promised.

For NFTs they exist to allow a user to give a marketplace the right to transfer the NFT for them upon a sale. It keeps the user from having to transfer ownership to the marketplace, and the way we've implemented it allows the user to authorize multiple marketplaces.

Of course, I prefer putting the marketplace in the NFT like we've done with Origyn, but I get the thinking of why we put it in.

-------------------------

infu | 2023-11-09 19:09:57 UTC | #100

These are legit use cases, but they can also be achieved with external contracts. Having it inside the ledger probably speeds things up, but having it outside can provide other security guarantees, modularity, and reusability. Thanks for explaining

Edit: Imo, If someone provides a ready-install audited WASM like the icrc1 ledger by Dfinity, all will be good and devs won't need to worry about making complex ledgers to get to building apps.

-------------------------

dieter.sommer | 2023-11-15 08:43:18 UTC | #101

Just wondering whether we would want a method `icrc7_update_metadata` to update metadata of an NFT. This would allow for dynamic NFT use cases, which would set the IC apart from other chains. When not having it here, we would need another standard to handle this.

-------------------------


lara | 2022-02-10 22:37:39 UTC | #1

Hi all!

I am back with a new design proposal for the next stage of the service nervous systems (SNSs). Let's use this thread to discuss how SNSs should be deployed and upgraded. This is our proposal:


## Objective

Similarly to how the [Network Nervous System (NNS)](https://medium.com/dfinity/the-network-nervous-system-governing-the-internet-computer-1d176605d66a) is the open tokenized governance system that controls the Internet Computer blockchain (IC), service nervous systems (SNSs) are algorithmic DAOs that will allow developers to create decentralized, token-based governance systems for their dapps.

Decentralized control and tokenization enables the introduction of new incentive systems and use cases that have the potential to set dapps apart from traditional applications. We refer to [this article](https://medium.com/dfinity/how-dapp-developers-placing-their-faith-in-total-decentralization-will-inherit-the-world-79419a3e36c9) for more background on how SNSs will empower dapps to leverage the full potential of the IC.

The goal of this discussion is to introduce a concrete first design for how SNSs can be deployed and upgraded.

## Background & context with other projects

We presented the first [proposed SNS design](https://www.youtube.com/watch?v=L4443aaAP5A&list=PLuhDt1vhGcrez-f3I0_hvbwGZHZzkZ7Ng&index=22) in October 2021. The community’s feedback was that they wish for a less complex SNS design that also leaves more freedom for developers and SNS communities to configure a DAO to their needs. Moreover, some developers mentioned that they have a particular DAO or use case in mind and are only interested in a ledger or governance canister implementation, which they plan to integrate with existing canisters / dapps.

The goal of SNSs is also to eventually provide an open governance solution “on the press of a button”, where even users that are not experienced developers can get an SNS as a *system functionality* that is automatically upgraded and maintained as part of the IC.

Motivated by this, we proposed to release smaller SNS features in stages, such that the different parts or canisters can be used by the community early. This new overall approach has been adopted in a [motion proposal](https://dashboard.internetcomputer.org/proposal/35642) in December 2021.

So far, the following stages have already started:

1. Improve the NNS ledger canister so that it can be used for any tokens, e.g., in SNSs. This is scheduled for the Titanium release on the [roadmap](https://dfinity.org/roadmap/).
2. Implement a governance canister. The proposed design for the governance canister has been presented and discussed in [this forum thread](https://forum.dfinity.org/t/open-governance-canister-for-sns-design-proposal/10224/11) and been approved by the community in [this motion proposal](https://dashboard.internetcomputer.org/proposal/42626). In addition, this stage will also deliver a root canister that is needed for governance upgrades. This implementation has started and is ongoing.

The design presented here is the next proposed stage:

3. **Tooling and support for the deployment and upgrade of SNSs**. At a high level, in this design, a SNS consists of a ledger canister, a governance canisters, and a root canister that are mostly from the previous two stages but may require small changes. In addition, this stage entails changes to the NNS canisters and a new canister that helps with deploying SNSs.

Other SNS features that we envision going forward are frontend support, support for initial token distribution, integration with the community fund, etc.

## Proposed design for deploying and upgrading SNSs

#### The SNS Canisters

We propose that in this initial design an SNS consists of three canisters:

1. the *governance canister* which enables decentralized decision making,
2. the *ledger canister* which determines for a SNS-specific governance token the balances and transactions, and
3. the *root canister* which is responsible for upgrading the other SNS canisters and the dapp that the SNS controls.

#### Canister code and blessed deployments

One of the key features of the IC is that it can continuously be upgraded by proposals through the NNS. The same is true for the NNS canisters themselves, which have been upgraded many times since genesis. Similarly, we propose to start with one version of each of the SNS canisters, which can then be continuously evolved.

As with the NNS, the code of all SNS canisters will be public. That is, anyone can deploy any version of the canisters at any point in time. However, it may be that not all canister versions can be upgraded to all other canister versions without breaking some functionality, e.g., due to incompatibility during state migration. For example, it is possible that the governance canister can be upgraded from version v1 to version v2 and from version v2 to version v3, but that it cannot be upgraded from version v1 to version v3 directly. Moreover, it is possible that newer versions of one canister may not be compatible with some older versions of a different canister, e.g., a new ledger version is not compatible with an old version of the governance canister.

Therefore, we propose to have blessed SNS deployments in the NNS registry. These new entries in the NNS registry then define

1. which versions of the SNS canisters are compatible and
2. from which deployment one can safely upgrade to which next deployment.

The IC community would thoroughly test these facts for some releases and “bless” this information in the registry by proposal. SNSs can then just follow the suggested path of upgrades and know that all the relevant upgrades along the way have been well-tested.

#### Two paths to deploy & upgrade a SNS

With the suggested design, there are at least two possibilities for how to deploy and continuously upgrade a SNS:

1. **A SNS that is a system functionality, which is automatically maintained by the IC and where the SNS canisters are hosted on a new SNS subnet.** To deploy an SNS, a user sends a command to the IC that defines the initial settings of the SNS. Afterwards, the IC will ensure that the SNS is kept on the latest available version. This has the advantage that the SNS community does not need to take any actions to keep the SNS canisters up to date (e.g., when bugs are fixed) nor do they need to understand the details of the canisters’ implementation. Especially, the SNS canisters are automatically upgraded following the blessed deployment path. To achieve better security guarantees through higher replications, the new SNS subnet will have more nodes than application subnets currently do.
2. **A SNS that is self-deployed, manually upgraded, and hosted on an application subnet.** Any SNS community can choose to deploy the SNS code, which is open source, on an application subnet. They can then choose to follow the blessed upgrade path or deviate from this path, e.g., leaving out some versions, or even modify the canisters’ code in a completely different way. In this option, canister upgrades require active actions of the SNS community (i.e., the submission of a proposal) and the SNS community has to ensure that the upgrades are secure. This includes ensuring that alternative canister versions are compatible and that upgrades to newer versions do not break any functionality. Application subnets currently have less nodes than the SNS subnet and are therefore less secure.

These two possibilities allow SNS communities to choose between using SNSs that are provided as a service by the IC, where maintenance is as automated as possible, and SNSs that have full flexibility of how they can be evolved. Because of the fact that the possibilities for Option 2 are unbounded and that it is likely that this option will mainly be used by those who want to explore new designs themselves, we focus on Option 1 in the remainder of this design proposal.

#### Proposed deployment & upgrade process

The following canisters, on three different subnets, are involved in the proposed design:

* On the NNS subnet, the registry canister holds the blessed deployment path, as described above, which includes the hash of the SNS canisters’ wasm modules.
* On a new SNS subnet, a new SNS wasm module canister holds the actual SNS canisters' wasm modules.
* On an application subnet, there is a cycles wallet controlled by a developer that wants to initialize a SNS.

The following protocol describes the steps to initialize a SNS:

1. Using the cycles wallet, the developer calls the SNS wasm module canister to deploy an SNS. They specify the initial parameters that the SNS should have (e.g., initial accounts on the ledger and initial neurons, token name etc). Also, along with the call, they send an initial cycle amount to pay for the SNS.
2. Upon receiving this call, the SNS Wasm module canister checks if the chosen initial parameters are well-formed (e.g., there are ledger accounts for all neurons etc) and if there is still space for more SNSs on the subnet.
3. If all these checks are successful, the SNS wasm module canister initiates the deployment of the three SNS canisters governance, ledger, and root.

The following describes how the IC automatically maintains SNSs as part of the system:

1. The NNS community can at any time bless new SNS deployments.
a) To do so, anyone can make a proposal in the NNS which, upon adoption, adds a new blessed SNS deployment to the registry. As mentioned above, this registry entry refers to the SNS canisters by specifying the hash of their wasm modules.
b) Anyone can then upload the actual canister wasm modules to the SNS wasm module canister on the SNS subnet. The SNS wasm module canister will only accept wasm modules for which the hash is mentioned in a blessed deployment on the registry.

2. The SNSs on the SNS subnet regularly query the registry to learn if there are new blessed deployments. If this is the case, they pull the respective wasm modules from the SNS wasm module canister and initialize an upgrade to this new version.

User experience:

We propose to integrate the necessary calls that a user is expected to make to initialize an SNS into dfx. As many developers are already familiar with the tool, we think this is a good solution for the first version.

While we envision a frontend that makes this functionality available to an even wider range of users, we propose to solve this in a separate design proposal.

#### Control

##### New SNS wasm module canister

We propose that the SNS wasm module canister is controlled by the NNS root canister, similarly to the canisters on the NNS.

##### SNS canisters

Within each SNS, we propose that the root canister controls the governance and ledger canister and that the governance canister controls the root canister. This means that whenever an update is triggered, the respective controlling canisters are responsible for upgrading the controlled canisters.

##### Dapp

The main motivation for SNSs is of course that they can control dapps in a decentralized manner. We deliberately did not include the dapp in the above design to allow for different use cases. At any point after the SNS exists, the dapp’s control can be changed to the SNS.

In particular, this allows for the following use cases:

* Developers who control an existing dapp can initialize an SNS and when it exists, they can add the SNS as the dapp’s controller and remove themselves from the set of controllers.
* Developers may choose to add a SNS as the dapp’s controller but, in the beginning, also remain controllers themselves until they gain sufficient confidence that the SNS works, at which point they can remove themselves as controllers.
* Developers can set up an SNS without an existing dapp. They can then, for example, use the SNS to get initial funding, vote on what the dapp should look like etc, and then at a later point in time create the dapp and assign the control to the SNS.

#### The new SNS subnet

As stated above, we propose that the SNS canisters are deployed on a new subnet. We next present more details regarding the design of this subnet.

##### Subnet type

Currently, there are system subnets (e.g., the NNS) and application subnets. We propose to introduce a third subnet type for the SNSs.

The reason for this is that while we propose similar configurations for the SNS subnet as for the system subnets, the canisters on the SNS subnet should pay cycles (which the NNS canister do not).

##### Replication

As SNSs are security critical applications and as there are dependencies between the SNS subnet and the NNS (the NNS controls the SNS wasm module canister), we propose that the new subnet should have 34 nodes.

##### Cycle costs

While we are still working on a concrete proposal, the high level idea is that it should be more expensive to have canisters running on the SNS subnet than on an application subnet.

The main reason for this is that the subnet has a larger number of nodes than the application subnets.

#### Scalability

We propose to start with one SNS subnet that can host around 10-15 SNSs according to initial estimations. If there is more demand, a new SNS subnet can be created the same way as other new subnets can be added to the IC, by proposals over the NNS. On this new subnet, the NNS can then deploy a new SNS wasm canister, and the same protocols as described above can be done. Following the same process, more and more SNS subnets can be created.

## Security

We consider this to be a security critical feature, as the upgrades of dapps and the value of associated governance tokens are at risk if there are vulnerabilities. We thus already initiated a design review by DFINITY’s security team and plan to also have thorough security code reviews.

## Alternatives considered

Some different approaches that we could have taken and why we decided against them.

* Why not hold off on releasing until we have all SNS features, including initial token distribution etc., implemented?
As argued above, we decided against this as it seemed to be a wish from the community to be able to use and experiment with the individual components as soon as possible.
* Why not omit the root canister and just have two canisters?
The reason for this is that the governance canister cannot upgrade itself. Upgrading a canister involves stopping the canister, installing the new code, and starting it again. This cannot be triggered by a canister itself. Moreover, we don’t believe it is a good idea to make the ledger canister more complex by adding this functionality to the ledger canister. Therefore, similarly to the NNS, we propose to have a root canister.
* Why is the root canister not only controlling the governance canister and the governance canister controls all other canisters?
There seems to be no strong reasons for not choosing this alternative. As both options seemed equally good, we preferred the above proposed control hierarchy as this is closest to what we have in the NNS and thus closer to what we have already tested and used extensively.
* Why not place the SNS wasm module canister on the NNS?
The reason for this is that currently the crossnet message limit is smaller than the size of the canister wasms that we need to communicate from the SNS wasm module canister to the SNS canisters when they are upgraded. While we are planning a feature to compress canisters, we are not sure when this feature will be finished and therefore propose to go with this solution for now.
* Why not have the SNS wasm module canister control all SNS canisters and notify them or start upgrades when new canister upgrades are available (i.e., implement a “push” rather than a “pull” mechanism for upgrades)?
For any canister that controls another canister that can either be on a malicious subnet or have bugs, there is the risk that the controlling canister cannot be stopped and thus not be upgraded. This is the case both for a canister that directly controls a buggy canister and for a canister that controls such a canister via a longer chain of control (i.e., A controls B, B controls C, and C is buggy). As we absolutely want to avoid that we cannot upgrade the NNS canisters anymore, we propose to avoid any control chain from the NNS to the SNS canisters as the latter necessarily need to call out to dapp canisters on less secure application subnets. Again, we are working on a more general solution for this problem, but suggest a design that is not dependent on this solution for efficiency reasons.

## Risks and mitigations

This feature involves many different layers of the IC stack. It requires changes to existing canisters, the implementation of new canisters, the realisation of a new subnet type, and new communications between canisters on different subnets.

To avoid incompatibilities between the different components and to mitigate the risks specific to different components, we included experts from many different teams in the design phase.

Furthermore, we mitigate the risk of unforeseen findings by involving the testing and security experts early in the process.

## Community conversation & timeline

We propose the following approach to discuss the design of this feature:

1. Feb 10th-15th: Design discussion on this forum thread
2. Feb 15th: Community conversation about the topic
3. Afterwards: start implementation of the design, potentially adjusted with feedback from Steps 1 & 2

There has already been [a motion proposal](https://dashboard.internetcomputer.org/proposal/35642) on the general idea of SNSs that has been adopted on Dec 21, 2021. We consider this design as a concrete, detailed suggestion on how to realize parts of this larger design / idea. Therefore, we propose not to submit a separate motion proposal for this design and rather discuss it in the forum here and in the community conversation. Apart from feedback on the design, we are also happy to get feedback on and discuss this approach.

-------------------------

KevLoui | 2022-02-11 10:43:12 UTC | #2

Hi @lara , thank you so much for this excellent summary! I'm looking forward to seeing what people bring to this discussion.

-------------------------

lastmjs | 2022-02-11 22:01:23 UTC | #3

Just want to confirm, each SNS will be capable of controlling multiple canisters correct? I imagine that the root canister will be capable of becoming the controller for as many canisters as desired. Then the governance canister could receive proposals that upgrade any canister which is controlled by the root canister. Correct?

And about token distribution by the ledger canister, I'm hoping there will be support for different supply and minting schemes. For example, in a dapp I'm envisioning there will not be a fixed supply, and the SNS will need to be able to mint tokens based on specific user actions. There will also need to be burning.

-------------------------

lastmjs | 2022-02-11 22:09:01 UTC | #4

Will there be the option to convert an SNS on an application subnet to an SNS on the SNS subnet and vice versa?

I can imagine a scenario where an SNS starts off running well with the default code and configuration capabilities, and then the community deciding that they want to venture off with some experiments. And then I can imagine those experiments being upstreamed into the blessed SNS code, and thus that SNS might want to convert back to the SNS subnet.

-------------------------

paulyoung | 2022-02-12 22:01:36 UTC | #5

@lara are there any plans to generalize the voting options to allow them to be customizable?

The options we have for proposals in the NNS today could be represented as the sum type `Adopt | Reject` but I can anticipate wanting to make proposals with something different.

For questions that only need one answer like “How should we refer to Bitcoin on the IC?” we could use something like `ckBTC | icBTC | Other Text` 

It also works when asking questions like, “In which order should we work on things?”. Here we could use `Feature1 | Feature2 | Feature3 | Feature4 | Other Text`

-------------------------

jzxchiang | 2022-02-13 08:02:16 UTC | #6

Every time I read one of these proposals, I get this strange itch to purchase and stake more ICP... can't explain it.

-------------------------

jzxchiang | 2022-02-14 07:41:22 UTC | #7

I just went over the design—I think it's sensible. The "alternatives considered" section was especially illuminating.

A couple of questions:

1. This design proposes two paths to deploy/upgrade a SNS: "system-deployed" and "self-deployed". Am I correct in concluding that the whole concept of a blessed deployment is only necessary because we want to support self-deployed SNSs, and that if we hypothetically only supported "system-deployed" SNS then we wouldn't need a blessed registry (or even SNS wasm module canisters) at all? For example, the NNS doesn't have the concept of blessed deployments, presumably because there's only one canonical NNS deployment at any time (in contrast to SNS, where there could be multiple SNSs, some system-deployed, some self-deployed, each potentially running a different version).

2. Why is a SNS governance canister a controller of a SNS root canister? On the NNS, I believe the only controller of the NNS root canister is the NNS lifeline canister. The NNS governance canister is still able to tell the root canister to upgrade canisters without being its controller, I thought.

> As we absolutely want to avoid that we cannot upgrade the NNS canisters anymore, we propose to avoid any control chain from the NNS to the SNS canisters as the latter necessarily need to call out to dapp canisters on less secure application subnets.

3. I don't see any control chain from the NNS to SNS canisters here in this design. The NNS can bless new SNS deployments by adding new wasm hashes to the registry canister, but a separate client will then upload the actual canister wasm modules to the SNS wasm module canister. Or were you planning for that client to be the NNS itself upon proposal adoption?

4. When will the SNS ledger canister design be made available? That was actually listed as the first stage [here](https://forum.dfinity.org/t/open-governance-canister-for-sns-design-proposal/10224). My guess is that the ledger canister design will be the most controversial, and will probably need the most time to discuss.

Thanks for sharing!

-------------------------

lara | 2022-02-14 10:45:35 UTC | #8

Hi @lastmjs, thanks for the questions.

> each SNS will be capable of controlling multiple canisters correct?

Correct. Additional canisters can also be "added", i.e., set to also be controlled by the SNS, but just setting their controller to the SNS root too.

> And about token distribution by the ledger canister

The current thinking is that in the MVP, i.e., the very first version of the SNS, there will be no voting rewards and no minting / burning. I agree with you that this should be made flexible (this is why it should be thought through and we suggest to rather do it thoroughly in a follow up than just introduce a default that people might not want now). If you think this is something that is needed urgently, it would be good to understand so that we can take this into account for prioritising next features.

-------------------------

lara | 2022-02-14 11:01:02 UTC | #9

It is not intended that this is possible, at least in the first version.

Two concerns that I see with allows this:
1. I would say it is hard to define good criteria for what an SNS needs to satisfy to be allowed to "go back on the blessed track". Any intermediate updates that did not follow the blessed upgrade path might have introduced some inconsistencies or bugs, so it might be problematic to put those in the same category (regard "as secure / as well tested") as SNSs that always followed the well-tested path.
2. Currently the vision is that on the SNS subnet there are only SNSs that follow the automatic upgrades, i.e., follow the blessed upgrade path. This ensures that there are no canisters on this subnet that have (known) bugs for too long, as they all upgrade regularly. Also, with this we can ensure that all canisters "follow the same rules", e.g., don't use up too much memory etc. Having canisters on this subnet that divert from this can be a security risk. One could say that one could nevertheless allow SNSs to switch between the self-upgrade and automated upgrade version but that they have to be moved to a new subnet for this. This however might be quite some effort.

-------------------------

lara | 2022-02-14 11:07:30 UTC | #10

Hi @paulyoung , thanks for the question!

For the first version, we envision yes / no votes as in the NNS. 

Certainly, we can think about other voting schemes in the future, as the SNSs will continuously be evolved like other canisters on the IC!

I think when introducing the possibility for new voting schemes, there are a few things that we have to consider carefully. The following come to mind spontaneously:
* we have to define precisely what the different voting schemes mean. I.e., in your example "How should we refer to Bitcoin", would each voter only have one vote? Or can one assign weights to each possible answer? 
* we might have to bound the number of possible answers
* we would have to think about how following would work for these new voting schemes (or maybe just say that following only kicks in for the yes / no votes?)
* once we have a frontend, we would have to think about how we can distinguish these types of proposals from the yes / no ones so that we can have user friendly interfaces for reading and voting on such proposals.

-------------------------

lara | 2022-02-14 11:46:44 UTC | #11

Thanks for reviewing the design so carefully.

Let me try to answer your questions:

1. Good question. Let me answer the questions regarding whether we need the blessed deployments and the SNS was module canister separately:
 a)  I think even if we only had system-deployed SNSs, there are some advantages to bless the deployments. I think the main reason for this is that in contrast to the NNS deployment, there are multiple SNSs. So it could for example be that a new version is blessed, that some SNSs auto-upgrade, but that the upgrade fails for some other SNSs (for whatever reason). Having the blessed deployments, the SNSs where something went wrong can then e.g., "try again" or we can bless alternative paths to help them get back on the "blessed path". I agree though that there might be alternatives without this, but I like that it also has the extra advantage of making the blessed path available for those who want to self-deploy.
b) you also ask "... we hypothetically only supported “system-deployed” SNS then we wouldn’t need a blessed registry (**or even SNS wasm module canisters**) at all". I would say for the SNS wasm module canister it is the opposite. If we only supported the self-deployment, I think we would not need it, as anyone on such an SNS would build the new canister wasm and include it in a proposal to upgrade the SNS (i.e., include it in an ingress message). We only have the canister for the system-upgrades: there, we don't want a separate ingress message for each SNS that is upgraded, we want things to be as automatic as possible. Therefore, we put the canister wasms once in this new canister and the SNSs can then just "take" the version from there.

2. This is correct. Especially, "The NNS governance canister is still able to tell the root canister to upgrade canisters without being its controller" is also correct. The reason for governance to be root's controller is not for upgrades of other canisters but in case the root canister has to be upgraded itself. Then, we need a canister that can stop root, install the new canister code, and restart root. You are right that on the NNS we have the lifeline canister for this (adding a little more independence, e.g., the lifeline is also written in motoko). We felt that this extra indirection is not needed on the SNS and that the governance canister could just take on this job of upgrading root. Especially, once could say that if something goes terribly wrong with the NNS this is still worse that if something goes wrong with the SNS as in the latter case we might still use the NNS to recover the SNS subnet.

3. "I don’t see any control chain from the NNS to SNS canisters here in this design." Right, I agree that this should be the case. The "we absolutely want to avoid.." is part of the reason why we did **not** choose the alternative of having the SNS wasm module canister control the SNSs, as with this alternative this requirement would not be met. So to be clear: yes, in the current design there should not be any control chain from the NNS to the SNS canisters. Do you have a suggestion how I can make this clearer in the explanation of the last alternative? 

4. The vision here is to generalise the NNS ledger canister so that it can be used with other kinds of tokens and then use this for the first version of the SNS. This is already being implemented atm. I am not sure where the changes will be presented, but can ask internally.

-------------------------

lastmjs | 2022-02-14 15:25:54 UTC | #12

Eventually this might be nice but I don't think it's a high priority, thanks for the explanation

-------------------------

lastmjs | 2022-02-14 15:27:38 UTC | #13

[quote="lara, post:8, topic:10816"]
The current thinking is that in the MVP, i.e., the very first version of the SNS, there will be no voting rewards and no minting / burning. I agree with you that this should be made flexible (this is why it should be thought through and we suggest to rather do it thoroughly in a follow up than just introduce a default that people might not want now). If you think this is something that is needed urgently, it would be good to understand so that we can take this into account for prioritising next features.
[/quote]

So how will the initial supply be created? And where will it go? And it will have to be fixed and all created right at the beginning?

-------------------------

lara | 2022-02-14 15:38:04 UTC | #14

I would think that whoever deploys an SNS can choose the initial accounts on the governance canister and on the ledger. 
Thus, they could choose how many tokens are initially owned by which account on the ledger.
This will both define the initial supply and where these tokens are.
I could imagine that an SNS could e.g., have some tokens in the account that is owned by the SNS governance canister or the dapp canister, which can then be distributed as rewards or used for other means, decided by SNS proposals. 

But I can imagine some use cases for which one might want minting / burning from the start. So in these cases, I guess the communities can either choose to add this functionality themselves (and got the self-deployment path) or to wait a bit until new SNS features are also available.

-------------------------

lastmjs | 2022-02-14 15:43:21 UTC | #15

Minting and burning are crucial to the plans I have for the SNS. Locking into a fixed supply right away is problematic for me. I could possibly work with a fixed supply and allow the SNS to give our tokens from that fixed supply, but not elegant.

I don't know what other people are planning.

-------------------------

KevLoui | 2022-02-14 17:56:50 UTC | #16

I’d also be interested in some clarification around fixed token supplies. I suppose people who aren’t expecting minting and burning activity may be satisfied with this (I’d be interested in hearing about anyones plans that don’t require these mechanisms btw), but I’d prefer to at least have the option - early on - for a variable token supply.

-------------------------

lara | 2022-02-14 19:19:36 UTC | #17

Thanks, this is useful feedback. 
Are you able to elaborate a bit on what you would need from minting / burning (just in case you want to share)?

I.e., would you just require some fixed operation (such as rewards in the NNS) that can mint, or are you looking for something like a method "mint X tokens now" that can be called by the governance canister, or even something that just automatically mints a certain number of tokens per time period to some account ?

-------------------------

lara | 2022-02-14 19:38:44 UTC | #18

Thanks for this feedback! 

I think at the moment there is not much more clarification that I can provide, rather than stating that this is probably not feasible for the initial version of SNS governance canister that is also discussed [here](https://forum.dfinity.org/t/open-governance-canister-for-sns-design-proposal/10224).

But as already stated in my other answers, it is valuable to get the feedback that there is some need for this, so that we can take this into account when prioritising next steps.
Also, in case you have particular use cases in mind for minting / burning, I would be happy to learn those!

-------------------------

lastmjs | 2022-02-14 21:43:32 UTC | #19

What I have in mind is the governance canister being able to mint/burn anytime at will. This capability will be used to issue tokens when users have performed certain actions, and those tokens will be minted and added to the supply in real time. Other user actions will cause tokens to be burned, removing them from the supply in real time.

I also think it would be valuable to have a "mint X token now" governance method, so that proposals can be made to pay out ad hoc.

The projects I have in mind are probably all going to have a variable supply, minting and burning programmatically based on user actions and proposals.

-------------------------

jzxchiang | 2022-02-15 06:56:45 UTC | #20

Thanks for clarifying for 1 and 2. I think we're basically on the same page now.

> The “we absolutely want to avoid…” is part of the reason why we did **not** choose the alternative of having the SNS wasm module canister control the SNSs, as with this alternative this requirement would not be met.

I think the confusion lies when you say that "with this alternative this requirement would not be met".

Let's say the SNS wasm module canister controls the SNS canisters. How does the NNS control the SNS wasm module canister? Is it when a new deployment is blessed? For example, when a blessed deployment proposal is adopted, the NNS will not only update the hashes in the registry canister *but also* upload the actual wasm modules to the SNS wasm module canister (on each SNS subnet)?

> 1. The vision here is to generalise the NNS ledger canister so that it can be used with other kinds of tokens and then use this for the first version of the SNS. This is already being implemented atm. I am not sure where the changes will be presented, but can ask internally.

Oh interesting, I had assumed you would share the ledger design proposal on the forum, like you have done with the SNS governance canister and the deployment/upgrades in this post. In my mind, the ledger design proposal might be the most controversial, not the least.

-------------------------

jzxchiang | 2022-02-15 07:18:46 UTC | #21

Also, +1 on minting & burning tokens.

> I.e., would you just require some fixed operation (such as rewards in the NNS) that can mint, or are you looking for something like a method “mint X tokens now” that can be called by the governance canister, or even something that just automatically mints a certain number of tokens per time period to some account ?

I think both are valuable. In fact, the heartbeat "cronjob" feature of the IC is pretty unique and could lead to interesting tokenomics.

At least for me, I'd like a variable token supply mostly for token rewards. The alternative is a fixed token supply, where token rewards (e.g. for posting valuable content on a social dapp) are provided by a treasury account. I think that's much more limiting and even risky, as you can't predict how many users and thus rewards your dapp will have to give out. With a variable token supply, you could vary inflation based on user activity, time, etc.

Just like NNS rewards, I expect a variable token supply to be more useful for most dapps. After all, it's a generalization of a fixed token supply.

> or are you looking for something like a method “mint X tokens now” that can be called by the governance canister

I think this is an interesting question.

Let's say a dapp wants to algorithmically reward a user with X tokens for something they've done. Which approach is better?

1. The SNS ledger canister exposes a "mint token" method that only the dapp canister can call. (The governance canister wouldn't call it because the tokens are minted as a result of some business logic algorithm, not a governance proposal.) The dapp canister then calls that method, which mints X tokens and directly deposits the tokens into the specified user's account.

2. The SNS ledger canister exposes no custom method, and instead algorithmically mints tokens, depositing them into the account of the dapp canister (i.e. the reward pool or "treasury"). The dapp canister can then choose to transfer X of the newly minted tokens to the user.

Approach 1 is less safe, as the dapp canister could get hacked and then mint a bunch of tokens into the account of the hacker by calling the "mint token" method.

Approach 2 is less flexible, as the SNS ledger canister now needs to implement the algorithm to decide which users get how many tokens. What if that algorithm needs to be updated? Upgrading the ledger canister is possible via SNS governance proposals (the same way the dapp canister would be upgraded), but it's arguably more risky to upgrade a highly sensitive ledger canister than a dapp canister.

What do you think? I'm not sure which is better.

-------------------------

lara | 2022-02-15 10:06:24 UTC | #22

Thanks, that's helpful!

-------------------------

lara | 2022-02-15 10:15:14 UTC | #23

Thanks for explaining more.
> How does the NNS control the SNS wasm module canister? Is it when a new deployment is blessed?

No. When a new deployment is blessed, any principal can upload the (already blessed) wasm to the SNS wasm module canister. Since the SNS wasm module canister will check the registry and only allow versions that are already blessed there, this requires no interaction with the NNS (this was deliberately designed in this way).

However, we want a controller for the SNS wasm module canister in case we need to evolve it. We aim to keep the canister simple, but it can always be that we missed something or find a bug. For this case, to update the SNS wasm module canister, we need someone to control it and orchestrate such upgrades. As with other system cansiters, we propose that the NNS, more specifically the NNS root canister, is the one to do this. 

Does this clarify things?

> I had assumed you would share the ledger design proposal on the forum.

In the context of the SNS I would say the most important information is that we plan to use a ledger that is almost the same as in the NNS for the first version. If this is something that people would like to discuss, I guess here could be a good place.
If you are more interested in discussing the detailed improvements that are done on the ledger, then I can try to loop in the right people who can elaborate on this a bit more.

-------------------------

jzxchiang | 2022-02-16 07:18:04 UTC | #24

> As with other system cansiters, we propose that the NNS, more specifically the NNS root canister, is the one to do this.

Ah interesting, this is new information. Yeah, it makes more sense.

> If you are more interested in discussing the detailed improvements that are done on the ledger, then I can try to loop in the right people who can elaborate on this a bit more.

I think that would be helpful! Sorry for any trouble, but it would be a shame if SNS tokens aren't compatible with any of the DEX solutions being built by the community.

-------------------------

lara | 2022-02-16 10:46:02 UTC | #25

Hi @jzxchiang ,
so the idea would really be to use a ledger that is very similar to the ICP ledger for the SNSs. I think this is the most important point regarding how DEXs can integrate with the resulting SNS ledgers.

I talked to the team working on improving the ledger. The most important things that will be improved to make the ledger that we have more fit for other uses are: 
* one can give the token a name 
* one can decide on the fee on initialisation.

Later, I think the plan is also to remove `notify()` and use alternative ways to pay for services instead. Note that for staking tokens into neurons, where we originally used notify, we already changed to such an alternative protocol.

I hope this helps!

-------------------------

lara | 2022-02-18 15:17:50 UTC | #26

Thanks for the interesting ideas.

Let me maybe first provide a bit more context. You might already know this, but it might also be helpful for other readers.
So the ledger canister specifies and account that is the "minting account". Whoever controls this account can mint new tokens. If tokens are burned, they are also sent to this account. 
In the NNS, this account is the NNS governance canister's account. This allows the governance canister to mint new tokens when rewards are paid. 
I think this would still be an elegant solution for paying e.g., voting rewards in the SNS.

One can also imagine just adding a method on the governance canister that generalises this existing concept: a proposal that calls this method could then mint any tokens (from the governance canister) and send them to any other account (canister or other).

Now in terms of how users can be paid for something that they have done in the dapp:
1. Your first suggestion would probably imply that the dapp canister would control the minting account. I am not sure this is advisable. First, for the reason that you already stated, as the dapp might get hacked. This is even more concerning if the dapp is on a (currently) less secure subnet. Moreover, it would then be unclear how voting rewards can be paid. Also, I can imagine many use cases where a dapp consists of multiple canisters over time that can easily be added and removed from the SNS by just setting their controllers to the SNS or removing it. Having then one dapp canister with this power to mint might be undesirable.

2. Here you seem to suggest that the ledger canister itself controls the minting account. I think this is not how the current ledger design intended things to work. In general, we should probably be very cautious of adding more logic to the ledger, as it is now more or less just a database of accounts and transactions. For security (and probably also for integration), it is probably a good idea to keep the ledger canister as simple as possible. But the team working on the ledger could probably provide even more input here.

As a variant of 2., we could let the SNS governance mint tokens regularly and send them to the dapp canister's account. This would be similar to how voting rewards are now distributed in the NNS, except that the rewards would not be distributed to the voters but rather just to the dapp. 
I think apart from your concern that I share, another tricky thing here is how we can make this generic so that all SNSs can use the same canister code. Also, there might be multiple dapp canisters, so in some cases this might be more complex than just regularly minting tokens to one canister.

I thus think all of these options require some more thought regarding how we can make things generic (so that all/most SNSs can share the canister code) but flexible (so that SNSs have the choice). 
From the top of my head, it seems that having a manual proposal every now and then where some funds are just allocated to the right canister (e.g., one of the dapp canisters) and then have the logic how these rewards are algorithmically allocated to users based on their behaviors in the dapp canisters, might be a combination that can cover many use cases..

-------------------------

skilesare | 2022-02-23 22:23:15 UTC | #27

I was looking at this line:

https://github.com/dfinity/ic/blob/833c2db9a3b652e8306cf6e38a728317dc2627e5/rs/sns/governance/canister/governance.did#L202

type UpgradeGovernanceControlledCanister = record {
  new_canister_wasm : vec nat8;
  canister_id : opt principal;
};

And it gave me some concern that we wouldn't be able to upgrade to canisters > 2MB because of the Ingress limit.  There may be something else that makes this work, but, for example, the ICP ledger canister is over 2MB and we've had to jump through hoops to deploy it in the past.

-------------------------

jzxchiang | 2022-02-25 02:55:21 UTC | #28

> As a variant of 2., we could let the SNS governance mint tokens regularly and send them to the dapp canister’s account. This would be similar to how voting rewards are now distributed in the NNS, except that the rewards would not be distributed to the voters but rather just to the dapp.

So I actually want basically what the NNS does: mint tokens and give them to users. But instead of the NNS governance canister deciding how many tokens a user gets, some other dapp canister decides.

You mentioned the NNS's minting account is controlled by the governance canister but that the rewards go directly to the users / voters. I thought the newly minted tokens would be deposited into the governance canister's minting account? Can you explain how that flow works again?

That would be pretty much what I want.

-------------------------

lara | 2022-03-01 12:57:29 UTC | #29

Thanks for bringing up this concern.
I agree that this is something we have to solve as developers should be able to deploy the canisters on regular application subnets. 
To solve this, we can either ensure that the wasm module is small enough or implement some canister compression that can be used during the deployment.

In the design specifically addressed in this forum entry, SNSs would live on a special subnet and upgrade themselves to a blessed version that they pull from the SNS wasm modules canister. Here, the ingress limit is not relevant when the actual upgrades take place but rather when the new wasm modules are added to the SNS wasm module canister (but still then we need to have a solution to the problem). As this is a special subnet that anyways would have some configurations differently to other application subnets, we could also consider to have a slightly larger ingress limit in the beginning.
Of for uses on normal application subnets we still need another solution as mentioned above.

-------------------------

Maxfinity | 2022-03-02 08:40:37 UTC | #30

[quote="lara, post:29, topic:10816"]
I agree that this is something we have to solve as developers should be able to deploy the canisters on regular application subnets.
[/quote]
Hi Lara, why was the notify method deprecated again? I think there are some advantages to using notify that you may not want to give up. Notify can be used in conjunction with canister_inspect message to ensure that only people with a balance in the native token who would be billed a fee  can call that method.

This is not the case with transfer_from and approve or other methods. I have sent you an email about the issue and would be keen to hear your thoughts.

-------------------------

lara | 2022-03-02 15:18:54 UTC | #31

Sure, let me try to explain how it currently works in the NNS:

There is one special ledger account, the *minting account*, that is controlled by the governance canister in the NNS (but each ledger allows you to specify who controls that account). You can imagine that this accounts holds the "dead tokens". If a token is burned, it is effectively transferred to this account. If a token is minted it is effectively "taken from this account" and sent to another account.

In the NNS, the governance canister controls this account, meaning that it can decide when new tokens are minted (= sent from this account). 
This currently happens in two places:
1) when *node providers* are paid new tokens are minted: this means that the tokens are transferred from the minting account to the node providers' accounts (I am not sure from the top of my head if this a transfer to their ledger account or to a neuron of whether both is allowed).
2) when *voting rewards* are allocated, this is first tracked as "maturity" in the neurons. Only later the tokens corresponding to the maturity are minted, which means again that at that point the tokens are transferred from the minting account to another account. This can either be caused by *spawning* this maturity into a new neuron (in this case the tokens are minted and transferred to a new neuron's account), *merging* the maturity (in this case the tokens are minted and transferred to the existing neuron's account, i.e., the neuron is "topped up"), or *disbursing* a neuron to a target account (in this case the tokens equivalent of the maturity are minted and transferred together with the neuron's stake to the target account). 

Does this make things clearer?

-------------------------

jzxchiang | 2022-03-03 01:19:28 UTC | #32

Thanks, yeah this clears things up.

What I'm still unsure about is who should control the minting account. If the SNS governance canister controls it, then that is fine if you mint rewards for voting on governance proposals. But what if you want to mint (or burn) tokens in response to other activities, for example moderating user content? That doesn't really fall under the dominion of governance. That's why I suggested a dapp canister.

Also, should the "controller" of the minting account be a canister with no controllers? In the case of the governance canister, I believe it cannot upgrade itself? Isn't it controlled by the NNS root canister?

-------------------------

lara | 2022-03-03 10:32:13 UTC | #33

> What I’m still unsure about is who should control the minting account. If the SNS governance canister controls it, then that is fine if you mint rewards for voting on governance proposals. But what if you want to mint (or burn) tokens in response to other activities, for example moderating user content? That doesn’t really fall under the dominion of governance. That’s why I suggested a dapp canister.

Yes, I see your point here. The question is also if on each distribution of rewards new tokens need to be minted right at this minute. One could also decide by vote how many tokens are minted and given to the dapp canister's ledger account and those tokens are then, depending on the activitiy of the dapp canister, further distributed by the dapp canister to the users. 
This would have the advantage that the dapp canister, that is potentially on a less secure subnet, does not have the power to mint just freely.

But I think different models are conceivable and likely for different SNSs and how tokens are used, different settings will be best.

> Also, should the “controller” of the minting account be a canister with no controllers?

I am not sure what you mean here. Why should the controller of the minting account be a canister without controllers? Do you see a problem if this is not the case?

> In the case of the governance canister, I believe it cannot upgrade itself? Isn’t it controlled by the NNS root canister?

Right, the governance canister cannot upgrade itself but it is controlled and can thus be upgraded by the root canister. This is true both in the NNS and in the SNS. 
So in the setting that we envision, *each* canister will have a controller to be able to continuously evolve the canisters, although the actual control over them is decentralised, i.e., only as a result of a proposal these canisters are upgraded by their respective controller canister.

-------------------------

daijianlin | 2022-03-25 12:00:48 UTC | #34

Any progress regarding SNS?

-------------------------

lara | 2022-03-25 17:06:20 UTC | #35

Thanks for asking! 
We are making good progress and should finish a first version of the SNS, specifically the governance and root canisters, in the next weeks. These two canisters, together with the existing ledger can then already be deployed as an SNS on any application subnet!
The more automated deployment and upgrade support and the new SNS subnet (which is the subject of this thread) will be tackled within the next milestone (Carbon).

We are currently defining which other SNS features should be included in the Carbon milestone and I plan to share our ideas on the roadmap and here on the forum soon (in the next week or two).
But I hope the above gives you a bit an idea on where we are!

-------------------------

Zane | 2022-03-25 18:50:28 UTC | #36

Will there be a token standard for tokens created by SNS?

-------------------------

JaMarco | 2022-03-25 19:24:19 UTC | #37

I think it will be the NNS ledger token standard.

-------------------------

skilesare | 2022-03-28 01:00:50 UTC | #38

Minting is the engine that has made almost every single crypto go. It needs to be supported or abstracted. For example, in btc instead of minting each block reward could be a payment from the Pre minted rewards account….although this has limits and restricts some economic adjustments.

-------------------------

lara | 2022-03-28 10:00:38 UTC | #39

Right. The SNSs will use the same ledger / token standard as the NNS.

-------------------------

lara | 2022-03-28 10:25:47 UTC | #40

Thanks for the input!
Within the Carbon milestone for SNS, we do plan to look into rewards / minting / burning.
I expect that by the Carbon milestone, we might only have a minimal variant for rewards that can then be customised further in the future. 
Once we start the rewards design process, we will share our thoughts and collect inputs here, as we know many of you have great ideas / inputs regarding this topic.

-------------------------

jzxchiang | 2022-04-01 04:39:58 UTC | #41

It's interesting how the ICP ledger canister chose to implement minting & burning using transfers from & to the minting account.

I wonder why it wasn't just implemented by directly increasing or decreasing the balances of users (and adjusting the total supply)? That seems to be the most straightforward implementation to me.

-------------------------

lara | 2022-04-05 12:45:26 UTC | #42

Sorry it took me a while to answer, but I wanted to check with the team working on the ledger to giver you a better answer. 

Mint/Burn are actually implemented as you suggest in the sense that minting & burning directly increase / decrease the users' balance. There is only a very thin translation layer in the send-endpoint which converts the supplied arguments to transfer/mint/burn action.
A motivation for keeping this in one endpoint was that it simplifies authorization for minting - if we had a separate mint endpoint, we would have to verify on the canister level if the caller is allowed to execute it (as potentially anyone would be able to call it). Now, the sender principal determines if a transaction is a minting transfer (meaning that no unauthorised principal can even "call" minting).

-------------------------

lara | 2022-04-06 14:44:07 UTC | #43

Hi all,
we are excited to share an update reagarding the SNS timeline in [this new forum post](https://forum.dfinity.org/t/sns-service-nervous-system-timeline/11963)!

-------------------------

lara | 2022-04-14 13:10:19 UTC | #44

**Refinement of the Design: Should the IC enforce unique token names on the SNS subnets?**

Within the design presented above, there are some remaining details to be decided. We plan to share them with you in this thread. Today, we would like feedback on whether the SNS subnets should enforce that all hosted SNSs use unique token names.

***TLDR;***
**We propose not to enforce unique token names on the SNS subnet and, should this be required, later just add a list of used token names (that are not required to be unique) to the SNS wasm modules canister. If a (unique) token name registry is desired, we propose that this is realised in a separate feature and also for non-SNS ledger canisters.**

*Introduction to the problem*

When deploying and initializing a SNS, a developer can, among other parameters, choose the token name and token symbol for the token to be used in the SNS ledger canister. Let’s focus on the token name in the rest of this post, as the discussion would be similar for the token symbol.

In the context of the above design, the question came up whether SNSs on the SNS subnets should have unique token names. That is, whether it should be prevented that an SNS can be deployed on a SNS subnet with a token name that is already used by another SNS. In this post, we would like to share our thoughts on this topic and ask you to provide feedback whether you agree with our conclusion.

*Pros and Cons*

We see at least the following Pros and Cons of enforcing unique SNS token names on the SNS subnets.

*Pros*

1. **Honest developers want unique token names.** It is likely in the interest of an honest developer who deploys a SNS to use a token name that is not currently used by another (popular) project. Preventing that different SNSs have the same token name achieves this goal to some extent.

2. **Users might be able to identify projects and tokens better if they use unique names.** If, in the future, there are tools that list all SNSs, it would help users to understand the different projects if none of the listed SNSs share the same token name.

*Cons*

1. **Uniqueness of SNS token names does not prevent token name clashes in the larger setting.** SNS tokens are not used in isolation. SNS tokens will be traded, for example on decentralized exchanges (DEXs) on the IC. Even if the uniqueness of token names is enforced on the SNS subnets, the same token names can still be used on ledger canisters that run on other IC subnets. Thus, DEXs are in any case required to identify tokens with additional information, for example by the SNS ledger canister ID. This is similar to some other blockchains, where smart contract addresses are provided to identify a given token. It can thus be argued that users must anyways be trained to identify tokens not only by names but also by additional means and that enforcing unique token names on the SNS subnets does not add any value for many contexts in which the tokens are used.

2. **Enforcing unique token names complicates the design and the implementation of the SNS feature.** Ensuring that SNS token names are unique requires a central place where all SNS token names are registered. This could, for example, be achieved by a SNS token name registry on the NNS subnet that maps token names to SNS ledger canister IDs. 
To ensure that two SNSs that are created simultaneously do not end up with the same token name, we would require a protocol that ensures synchronization. For example, the SNS wasm modules canister could first reserve a token name in the token name registry, then create the SNS, and in the end update the reserved name with the ID of the created ledger canister. Such an extension complicates the deployment process, as there are at least two additional cross-net message calls. This in turn makes the implementation, testing, and security reviews more involved which means that there is more risk for bugs and for a delay of feature delivery.
In addition, it is unclear how much additional design effort would be required for such a registry. For example, one would have to decide if such a name registry should just give out names on a first-come-first-serve basis. This adds further uncertainty to the feature and thus might be better addressed in a separate feature.
3. **If a token name registry is a requested feature, it should not be exclusive to SNSs on the SNS subnet.** If there is a need for a token name registry, where projects can register their token names and map them to their ledger canister IDs, it is unclear why this should only be accessible to ledger canisters that are hosted on the SNS subnet. It seems to be more in the spirit of decentralization to enable such a feature also for SNS ledger canister that are hosted on other subnets, as well as for other kinds of ledger canisters (i.e., implementing another token standard). If we accept this, then a token name registry is not required to be part of the SNS feature and should be done in a separate feature.

*Conclusion*

For the above reasons, we think that the *cons* outweigh the added value from enforcing unique token names on SNS subnets. If a registry of token names is of interest to the community, we suggest that this registry should be accessible to a wider range of tokens on the IC rather than just to ledger canisters on the SNS subnets. Such a token name registry should therefore be tackled in a feature that is independent of the SNSs.

Developers might still want to get an overview of token names that are already used by other SNSs and deliberately choose a new token name. This could, however, be achieved by a simpler solution: we could add to the SNS wasm module canisters, which exist on each SNS subnet, a list of already used token names. A developer who would like to deploy a new SNS with a new token name, could then read all these lists before choosing their token name.

*In **summary**, we propose*
* **not** to enforce unique token names on the SNS subnet and
* to add a **list of used token names** to the SNS wasm modules canister if this is a requested feature. We propose that this can even happen after the first SNS version for the Carbon milestone.

*Our ask*

We are looking for feedback, for example:

* Do you agree with our conclusion?
* Do you think that having an API to just list the SNS token names is useful?
* Do you have other ideas or concerns regarding this topic?

As always, we are looking forward to your questions and inputs!

-------------------------

Jesse | 2022-06-07 13:44:35 UTC | #45

1.) Thank you for your hard work. 

2.) what’s the current projected release date on the SNS canister?

-------------------------

lara | 2022-06-09 20:46:02 UTC | #46

Thanks for the question!
So the SNS will consist of multiple canisters. A first version of most of them (the governance canister, the root canister, and the ledger canister) already exist and are open sourced [here](https://github.com/dfinity/ic/tree/master/rs).
We will further improve those canisters and also plan to add an initial token swap canister (as described in [this forum post](https://forum.dfinity.org/t/sns-initial-token-swap/13591) .

The SNS release where SNSs are deployed on a special subnet (see [here](https://forum.dfinity.org/t/sns-deployment-and-upgrades-design-proposal/10816)) is targeted for the [Carbon milestone](https://dfinity.org/roadmap/?m=carbon).

-------------------------

skilesare | 2022-07-07 21:06:36 UTC | #47

[quote="lara, post:1, topic:10816"]
**A SNS that is self-deployed, manually upgraded, and hosted on an application subnet.** Any SNS community can choose to deploy the SNS code, which is open source, on an application subnet. They can then choose to follow the blessed upgrade path or deviate from this path, e.g., leaving out some versions, or even modify the canisters’ code in a completely different way. In this option, canister upgrades require active actions of the SNS community (i.e., the submission of a proposal) and the SNS community has to ensure that the upgrades are secure. This includes ensuring that alternative canister versions are compatible and that upgrades to newer versions do not break any functionality. Application subnets currently have less nodes than the SNS subnet and are therefore less secure.
[/quote]

@LightningLad91 see above for application mode

-------------------------

lara | 2022-07-28 18:24:52 UTC | #48

Hi all,

I am excited to report that we are working on implementing the last few pieces of this feature that are needed to get the SNSs going!

As we are implementing some of the details, we notice that we can slightly simplify the design compared to what we originally proposed above thanks to some improvements that happened in the meantime. We therefore wanted to share these updates with you.

**Blessed version in one SNS-W on the NNS subnet.**
In the original design, we proposed to hold the SNS canisters’ wasms in an SNS wasms modules canister (SNS-W) that is hosted on each SNS subnet and to hold the blessed SNS versions in the NNS registry. For upgrading the SNS to a new version, one would need to first update the registry with a new blessed version and then add the wasm of this version to all SNS-W canisters by an ingress message (and repeat this on all SNS subnets if there are multiple at some point) .
The main reason for this was that we thought that the SNS canister wasms were too big to be sent in cross-net messages from the NNS to the SNS.

In the meantime, we were able to reduce the wasms of the SNS canisters with some improvements. Therefore, we propose to now have one SNS-W canister on the NNS subnet rather than many of them accross SNS subnets. This allows that NNS proposals that bless new SNS versions also directly add the new wasm in SNS-W, without further user interaction. Also, as we only have one SNS-W canister, this simplifies synchronization across all SNS subnets (once there is the need for more than one).
As the SNS-W canister is already on the NNS subnet, we also propose to record the blessed SNSs in this canister rather than in the registry. This nicely separates concerns and allows to hold all the information relevant for SNSs in the same canister.

**The type of the SNS subnet**
Originally, we proposed that the SNS subnet will be a new type of subnet. We argued that this is needed as we needed some bounds that are the same as on a system subnet but other properties from an application subnet, for example that cycles must be paid for canisters.
Again, in the meantime we made some improvements that eliminated the need for special bounds. Therefore, we now propose that the SNS is of type “application subnet”. This means that it is like a regular subnet with the only difference that only blessed SNSs can be deployed on it.
This is beneficial, especially as the SNS code should anyways work on other application subnets to allow anyone to self-deploy an SNS.

**SNS upgrade triggering**
Finally, the original idea was that SNSs upgrade themselves, by checking on every heartbeat if there are new blessed versions in SNS-W. This would not only cause a lot of cross-net traffic but it would also take away some power from the SNS communities. 
Therefore, we now suggest that the SNS communities decide, with SNS proposals, *when* they want to upgrade to the next blessed SNS version. The SNSs can still only be upgraded according to the blessed deployment path, which also means that the SNS communities don’t have to be concerned with too much maintanance burden, but the SNS communities can decide at which moment they would like the upgrade.

We hope all these small improvements make sense to you and are happy to answer any questions that you might have!

-------------------------

dfisher | 2022-10-11 22:42:37 UTC | #49

Hi @lara,

I'd like to make a suggestion for the new SNS front end that is coming. For prospective and existing projects with SNS tokens, I believe it makes sense to provide both a link to the website and a link to a downloadable PDF of the SNS White Paper. I also believe we should add an empty template for folks who would like to add their own SNS White Paper. 

The OpenChat team has done a fantastic job of creating a great template for a SNS White Paper to provide prospective investors with the information they need to decide to invest or not. I would propose adding a template White Paper modelled on the structure of their White Paper for all future projects that prospective SNS projects can download and work from. 

We need to keep the bar high and imho if projects don't fill out the template sufficiently they should not be allowed to launch on the SNS. There are things prospective investors simply need to know to make informed decisions. 

Let me know what you think.

-------------------------

lara | 2022-10-21 15:28:09 UTC | #50

Hi @dfisher ,
thanks for the idea.
I happily take this feedback to a discussion where we plan to think again about what exactly should be included and displayed in which way in an NNS proposal to start an SNS decentralization sale.

Regarding the template: 
What I like about the template idea is that it make different projects more comparable and that it might set minimal requirements of information that is expected.
There are however a few comments / conerns that I have:
* I think all relevant parameters that are set should be visible and verifiable in the proposal. A white paper can then only serve as a declaration of what the team intends to do. I think we should be careful that this can then not be wrongly interpreted as any guarantee / contract.
* I personally think that such a template does not have to be defined by DFINITY but that the wider NNS community should come together and start defining what they expect from an SNS to support it with their vote. As you say, good examples will certainly set a bar and can serve as models for what is expected in future proposals.
* I am not sure it is the right time to create such a template before we see the first SNSs as it might be hard for the community to define what are convincing arguments without seeing any examples. I think if we go for a template it should be able to evolve over time. 
* I wonder if there is a one-fits-all template for this purpose as the different projects might have rather different goals. Each project might choose a bit a different way of how to represent the information, but it will be up to them to convince the NNS community about their project. Different form might be suitable for this in different cases.

-------------------------

